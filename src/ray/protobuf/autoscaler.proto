/*
This file defines an experimental interface designed for Ray
autoscalers.

It is currently unstable and under active development, but it is
intended to become stable and forwards-compatible in the future.
*/


syntax = "proto3";
option cc_enable_arenas = true;
package ray.rpc;

message ResourceBundle {
  // The fixed point resource size of the resource (granularity: 1/10000).
  map<string, int64> resources = 1;
}

// Type of placement group strategy.
enum PlacementStrategy {
  // Packs Bundles into as few nodes as possible.
  PACK = 0;

  // Places Bundles across distinct nodes or processes as even as possible.
  SPREAD = 1;

  // Packs Bundles within one node. The group is not allowed to span multiple nodes.
  STRICT_PACK = 2;

  // Places Bundles across distinct nodes.
  // The group is not allowed to deploy more than one bundle on a node.
  STRICT_SPREAD = 3;
}

enum QueueType {
  // A task that (assuming no deadlock can eventually be scheduled on the cluster.
  FEASIBLE_TASK = 0;

  // A task that the cluster does not have the correct resources to fulfill.
  INFEASIBLE_TASK = 1;

  // A actor that (assuming no deadlock can eventually be scheduled on the cluster.
  FEASIBLE_ACTOR = 2;

  // A actor that the cluster does not have the correct resources to fulfill.
  INFEASIBLE_ACTOR = 3;

  // A placement group that (assuming no deadlock can eventually be scheduled on the cluster.
  FEASIBLE_PLACEMENT_GROUP = 4;

  // A placement group that the cluster does not have the correct resources to fulfill.
  INFEASIBLE_PLACEMENT_GROUP = 5;

  // Represents a job's call to
  // `ray.autoscaler.sdk.request_resources()`. This type requests
  // resources to be available on the cluster but won't actually
  // utilize them.
  SDK_RESOURCE_REQUEST = 6;
}

// A workload (task/actor/placement group) unfulfilled by the the cluster's internal scheduler(s).
message QueuedResources {
  // The number of resources of this quantity. This should be
  // functionally equivalent to setting quantity=1 and repeating the
  // field many times.
  uint32 quantity = 1;

  // The queue type this resource comes from.
  QueueType type = 2;

  // If the queued resource represents an actor or task, there is
  // 1 entry in `bundles`. In a placement group, each bundle
  // receives its own entry.
  repeated ResourceBundle bundles = 3;

  // The placement strategy of bundles within this queued resources.
  PlacementStrategy placement_strategy = 4;
}

message GetAllQueuedResourcesRequest {
}

message GetAllQueuedResourcesResponse {
  // The set of all queued resources.
  repeated QueuedResources queued_resources = 1;
}

message NodeInfo {
  // State of a node.
  enum NodeState {
    // The node has not joined the cluster yet.
    PENDING = 0;

    // The node has joined the cluser and is healthy.
    ALIVE = 1;

    // The node is marked for removal, but it may not be safe to remove it yet.
    DRAINING = 2;

    // The node is no longer active in the cluster it is safe to remove it.
    DEAD = 3;
  }

  // The state of the node.
  NodeState node_state = 1;

  // TODO: Ideally we unify GCS's node id with the autoscaler's here.
  // The ID of node.
  bytes node_id = 2;

  // The address of the node. This information is primarily
  // intended for user-facing observability. The processes at this
  // address don't provide a stable api.
  string node_manager_address = 3;

  // The available fixed point resources (granularity 1/10000) of this node.
  map<string, int64> resources_available = 4;
  // The total fixed point resources (granularity 1/10000) of this node.
  map<string, int64> resources_total = 5;

  // The underlying host type (e.g. instance type or machine type).
  string host_type = 6;
}

message GetAllNodeStatusesRequest {
}

message GetAllNodeStatusesResponse {
  // The set of all nodes that ever were or ever will be in the cluster.
  repeated NodeInfo all_nodes = 1;
}

message SetNodeStateRequest {
  // Set a batch of node states.
  repeated NodeInfo batch_to_update = 1;
}

message SetNodeStateResponse {
  // Whether or not setting the node state succeeded.
  bool success = 1;
}


enum AutoscalerEventLevel {
  INFO = 0;
  WARNING = 1;
  ERROR = 2;
}

message PublishAutoscalerEventRequest {

  // The event level of the autoscaler event.
  AutoscalerEventLevel level = 1;

  // Autoscaler event type.
  string event_type = 2;

  // The autoscaler event message.
  string message = 3;
}

message PublishAutoscalerEventResponse {
  // True if GCS now claims respnsibility for communicating this event.
  bool success = 1;
}

service AutoscalerService {

  // Get the aggregated state of the cluster's resource queues.
  rpc GetAllQueuedResources(GetAllQueuedResourcesRequest) returns (GetAllQueuedResourcesResponse);

  // Get the aggregated state of the cluster's nodes.
  rpc GetAllNodeStatuses(GetAllNodeStatusesRequest) returns (GetAllNodeStatusesResponse);

  // Set the node state for a batch of nodes. Nodes not included will retain their existing state.
  rpc SetNodeState(SetNodeStateRequest) returns (SetNodeStateResponse);
}
