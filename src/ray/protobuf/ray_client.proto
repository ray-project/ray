// Copyright 2020 The Ray Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//  http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

syntax = "proto3";
option cc_enable_arenas = true;

package ray.rpc;

enum Type { DEFAULT = 0; }

// An argument to a ClientTask.
message Arg {
  enum Locality {
    INTERNED = 0;
    REFERENCE = 1;
  }

  // The type of argument this is -- whether a data blob or a reference.
  Locality local = 1;
  // The reference id, if a reference.
  bytes reference_id = 2;
  // A data blob, if passed in-band.
  bytes data = 3;
  // How to decode this data blob.
  Type type = 4;
}

// A message representing the valid options to modify a task exectution
//
// TODO(barakmich): In the longer term, if everything were a client,
// this message could be the actual standard for which options are
// allowed in the API. Today, however, it's a bit flexible and defined in the
// Python code. So for now, it's a stand-in message with a pickle field, but
// this is forwards-compatible with deprecating that field and instituting
// strongly defined and typed fields, without migrating the original ClientTask.
message TaskOptions {
  bytes pickled_options = 1;
}

// Represents one unit of work to be executed by the server.
message ClientTask {
  enum RemoteExecType {
    FUNCTION = 0;
    ACTOR = 1;
    METHOD = 2;
    STATIC_METHOD = 3;
    NAMED_ACTOR = 4;
  }
  // Which type of work this request represents.
  RemoteExecType type = 1;
  // A name parameter, if the payload can be called in more than one way
  // (like a method on a payload object).
  string name = 2;
  // A reference to the payload.
  bytes payload_id = 3;
  // Positional parameters to pass to this call. Deprecated in favor of data field
  repeated Arg args = 4;
  // Keyword parameters to pass to this call. Deprecated in favor of data field
  map<string, Arg> kwargs = 5;
  // The ID of the client namespace associated with the Datapath stream
  // making this request.
  string client_id = 6;
  // Options for modifying the remote task execution environment.
  TaskOptions options = 7;
  // Options passed to create the default remote task excution environment.
  TaskOptions baseline_options = 8;
  // A namespace parameter.
  string namespace = 9;
  // Serialized args and kwargs. Under the hood this should just be a pickled
  // tuple containing (args, kwargs).
  bytes data = 10;
  // Identifies which chunk the serialized args and kwargs belong to
  int32 chunk_id = 11;
  // Total number of chunks
  int32 total_chunks = 12;
}

message ClientTaskTicket {
  // Was the task successful?
  bool valid = 1;
  // A reference to the returned values from the execution.
  repeated bytes return_ids = 2;
  // If unsuccessful, an encoding of the error.
  bytes error = 3;
}

// Delivers data to the server
message PutRequest {
  // The data blob for the server to store.
  bytes data = 1;
  // The ID generated by the client for tracking this object before it has a
  // real reference ID. Used to late-bind references made on the client side
  // during pickling.
  // For example, the data field in this message contains an Actor class that
  // refers to its own ActorClass -- which needs to know the ObjectRef
  // ID that will return from this RPC, but that clearly doesn't exist yet.
  //
  // Empty if no late binding is possible, as in a normal put().
  bytes client_ref_id = 2;
  // Identifies which chunk the data belongs to
  int32 chunk_id = 3;
  // Total number of chunks
  int32 total_chunks = 4;
  // Total size in bytes of the data being put
  int64 total_size = 5;
  // The owner of the put
  bytes owner_id = 6;
}

message PutResponse {
  // The reference ID for the data that the server has stored.
  bytes id = 1;

  // Whether or not the put was successful.
  bool valid = 2;

  // An error blob (for example, an exception) on failure.
  bytes error = 3;
}

// Requests data from the server.
message GetRequest {
  // The reference ID for the requested object data
  repeated bytes ids = 4;
  // Length of time to wait for data to be available, in seconds. Zero is no timeout.
  float timeout = 2;
  // Whether to schedule this as a callback on the server side.
  bool asynchronous = 3;
  // The chunk_id to start retrieving data from, in case the request is interrupted
  // after partial retrieval by a disconnect
  int32 start_chunk_id = 5;

  // Deprecated fields.
  bytes id = 1 [deprecated = true];
}

message GetResponse {
  // Whether or not the data was successfully retrieved
  bool valid = 1;
  // The data blob containing a list of serialized objects, on success.
  // Total size and the order of objects match those in `GetRequest.ids`.
  bytes data = 2;
  // An error blob (for example, an exception) on failure.
  bytes error = 3;
  // Identifies which chunk the data belongs to
  int32 chunk_id = 4;
  // Total number of chunks
  int32 total_chunks = 5;
  // Total size in bytes of the data being retrieved
  uint64 total_size = 6;
}

// Waits for data to be ready on the server, with a timeout.
message WaitRequest {
  // The IDs of the data to wait for ready status.
  repeated bytes object_ids = 1;
  // How many of the above ids to wait for before returning.
  int64 num_returns = 2;
  // How long to wait for these IDs to become ready.
  double timeout = 3;
  // The Client namespace associated with the Datapath stream that holds these IDs.
  string client_id = 4;
}

message WaitResponse {
  bool valid = 1;
  repeated bytes ready_object_ids = 2;
  repeated bytes remaining_object_ids = 3;
}

message ClusterInfoType {
  // Namespace the enum, as it collides in the overall package.
  enum TypeEnum {
    IS_INITIALIZED = 0;
    NODES = 1;
    CLUSTER_RESOURCES = 2;
    AVAILABLE_RESOURCES = 3;
    RUNTIME_CONTEXT = 4;
    TIMELINE = 5;
    PING = 6;
    DASHBOARD_URL = 7;
  }
}

message ClusterInfoRequest {
  ClusterInfoType.TypeEnum type = 1;
}

message ClusterInfoResponse {
  message ResourceTable {
    map<string, double> table = 1;
  }

  message RuntimeContext {
    bytes job_id = 1;
    bytes node_id = 2;
    string namespace = 3;
    string runtime_env = 4;
    bool capture_client_tasks = 5;
  }

  ClusterInfoType.TypeEnum type = 1;
  oneof response_type {
    string json = 2;
    ResourceTable resource_table = 3;
    RuntimeContext runtime_context = 4;
  }
}

message TerminateRequest {
  message ActorTerminate {
    bytes id = 1;
    bool no_restart = 2;
  }
  message TaskObjectTerminate {
    bytes id = 1;
    bool force = 2;
    bool recursive = 3;
  }

  string client_id = 1;
  oneof terminate_type {
    ActorTerminate actor = 2;
    TaskObjectTerminate task_object = 3;
  }
}

message TerminateResponse {
  bool ok = 1;
}

message KVExistsRequest {
  bytes key = 1;
  optional bytes namespace = 2;
}

message KVExistsResponse {
  bool exists = 1;
}

message KVGetRequest {
  bytes key = 1;
  optional bytes namespace = 2;
}

message KVGetResponse {
  // Not set when key does not exist.
  optional bytes value = 1;
}

message KVPutRequest {
  bytes key = 1;
  bytes value = 2;
  bool overwrite = 3;
  optional bytes namespace = 4;
}

message KVPutResponse {
  bool already_exists = 1;
}

message KVDelRequest {
  bytes key = 1;
  bool del_by_prefix = 2;
  optional bytes namespace = 3;
}

message KVDelResponse {
  int32 deleted_num = 1;
}

message KVListRequest {
  bytes prefix = 1;
  optional bytes namespace = 2;
}

message KVListResponse {
  repeated bytes keys = 1;
}

message ClientPinRuntimeEnvURIRequest {
  string uri = 1;
  int32 expiration_s = 2;
}

message ClientPinRuntimeEnvURIResponse {}

message InitRequest {
  // job_config of ray.init
  bytes job_config = 1;
  string ray_init_kwargs = 2;
  int32 reconnect_grace_period = 3;
}

message InitResponse {
  bool ok = 1;
  string msg = 2;
}

message PrepRuntimeEnvRequest {
}

message PrepRuntimeEnvResponse {
}

message ClientListNamedActorsRequest {
  bool all_namespaces = 1;
}

message ClientListNamedActorsResponse {
  string actors_json = 1;
}

service RayletDriver {
  rpc Init(InitRequest) returns (InitResponse) {
  }
  rpc PrepRuntimeEnv(PrepRuntimeEnvRequest) returns (PrepRuntimeEnvResponse) {
  }
  rpc GetObject(GetRequest) returns (stream GetResponse) {}
  rpc PutObject(PutRequest) returns (PutResponse) {
  }
  rpc WaitObject(WaitRequest) returns (WaitResponse) {
  }
  rpc Schedule(ClientTask) returns (ClientTaskTicket) {
  }
  rpc Terminate(TerminateRequest) returns (TerminateResponse) {
  }
  rpc ClusterInfo(ClusterInfoRequest) returns (ClusterInfoResponse) {
  }
  rpc KVGet(KVGetRequest) returns (KVGetResponse) {
  }
  rpc KVPut(KVPutRequest) returns (KVPutResponse) {
  }
  rpc KVDel(KVDelRequest) returns (KVDelResponse) {
  }
  rpc KVList(KVListRequest) returns (KVListResponse) {
  }
  rpc KVExists(KVExistsRequest) returns (KVExistsResponse) {
  }
  rpc ListNamedActors(ClientListNamedActorsRequest)
      returns (ClientListNamedActorsResponse) {
  }
  rpc PinRuntimeEnvURI(ClientPinRuntimeEnvURIRequest)
      returns (ClientPinRuntimeEnvURIResponse) {}
}

message ReleaseRequest {
  // The IDs to release from the server; the client connected on this stream no
  // longer holds a reference to them.
  repeated bytes ids = 1;
}

message ReleaseResponse {
  // For each requested ID, whether or not it was released.
  repeated bool ok = 2;
}

message ConnectionInfoRequest {
}

message ConnectionInfoResponse {
  // The number of data clients connected to the server, including the caller.
  int32 num_clients = 1;
  // The Ray version (e.g., "1.2.0").
  string ray_version = 2;
  // The Ray commit (git sha1 hash).
  string ray_commit = 3;
  // The Python version (e.g., "3.7.2").
  string python_version = 4;
  // The protocol version of the server (e.g., "2020-02-01").
  string protocol_version = 5;
}

message ConnectionCleanupRequest {
  // Explicitly request that connection is cleaned up for graceful shutdown
}

message ConnectionCleanupResponse {
  // Acknowledge cleanup request
}

message AcknowledgeRequest {
  // Used to acknowledge that all requests up to the given req_id have been
  // received
  int32 req_id = 1;
}

message DataRequest {
  // An incrementing counter of request IDs on the Datapath,
  // to match requests with responses asynchronously.
  int32 req_id = 1;
  oneof type {
    GetRequest get = 2;
    PutRequest put = 3;
    ReleaseRequest release = 4;
    ConnectionInfoRequest connection_info = 5;
    InitRequest init = 6;
    PrepRuntimeEnvRequest prep_runtime_env = 7;
    ConnectionCleanupRequest connection_cleanup = 8;
    AcknowledgeRequest acknowledge = 9;
    ClientTask task = 10;
    TerminateRequest terminate = 11;
    ClientListNamedActorsRequest list_named_actors = 12;
  }
}

message DataResponse {
  // The request id that this response matches with.
  int32 req_id = 1;
  oneof type {
    GetResponse get = 2;
    PutResponse put = 3;
    ReleaseResponse release = 4;
    ConnectionInfoResponse connection_info = 5;
    InitResponse init = 6;
    PrepRuntimeEnvResponse prep_runtime_env = 7;
    ConnectionCleanupResponse connection_cleanup = 8;
    ClientTaskTicket task_ticket = 10;
    TerminateResponse terminate = 11;
    ClientListNamedActorsResponse list_named_actors = 12;
  }
  // tag 9 is skipped, since there is no AcknowledgeResponse
  reserved 9;
  reserved "acknowledge";
}

service RayletDataStreamer {
  rpc Datapath(stream DataRequest) returns (stream DataResponse) {
  }
}

// A request to change the quantity or type of the logs
// currently being streamed. Initially, all logs are disabled.
message LogSettingsRequest {
  // Set to recieve logs.
  bool enabled = 1;
  // At what loglevel should logs be forwarded on the stream.
  int32 loglevel = 2;
  // TODO(barakmich): More log filtering options.
}

message LogData {
  // The message data in the log
  string msg = 1;
  // The loglevel at which this log should be displayed.
  // * level > 0: Log leveling as per python's logging library
  // * level == -1: stdout (fd 1)
  // * level == -2: stderr (fd 2)
  int32 level = 2;
  // The name of the logger that generated this message.
  string name = 3;
}

service RayletLogStreamer {
  rpc Logstream(stream LogSettingsRequest) returns (stream LogData) {
  }
}
