// Copyright 2017 The Ray Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//  http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

syntax = "proto3";
option cc_enable_arenas = true;

package ray.rpc.autoscaler;
import "src/ray/protobuf/autoscaler.proto";

// A node type that's available for the cluster.
message InstanceType {
  // the name of the instance type. e.g. "m4.large"
  string type_name = 1;
  // avaialble resources on the node. such as {"CPU": 4, "GPU": 1}
  map<string, double> resources = 2;
}

message GetAvailableInstanceTypesRequest {}

message GetAvailableInstanceTypesResponse {
  repeated InstanceType instance_types = 1;
  // number of instances that are available for starting.
  // this can change if the cloud provider has a limit on
  // number of instances that can be started.
  int64 available_instances = 2;
}

// Represents the state of a launched instance.
// An instance is considered launched as long as
// it has a unique instance_id associated with it.
//
// Note a launched instance may be DEAD. In this case,
// the state will be garbage collected after some timeout
// period (by default 30 minutes).
message Instance {
  enum InstanceStatus {
    // The unspecified state
    // TODO: we should not be using this state.
    UNKNOWN = 0;
    // The instance is queued to be allocated.
    QUEUED = 1;
    // The instance is requested to be allocated - follows from the QUEUED state.
    REQUESTED = 2;
    // The instance is allocated - follows from the REQUESTED state.
    ALLOCATED = 3;
    // The instance allocation failed - follows from the REQUESTED state.
    ALLOCATION_FAILED = 4;
    // The instance is stopping - follows from the ALLOCATED state.
    STOPPING = 5;
    // The instance is stopped - follows from the STOPPING state.
    STOPPED = 6;
    // The instnace record is deleted from the storage - follows from the STOPPED state.
    GARBAGE_COLLECTED = 7;
  }

  enum RayStatus {
    // The unspecified state
    RAY_STATUS_UNKNOWN = 0;
    // The instance is installing ray.
    RAY_INSTALLING = 1;
    // Ray installation failed - follows from the RAY_INSTALLING state.
    RAY_INSTALL_FAILED = 2;
    // Ray started and connected to gcs - follows from the RAY_INSTALLING state.
    RAY_RUNNING = 3;
    // Ray node being stopped.
    RAY_STOPPING = 4;
    // Ray stopped - follows from the RAY_RUNNING state.
    RAY_STOPPED = 5;
  }

  // an unique id for the instance that's generated by the
  // instance manager. This may be optional if
  // the instance hasn't be started yet.
  string instance_id = 11;
  // the status of the instance.
  InstanceStatus status = 12;
  // the node type of the instance. This is the user defined ray instance type name
  // It's the key of `available_node_types` in the ray-schema.json, e.g.
  // `ray.head.default``
  // TODO: name to ray node type name 
  string instance_type = 13;
  // The corresponding total resources on the node.
  map<string, double> total_resources = 14;
  // Unix timestamp of the last time the instance get modified in milliseconds in
  // the instance storage.
  int64 last_modified_timestamp_at_storage_ms = 15;
  // the external id of the instance that's generated by
  // the cloud provider like AWS, GCP, etc.
  // Note this id can be reused by different instances.
  string cloud_instance_id = 16;
  // internal ip address of the instance.
  string internal_ip = 17;
  // external ip address of the instance.
  string external_ip = 18;
  // the monotonically increasing version number of the instance.
  int64 version = 19;
  // the status of the ray process on the instance.
  RayStatus ray_status = 20;
  // the status history of the instance.
  message StatusHistory {
    InstanceStatus instance_status = 1;
    RayStatus ray_status = 2;
    // Unix timestamp of the last time the instance get modified in milliseconds.
    int64 timestamp_ms = 3;
  }
  repeated StatusHistory status_history = 21;
  // The request id that's associated with the instance, this is id for request
  // where the instance manager is trying to launch the instance.
  string launch_request_id = 22;
  // The instance termination details.
  string exit_details = 23;
}

message InstanceUpdateEvent {
  // the instance id of the instance that's updated.
  string instance_id = 1;
  // the status of the ray process on the instance.
  Instance.RayStatus new_ray_status = 2;
  // the new instance status.
  Instance.InstanceStatus new_instance_status = 3;
}

// Launch request for a node type.
message LaunchRequest {
  // the instance type name.
  string instance_type = 1;
  // the number of instances to launch.
  int32 count = 2;
  // a unique request id.
  string id = 3;
  // request time in seconds.
  int64 request_ts = 4;
}

message UpdateInstanceManagerStateRequest {
  // the expected version of the state.
  int64 expected_version = 1;
  // instance launch requests.
  repeated LaunchRequest launch_requests = 2;
  // instance state updates.
  repeated InstanceUpdateEvent updates = 3;
}

message UpdateInstanceManagerStateReply {
  // whether the update is successful.
  bool success = 1;
  // the error message if failed.
  string error_message = 2;
  // the current version of the state. If success, this is the same as
  // the version after updates.
  int64 version = 3;
  // the updated instance state if success, else none.
  optional InstanceManagerState state = 4;
}

message InstanceManagerState {
  // a monotonically increasing version number.
  // the version number is incremented whenever
  // the state is updated (either by successful adjusting request,
  // or instance state change).
  int64 version = 1;
  repeated Instance instances = 2;
  repeated LaunchRequest launch_requests = 3;
}

message GetInstanceManagerStateRequest {}

message GetInstanceManagerStateReply {
  InstanceManagerState state = 1;
}

service InstanceManagerService {
  rpc GetInstanceManagerState(GetInstanceManagerStateRequest)
      returns (GetInstanceManagerStateReply);
  rpc UpdateInstanceManagerState(UpdateInstanceManagerStateRequest)
      returns (UpdateInstanceManagerStateReply);
  rpc GetAvailableInstanceTypes(GetAvailableInstanceTypesRequest)
      returns (GetAvailableInstanceTypesResponse);
}

// ============= Resource Scheduling Service API =======================
//
// ResourceSchedulerService is a service that schedules resource bundles
// to nodes. It's used by the autoscaler to schedule resource bundles
// to determine the desired cluster size to satisfy the current resource
// demands.
//
// NOTE(rickyx): This service could actually be implemented by GCS
// (or a separate service) in the future.

// Node type config for each node type. This is derived from the ray schema's
// 'available_node_types'. It captures the mimimal node provider agnostic
// information about each node type that's needed for scheduling.
message NodeTypeConfig {
  // The name of the node type.
  string name = 1;
  // The minimal number of workers to be launched for this node type.
  int32 min_workers = 2;
  // The maximal number of workers can be launched for this node type.
  int32 max_workers = 3;
  // The resources on the node.
  map<string, double> resources = 4;
  // The labels on the node.
  map<string, string> labels = 5;
}

// Resource scheduling config. This is derived from the autoscaling config.
message ResourceScheduleConfig {
  // The node type configs.
  map<string, NodeTypeConfig> node_type_configs = 1;

  // The max number of nodes that could be launched for the entire cluster.
  optional int32 max_num_nodes = 2;
}

message ScheduleResourceBundlesRequest {
  // The resource bundles to be scheduled.
  repeated ResourceRequestByCount resource_requests = 1;
  // The gang resource bundles to be scheduled.
  repeated GangResourceRequest gang_resource_requests = 2;
  // The cluster resource state version.
  repeated ClusterResourceConstraint cluster_resource_constraints = 3;
  // The current nodes reported by ray cluster.
  repeated NodeState node_states = 4;
  // The current instances in the cluster
  repeated Instance current_instances = 5;
  // The scheduling config.
  ResourceScheduleConfig schedule_config = 6;
}

message ScheduleResourceBundlesReply {
  // The infeasible resource bundles.
  repeated ResourceRequestByCount infeasible_resource_requests = 1;
  // The infeasible gang resource bundles.
  repeated GangResourceRequest infeasible_gang_resource_requests = 2;
  // The infeasible cluster resource constraints.
  repeated ClusterResourceConstraint infeasible_cluster_resource_constraints = 3;
  // The target cluster shape, given the current resource demands and instances.
  // Key is the node type name, value is the number of nodes.
  // Note this might be "smaller" than the current cluster shape, since there
  // could be resource requests constraints enforced.
  map<string, int32> target_cluster_shape = 4;

  // Current cluster shape.
  map<string, int32> current_cluster_shape = 5;
}

service ResourceSchedulerService {
  rpc ScheduleResourceBundles(ScheduleResourceBundlesRequest)
      returns (ScheduleResourceBundlesReply);
}