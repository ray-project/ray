// Copyright 2023 The Ray Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//  http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

syntax = "proto3";
option cc_enable_arenas = true;

package ray.rpc.autoscaler.im;

// A status code to be used for operations in the Instance Manager
// and other components.
enum StatusCode {
  // The unspecified status code. Should not be used.
  UNSPECIFIED = 0;
  // Success operations.
  OK = 1;
  // Version mismatched.
  VERSION_MISMATCH = 2;
  // Unknown errors, that's probably not recoverable.
  UNKNOWN_ERRORS = 3;
  // Unavailable resources or operations. Caller should retry.
  UNAVAILABLE = 4;
}

message Status {
  StatusCode code = 1;
  string message = 2;
}

enum NodeKind {
  // The unmanaged node kind (e.g. out of band ones started by users.)
  UNMANAGED = 0;
  // The head node.
  HEAD = 1;
  // The worker node.
  WORKER = 2;
}

/// Represents the state of an instance.
message Instance {
  // Represents the state of a launched instance.
  // See
  // https://docs.google.com/document/d/1NzQjA8Mh-oMc-QxXOa529oneWCoA8sDiVoNkBqqDb4U/edit#heading=h.k9a1sp4qpqj4
  // for lifecycle of an instance.
  enum InstanceStatus {
    // The unspecified state
    UNKNOWN = 0;
    // The instance is queued to be allocated.
    QUEUED = 1;
    // The instance is requested to be allocated - follows from the QUEUED state.
    REQUESTED = 2;
    // The instance is allocated - follows from the REQUESTED state.
    ALLOCATED = 3;
    // The instance is installing ray (optionally) - follows from the ALLOCATED state.
    RAY_INSTALLING = 4;
    // Ray started and connected to gcs - follows from the RAY_INSTALLING state or
    // ALLOCATED.
    RAY_RUNNING = 5;
    // Ray node should be stopped - follows from the RAY_RUNNING state.
    RAY_STOP_REQUESTED = 6;
    // Ray node being stopped - follows from RAY_STOP_REQUESTED.
    RAY_STOPPING = 7;
    // Ray stopped - follows from the RAY_STOPPING/RAY_RUNNING state.
    RAY_STOPPED = 8;
    // The instance is terminating - follows from the RAY_STOPPED state.
    TERMINATING = 9;
    // The instance is terminated - follows from TERMINATING state or any other running
    // states when instance was preempted.
    TERMINATED = 10;
    // Error states.
    // The instance allocation failed - follows from the REQUESTED state.
    ALLOCATION_FAILED = 11;
    // The instance startup failed - follows from the RAY_INSTALLING state.j
    RAY_INSTALL_FAILED = 12;
    // The instance termination failed - follows from the TERMINATING state.
    TERMINATION_FAILED = 13;
  }
  // an unique id for the instance that's generated by the
  // instance manager. This may be optional if
  // the instance hasn't be started yet.
  string instance_id = 1;
  // The cloud instance id of the instance, which is a **unique** and **opaque**
  // id generated by the cloud provider.
  optional string cloud_instance_id = 2;
  // The ray node id. Empty before ray is started and registered to GCS.
  optional string node_id = 3;
  // the status of the instance.
  InstanceStatus status = 4;
  // the node type of the instance. This is the user defined ray instance type name
  // It's the key of `available_node_types` in the ray-schema.json, e.g.
  // `ray.head.default``
  string instance_type = 5;
  // The corresponding total resources on the node.
  map<string, double> total_resources = 6;
  // internal ip address of the instance.
  string internal_ip = 7;
  // external ip address of the instance.
  string external_ip = 8;
  // the monotonically increasing version number of the instance.
  int64 version = 9;
  // The status history of the instance.
  message StatusHistory {
    InstanceStatus instance_status = 1;
    // Unix timestamp of the last time the instance get modified in nanoseconds.
    int64 timestamp_ns = 2;
    // The details of the status change if any.
    string details = 3;
  }
  repeated StatusHistory status_history = 10;
  // The request id that's associated with the instance, this is id for request
  // where the instance manager is trying to launch the instance.
  // This could also be used as idempotency key for the launch request to the
  // cloud provider.
  string launch_request_id = 11;
  // The instance STOPPED details.
  string exit_details = 12;
  // The node config hash when launched. This is used to detect outdated
  // node, which needs to terminated.
  string launch_config_hash = 13;
  // The ray node kind, e.g. head, worker, etc.
  NodeKind node_kind = 14;
}

// Update event for an instance.
message InstanceUpdateEvent {
  // the instance id of the instance that's updated.
  string instance_id = 1;
  // the new instance status.
  Instance.InstanceStatus new_instance_status = 2;
  // The details of the status change if any.
  string details = 3;
  // Whether to upsert the instance. If true, the instance will be created if it
  // doesn't exist, if false, the instance must exist or the update will fail.
  bool upsert = 4;

  /// Additional metadata for the update event.

  // The instance type for QUEUED/REQUESTED/ALLOCATED event.
  optional string instance_type = 5;
  // Cloud instance id for ALLOCATED event.
  optional string cloud_instance_id = 6;
  // The ray node type for ALLOCATED event.
  optional NodeKind node_kind = 7;
  // Ray node id for RAY_RUNNING event.
  optional string ray_node_id = 8;
  // Launch request id for REQUESTED event.
  optional string launch_request_id = 9;
  // Termination request for RAY_STOPPING event.
  optional TerminationRequest termination_request = 10;
}

// Launch request for a node type.
message LaunchRequest {
  // the instance type name.
  string instance_type = 1;
  // the number of instances to launch.
  int32 count = 2;
  // a unique request id.
  string id = 3;
  // request time in milliseconds.
  int64 request_ts_ms = 4;
}

// Termination request for an instance.
message TerminationRequest {
  enum Cause {
    UNKNOWN = 0;
    // Idle termination.
    IDLE = 1;
    // Per type max instance limit reached.
    MAX_NUM_NODE_PER_TYPE = 2;
    // Global max num nodes reached.
    MAX_NUM_NODES = 3;
    // An outdated node.
    OUTDATED = 4;
  }
  // id of the request.
  string id = 1;
  // The ray node id of the instance that's terminated.
  string ray_node_id = 2;
  // the instance id of the instance that's terminated.
  string instance_id = 3;
  // the reason of the termination.
  Cause cause = 4;
  // Instance type.
  string instance_type = 5;

  // Idle time if the cause is IDLE.
  optional uint64 idle_duration_ms = 6;
  // The per type max instance limit if the cause is MAX_NUM_NODE_PER_TYPE.
  optional uint32 max_num_nodes_per_type = 7;
  // The global max num nodes if the cause is MAX_NUM_NODES.
  optional uint32 max_num_nodes = 8;
  // Details of the termination.
  string details = 9;
}

message UpdateInstanceManagerStateRequest {
  // the expected version of the state.
  int64 expected_version = 1;
  // instance state updates.
  repeated InstanceUpdateEvent updates = 2;
}

message UpdateInstanceManagerStateReply {
  // whether the update is successful.
  Status status = 1;
  // the current version of the state. If success, this is the same as
  // the version after updates.
  int64 version = 2;
}

message InstanceManagerState {
  // a monotonically increasing version number.
  // the version number is incremented whenever
  // the state is updated (either by successful adjusting request,
  // or instance state change).
  int64 version = 1;
  // The current list of autoscaler instances.
  repeated Instance instances = 2;
}

message GetInstanceManagerStateRequest {}

message GetInstanceManagerStateReply {
  Status status = 1;
  // The instance manager state.
  InstanceManagerState state = 2;
}

service InstanceManagerService {
  /// The instance manager service should guarantee linearizability of the updates/gets
  /// to the instance manager state: e.g.
  ///   - if two updates are sent to the instance manager service, the second update
  ///   should be applied after the first update is applied.
  ///   - if an update is sent to the instance manager before a get, the get should
  ///   return the state after the update.
  rpc GetInstanceManagerState(GetInstanceManagerStateRequest)
      returns (GetInstanceManagerStateReply);
  rpc UpdateInstanceManagerState(UpdateInstanceManagerStateRequest)
      returns (UpdateInstanceManagerStateReply);
}
