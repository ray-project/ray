// ============= Scheduling Status Primitives ====================

message AntiAffinity {
  string label = 1;
}

message ResourceBundle {
  map<string, double> resources = 1;
  repeated AntiAffinity anti_affinities = 2;
}


message ResourceRequest {
  repeated ResourceBundle bundles = 1;
}

message ClusterSizeConstraint {
  repeated bytes request_ids = 1;
  repeated ResourceBundle bundles = 2;
}

message NodeStatus {
  // The address of the node.
  string address = 1;

  // The available resources on the node.
  map<string, double> available_resources = 2;

  // The corresponding total resources on the node.
  map<string, double> total_resources = 3;
}

// =========== Primitives autoscaler insights ====================

enum AutoscalerNodeStates {
  // The underlying cloud resource is alive, it's up to the cluster to decide
  // if the node has joined the cluster (active) or not (still starting up).
  ALIVE = 1;
  // A terminal state, indicating the autoscaler believes this node will never
  // join the cluster.
  DEAD = 2;
  // A hint that this node will be downscaled. Ray doesn't get a say in whether
  // this node will be downscaled. It only has an opportunity to minimize the
  // blast radius. Preemption, can happen for multiple reasons such as spot
  // instance failure.
  PREMPTED = 3;
}

message AutoscalerNode {
  bytes node_id = 1;
  AutoscalerNodeStates node_state = 2;
  string description = 4;
}

message PendingNode {
  string node_type = 1;
  uint64 pending_count = 2;
  uint64 sent_count = 3;
}

message AutoscalerDecision {
  oneof possible_autoscaler_decisions {
    // Information about actions taken on nodes.
    AutoscalerNode autoscaler_node = 1;
    // Feedback about whether a resource request was infeasible.
    ResourceRequest infeasible_request_data = 2;
    // The unfinished requests in the autoscaler. Ray will only use this
    // information for observability.
    PendingNode pending_node = 3;
  }
}


// ============= Batched approach =======================
message ReportBatchAutoscalerDecisionsReply {}

message ReportBatchAutoscalerDecisionsRequest {
  bytes scheduling_state_id = 1;
  repeated AutoscalerDecision decisions = 2;
}

message GetBatchSchedulingStatusReply {
  bytes scheduling_state_id = 1;
  repeated NodeStatus node_states = 2;
  repeated ResourceRequest resource_requests = 3;
  repeated ClusterSizeConstraint cluster_size_constraints = 4;
}

message GetBatchSchedulingStatusRequest {
  // The last seen scheduling state id. The default value is reserved for if a
  // previous scheduling state has never been seen.
  bytes last_seen_scheduling_state_id = 01;
}

service BatchAutoscalerService {
  rpc GetBatchSchedulingStatus(GetBatchSchedulingStatusRequest) returns GetBatchSchedulingStatusReply;
  rpc ReportAutoscalerDecisions(ReportBatchAutoscalerDecisionsRequest) returns ReportBatchAutoscalerDecisionsReply;
}

// ================ Streaming approach ================


message ReportBatchAutoscalerDecisionsStreamReply {}

message ReportAutoscalerDecisionsStreamPacket {
  bytes scheduling_state_id = 1;
  AutoscalerDecision decision = 2;
}

message GetStreamSchedulingStatusPacket{
  bytes scheduling_state_id = 1;
  oneof update_type {
     NodeStatus node_states = 2;
     ResourceRequest resource_requests = 3;
     ClusterSizeConstraint cluster_size_constraints = 4;
  }
}

message GetStreamSchedulingStatusRequest {
  // The last seen scheduling state id. The default value is reserved for if a
  // previous scheduling state has never been seen.
  bytes last_seen_scheduling_state_id = 01;
}


service StreamAutoscalerService {
  rpc GetBatchSchedulingStatus(GetStreamSchedulingStatusRequest) returns (stream GetStreamSchedulingStatusPacket);
  rpc ReportAutoscalerDecisionsStream(stream ReportAutoscalerDecisionsStreamPacket) returns ReportBatchAutoscalerDecisionsStreamReply;
}

// ============= Metrics =================

message EmitMetricRequest {
  string metric_name = 2;
  map<string, string> tags = 3;
  double value = 4;
}

message EmitMetricReply {}

message CreateMetricRequest {
  enum MetricType {

  }
  string metric_name = 1;
  string metric_description = 2;
  string unit = 4;
  repeated string tag_keys = 3;
}

message CreateMetricReply {}

service MetricService {
  rpc CreateMetric(CreateMetricRequest) returns CreateMetricReply;
  rpc EmitMetric(EmitMetricRequest) returns EmitMetricReply;
}
