// ============= Scheduling Status Primitives ====================
//
// Following fields represents the Ray state autoscaler interested
// in.

// Represents an anti-affinity constraint. A bundle with this constraint
// can't be allocated to a node that has a label with the same name and
// value.
message AntiAffinityConstraint {
  string label_name = 1;
  string label_value = 2;
}

message ResourceBundle {
  map<string, double> resources = 1;
  repeated AntiAffinityConstraint affinity_constraints = 2;
  // If the resource bundle is allocated, the node will be labeled
  // with the following labels.
  map<string, string> new_labels = 3;
}

// All bundles in the same resource request require gang
// allocation semantics: they should be allocated together.
message ResourceRequest {
  // a map from bundles to the number of bundles requested.
  map<ResourceBundle, int32_t> bundles = 1;
}

// Cluster constraint represents minimial cluster size requirement,
// issued through ray.autoscaler.sdk.request_resources.
message OnDemandResourceRequest {
  bytes request_id = 1;
  ResourceRequest resource_request = 2;
}

message NodeResourceState {
  bytes node_id = 1;

  // The address of the node.
  string address = 2;

  // The available resources on the node.
  map<string, double> available_resources = 3;

  // The corresponding total resources on the node.
  map<string, double> total_resources = 4;

  // Dynamic labels associated with the node.
  map<string, string> dynamic_labels = 5;

  // TODO(scv119): we can support static labels proposed in
  // https://github.com/ray-project/enhancements/pull/22 as
  // following.
  // map<string, string> static_labels = 6;
}

// =========== Primitives autoscaler insights ====================

// Following states present the Autoscaler state GCS interested in,
// for observability and scheduling purpose.

enum AutoscalerNodeStatus {
  // The underlying cloud resource is alive, it's up to the cluster to decide
  // if the node has joined the cluster (active) or not (still starting up).
  ALIVE = 1;
  // A terminal state, indicating the autoscaler believes this node will never
  // join the cluster.
  DEAD = 2;
  // A notification that this node will be preempted soon. Ray doesn't get a say in whether
  // this node will be downscaled. It only has an opportunity to minimize the
  // blast radius. Preemption, can happen for multiple reasons such as spot
  // instance failure.
  PREMEPTING = 3;
}

// Presents a node that has (previously) been allocated
// by the autoscaler. Unlike the pending node, allocated
// node has node_id assigned.
// Note the node might be terminated (DEAD), and it 
// will be garbage collected by the autoscaler after
// a timeout (default 30 minutes).
message AllocatedNode {
  bytes node_id = 1;
  AutoscalerNodeStates node_state = 2;
  string description = 3;
  string node_type = 4;
}

// Represents a node that autoscaler
// has decided to upscale but pending.
message PendingUpscaleNode {
  string node_type = 1;
  int64_t num_pending = 2;
  int64_t num_bootstraping = 3;
}

// ============= Snapshot based Autoscaling Service API =======================
//
// Autoscaler periodically calls to
// two snapshot APIs, GetClusterResourceState
// and ReportAutoscalingState. 
// The GetClusterResourceState will return a snapshot
// of Ray state that Autoscaler interested, along with
// the snapshot_id (version).
//
// Separately, autoscaler will constantly making decisions
// based on the latest Ray state, and also change its
// state based on the information from node provider.
// Autoscaler will periodically report its state to GCS
// through ReportAutoscalingState API.

message ReportAutoscalingStateReply {}

message ReportAutoscalingStateRequest {
  int64_t last_seen_cluster_resource_state_version = 1;
  // A monotonically increasing version identifies
  // the state of autoscaler.
  // Note: for the same cluster resource state, the
  // autoscaler state might be different, since
  // the autoscaler's state could also be updated by
  // node provider.
  int64_t autoscaler_state_version = 2;
  repeated AllocatedNode allocated_nodes = 3;
  repeated PendingUpscaleNode pending_nodes = 4;
  repeated ResourceRequest infeasible_requests = 5;
}

message GetClusterResourceStateReply {
  // an monotonically increasing version of the cluster resources.
  int64_t cluster_resource_state_version = 1;
  repeated NodeResourceState node_resource_states = 2;
  repeated ResourceRequest resource_requests = 3;
  repeated OnDemandResourceRequest on_demand_resource_requests = 4;
}

message GetClusterResourceStateRequest {
  // The last seen cluster resource state version. The default value is reserved for if a
  // previous scheduling state has never been seen.
  int64_t last_seen_cluster_resource_state_version = 1;
}

service AutoscalerStateService {
  rpc GetClusterResourceState(GetClusterResourceStateRequest) returns GetClusterResourceStateReply;
  rpc ReportAutoscalingState(ReportAutoscalingStateRequest) returns ReportAutoscalingStateReply;
}

// ============= Metrics =================
// A metric service. Don't review for now.

message EmitMetricRequest {
  string metric_name = 2;
  map<string, string> tags = 3;
  double value = 4;
}

message EmitMetricReply {}

message CreateMetricRequest {
  enum MetricType {

  }
  string metric_name = 1;
  string metric_description = 2;
  string unit = 4;
  repeated string tag_keys = 3;
}

message CreateMetricReply {}

service MetricService {
  rpc CreateMetric(CreateMetricRequest) returns CreateMetricReply;
  rpc EmitMetric(EmitMetricRequest) returns EmitMetricReply;
}
