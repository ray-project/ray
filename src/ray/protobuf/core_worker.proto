// Copyright 2017 The Ray Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//  http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

syntax = "proto3";

package ray.rpc;

import "src/ray/protobuf/common.proto";

message ActiveObjectIDs {
  repeated bytes object_ids = 1;
}

// Persistent state of an ActorHandle.
message ActorHandle {
  // ID of the actor.
  bytes actor_id = 1;

  // The task or actor ID of the actor's owner.
  bytes owner_id = 2;

  // The address of the actor's owner.
  Address owner_address = 3;

  // ID of the job that created the actor (it is possible that the handle
  // exists on a job with a different job ID).
  bytes creation_job_id = 4;

  // Language of the actor.
  Language actor_language = 5;

  // Function descriptor of actor creation task.
  FunctionDescriptor actor_creation_task_function_descriptor = 6;

  // The unique id of the dummy object returned by the actor creation task.
  // It's used as a dependency for the first task.
  // TODO: Remove this once scheduling is done by task counter only.
  bytes actor_cursor = 7;

  // An extension field that is used for storing app-language-specific data.
  bytes extension_data = 8;

  // How many times tasks may be retried on this actor if the actor fails.
  int64 max_task_retries = 9;
}

message ReturnObject {
  // Object ID.
  bytes object_id = 1;
  // If set, indicates the data is in plasma instead of inline. This
  // means that data and metadata will be empty.
  bool in_plasma = 2;
  // Data of the object.
  bytes data = 3;
  // Metadata of the object.
  bytes metadata = 4;
  // ObjectIDs that were nested in data. This is only set for inlined objects.
  repeated bytes nested_inlined_ids = 5;
  // Size of this object.
  int64 size = 6;
}

message PushTaskRequest {
  // The ID of the worker this message is intended for.
  bytes intended_worker_id = 1;
  // The task to be pushed.
  TaskSpec task_spec = 2;
  // The sequence number of the task for this client. This must increase
  // sequentially starting from zero for each actor handle. The server
  // will guarantee tasks execute in this sequence, waiting for any
  // out-of-order request messages to arrive as necessary.
  // If set to -1, ordering is disabled and the task executes immediately.
  int64 sequence_number = 3;
  // The max sequence number the client has processed responses for. This
  // is a performance optimization that allows the client to tell the server
  // to cancel any PushTaskRequests with seqno <= this value, rather than
  // waiting for the server to time out waiting for missing messages.
  int64 client_processed_up_to = 4;
  // Resource mapping ids assigned to the worker executing the task.
  repeated ResourceMapEntry resource_mapping = 5;
}

message PushTaskReply {
  // The returned objects.
  repeated ReturnObject return_objects = 1;
  // Set to true if the worker will be exiting.
  bool worker_exiting = 2;
  // The references that the worker borrowed during the task execution. A
  // borrower is a process that is currently using the object ID, in one of 3
  // ways:
  // 1. Has an ObjectID copy in Python.
  // 2. Has submitted a task that depends on the object and that is still
  // pending.
  // 3. Owns another object that is in scope and whose value contains the
  // ObjectID.
  // This list includes the reference counts for any IDs that were passed to
  // the worker in the task spec as an argument by reference, or an ObjectID
  // that was serialized in an inlined argument. It also includes reference
  // counts for any IDs that were nested inside these objects that the worker
  // may now be borrowing. The reference counts also include any new borrowers
  // that the worker created by passing a borrowed ID into a nested task.
  repeated ObjectReferenceCount borrowed_refs = 3;
}

message DirectActorCallArgWaitCompleteRequest {
  // The ID of the worker this message is intended for.
  bytes intended_worker_id = 1;
  // Id used to uniquely identify this request. This is sent back to the core
  // worker to notify the wait has completed.
  int64 tag = 2;
}

message DirectActorCallArgWaitCompleteReply {
}

message GetObjectStatusRequest {
  // The ID of the worker that owns this object. This is also
  // the ID of the worker that this message is intended for.
  bytes owner_worker_id = 1;
  // Wait for this object's status.
  bytes object_id = 2;
}

message GetObjectStatusReply {
  enum ObjectStatus {
    CREATED = 0;
    OUT_OF_SCOPE = 1;
    FREED = 2;
  }
  ObjectStatus status = 1;
}

message WaitForActorOutOfScopeRequest {
  // The ID of the worker this message is intended for.
  bytes intended_worker_id = 1;
  // ActorID of the actor in scope.
  bytes actor_id = 2;
}

message WaitForActorOutOfScopeReply {
}

message WaitForObjectEvictionRequest {
  // The ID of the worker this message is intended for.
  bytes intended_worker_id = 1;
  // ObjectID of the pinned object.
  bytes object_id = 2;
}

message WaitForObjectEvictionReply {
}

message AddObjectLocationOwnerRequest {
  bytes intended_worker_id = 1;
  bytes object_id = 2;
  bytes node_id = 3;
}

message AddObjectLocationOwnerReply {
}

message RemoveObjectLocationOwnerRequest {
  bytes intended_worker_id = 1;
  bytes object_id = 2;
  bytes node_id = 3;
}

message RemoveObjectLocationOwnerReply {
}

message GetObjectLocationsOwnerRequest {
  bytes intended_worker_id = 1;
  bytes object_id = 2;
}

message GetObjectLocationsOwnerReply {
  repeated bytes node_ids = 1;
}

message KillActorRequest {
  // ID of the actor that is intended to be killed.
  bytes intended_actor_id = 1;
  // Whether to force kill the actor.
  bool force_kill = 2;
  // If set to true, the killed actor will not be restarted anymore.
  bool no_restart = 3;
}

message KillActorReply {
}

message CancelTaskRequest {
  // ID of task that should be killed.
  bytes intended_task_id = 1;
  // Whether to kill the worker.
  bool force_kill = 2;
  // Whether to recursively cancel tasks.
  bool recursive = 3;
}

message CancelTaskReply {
  // Whether the requested task is the currently running task.
  bool attempt_succeeded = 1;
}

message RemoteCancelTaskRequest {
  // Object ID of the remote task that should be killed.
  bytes remote_object_id = 1;
  // Whether to kill the worker.
  bool force_kill = 2;
  // Whether to recursively cancel tasks.
  bool recursive = 3;
}

message RemoteCancelTaskReply {
}

message GetCoreWorkerStatsRequest {
  // The ID of the worker this message is intended for.
  bytes intended_worker_id = 1;
  // Whether to include memory stats. This could be large since it includes
  // metadata for all live object references.
  bool include_memory_info = 2;
}

message GetCoreWorkerStatsReply {
  // Debug information returned from the core worker.
  CoreWorkerStats core_worker_stats = 1;
}

message WaitForRefRemovedRequest {
  // The ID of the worker this message is intended for.
  bytes intended_worker_id = 1;
  // Object whose removal we are waiting for.
  ObjectReference reference = 2;
  // ObjectID that contains object_id. This is used when an ObjectID is stored
  // inside another object ID that we do not own. Then, we must notify the
  // outer ID's owner that the ID contains object_id.
  bytes contained_in_id = 3;
}

message ObjectReferenceCount {
  // The reference that the worker has or had a reference to.
  ObjectReference reference = 1;
  // Whether the worker is still using the ObjectID locally. This means that
  // it has a copy of the ObjectID in the language frontend, has a pending task
  // that depends on the object, and/or owns an ObjectID that is in scope and
  // that contains the ObjectID.
  bool has_local_ref = 2;
  // Any other borrowers that the worker created (by passing the ID on to them).
  repeated Address borrowers = 3;
  // The borrower may have returned the object ID nested inside the return
  // value of a task that it executed. This list contains all task returns that
  // were owned by a process other than the borrower. Then, the process that
  // owns the task's return value is also a borrower for as long as it has the
  // task return ID in scope. Note that only the object ID and owner address
  // are used for elements in this list.
  repeated ObjectReference stored_in_objects = 4;
  // The borrowed object ID that contained this object, if any. This is used
  // for nested object IDs.
  bytes contained_in_borrowed_id = 5;
  // The object IDs that this object contains, if any. This is used for nested
  // object IDs.
  repeated bytes contains = 6;
}

message WaitForRefRemovedReply {
  // The reference counts for the object that the worker was borrowing and
  // any objects nested inside. The worker should no longer be using the object
  // ID by the time it replies, but may have accumulated other borrowers or may
  // still be borrowing an object ID that was nested inside.
  repeated ObjectReferenceCount borrowed_refs = 1;
}

message LocalGCRequest {
}

message LocalGCReply {
}

message PlasmaObjectReadyRequest {
  bytes object_id = 1;
}

message PlasmaObjectReadyReply {
}

message SpillObjectsRequest {
  // The IDs of objects to be spilled.
  repeated bytes object_ids_to_spill = 1;
}

message SpillObjectsReply {
  // The URLs of spilled objects.
  repeated string spilled_objects_url = 1;
}

message RestoreSpilledObjectsRequest {
  // The URLs of spilled objects.
  repeated string spilled_objects_url = 1;
  // Object ids to restore. The order of object ids
  // must be the same as spilled_objects_url.
  repeated bytes object_ids_to_restore = 2;
}

message RestoreSpilledObjectsReply {
}

message ExitRequest {
}

message ExitReply {
}

service CoreWorkerService {
  // Push a task directly to this worker from another.
  rpc PushTask(PushTaskRequest) returns (PushTaskReply);
  // Reply from raylet that wait for direct actor call args has completed.
  rpc DirectActorCallArgWaitComplete(DirectActorCallArgWaitCompleteRequest)
      returns (DirectActorCallArgWaitCompleteReply);
  // Ask the object's owner about the object's current status.
  rpc GetObjectStatus(GetObjectStatusRequest) returns (GetObjectStatusReply);
  // Wait for the actor's owner to decide that the actor has gone out of scope.
  // Replying to this message indicates that the client should force-kill the
  // actor process, if still alive.
  rpc WaitForActorOutOfScope(WaitForActorOutOfScopeRequest)
      returns (WaitForActorOutOfScopeReply);
  // Notify the object's owner that it has been pinned by a raylet. Replying
  // to this message indicates that the raylet should unpin the object.
  rpc WaitForObjectEviction(WaitForObjectEvictionRequest)
      returns (WaitForObjectEvictionReply);
  // Add object location to the ownership-based object directory.
  rpc AddObjectLocationOwner(AddObjectLocationOwnerRequest)
      returns (AddObjectLocationOwnerReply);
  // Remove object location from the ownership-based object directory.
  rpc RemoveObjectLocationOwner(RemoveObjectLocationOwnerRequest)
      returns (RemoveObjectLocationOwnerReply);
  // Get object locations from the ownership-based object directory.
  rpc GetObjectLocationsOwner(GetObjectLocationsOwnerRequest)
      returns (GetObjectLocationsOwnerReply);
  // Request that the worker shut down without completing outstanding work.
  rpc KillActor(KillActorRequest) returns (KillActorReply);
  // Request that a worker cancels a task.
  rpc CancelTask(CancelTaskRequest) returns (CancelTaskReply);
  // Request for a worker to issue a cancelation.
  rpc RemoteCancelTask(RemoteCancelTaskRequest) returns (RemoteCancelTaskReply);
  // Get metrics from core workers.
  rpc GetCoreWorkerStats(GetCoreWorkerStatsRequest) returns (GetCoreWorkerStatsReply);
  // Wait for a borrower to finish using an object. Sent by the object's owner.
  rpc WaitForRefRemoved(WaitForRefRemovedRequest) returns (WaitForRefRemovedReply);
  // Trigger local GC on the worker.
  rpc LocalGC(LocalGCRequest) returns (LocalGCReply);
  // Spill objects to external storage. Caller: raylet; callee: I/O worker.
  rpc SpillObjects(SpillObjectsRequest) returns (SpillObjectsReply);
  // Restore spilled objects from external storage. Caller: raylet; callee: I/O worker.
  rpc RestoreSpilledObjects(RestoreSpilledObjectsRequest)
      returns (RestoreSpilledObjectsReply);
  // Notification from raylet that an object ID is available in local plasma.
  rpc PlasmaObjectReady(PlasmaObjectReadyRequest) returns (PlasmaObjectReadyReply);
  // Request for a worker to exit.
  rpc Exit(ExitRequest) returns (ExitReply);
}
