.. _ray-dag-guide:

Lazy Computation Graphs with the Ray DAG API
============================================

With ``ray.remote`` you have the flexibility of running an application where
computation is executed remotely at runtime. For a ``ray.remote`` decorated
class or function, you can also use ``.bind`` on the body to build a static
computation graph.

.. note::

     Ray DAG is designed to be a developer facing API where recommended use cases
     are

     1) Locally iterate and test your application authored by higher level libraries.

     2) Build libraries on top of the Ray DAG APIs.


When ``.bind()`` is called on a ``ray.remote`` decorated class or function, it will
generate an intermediate representation (IR) node that act as backbone and
building blocks of the DAG that is statically holding the computation graph
together, where each IR node is resolved to value at execution time with
respect to their topological order.

The IR node can also be assigned to a variable and passed into other nodes as
arguments.

Ray DAG with functions
----------------------

The IR node generated by ``.bind()`` on a ``ray.remote`` decorated function is
executed as a Ray Task upon execution which will be solved to the task output.

This example shows how to build a chain of functions where each node can be
executed as root node while iterating, or used as input args or kwargs of other
functions to form more complex DAGs.

Any IR node can be executed directly ``dag_node.execute()`` that acts as root
of the DAG, where all other non-reachable nodes from the root will be igored.

.. tab-set::

    .. tab-item:: Python

        .. literalinclude:: ./doc_code/ray-dag.py
          :language: python
          :start-after: __dag_tasks_begin__
          :end-before: __dag_tasks_end__


Ray DAG with classes and class methods
--------------------------------------

The IR node generated by ``.bind()`` on a ``ray.remote`` decorated class is
executed as a Ray Actor upon execution. The Actor will be instantiated every
time the node is executed, and the classmethod calls can form a chain of
function calls specific to the parent actor instance.

DAG IR nodes generated from a function, class or classmethod can be combined
together to form a DAG.

.. tab-set::

    .. tab-item:: Python

        .. literalinclude:: ./doc_code/ray-dag.py
          :language: python
          :start-after: __dag_actors_begin__
          :end-before: __dag_actors_end__



Ray DAG with custom InputNode
-----------------------------

``InputNode`` is the singleton node of a DAG that represents user input value at
runtime. It should be used within a context manager with no args, and called
as args of ``dag_node.execute()``

.. tab-set::

    .. tab-item:: Python

        .. literalinclude:: ./doc_code/ray-dag.py
          :language: python
          :start-after: __dag_input_node_begin__
          :end-before: __dag_input_node_end__

More Resources
--------------

You can find more application patterns and examples in the following resources
from other Ray libraries built on top of Ray DAG API with the same mechanism.

| `Visualization of DAGs <https://docs.ray.io/en/master/serve/model_composition.html#visualizing-the-graph>`_
| `DAG Cookbook and patterns <https://docs.ray.io/en/master/serve/tutorials/deployment-graph-patterns.html>`_
| `Serve Deployment Graph's original REP <https://github.com/ray-project/enhancements/blob/main/reps/2022-03-08-serve_pipeline.md>`_
