// This file is generated by rust-protobuf 2.18.2. Do not edit
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![cfg_attr(rustfmt, rustfmt::skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_imports)]
#![allow(unused_results)]
//! Generated file from `src/ray/protobuf/runtime_env_common.proto`

/// Generated files are compatible only with the same version
/// of protobuf runtime.
// const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_2_18_2;

#[derive(PartialEq,Clone,Default)]
pub struct PipRuntimeEnv {
    // message oneof groups
    pub pip_runtime_env: ::std::option::Option<PipRuntimeEnv_oneof_pip_runtime_env>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PipRuntimeEnv {
    fn default() -> &'a PipRuntimeEnv {
        <PipRuntimeEnv as ::protobuf::Message>::default_instance()
    }
}

#[derive(Clone,PartialEq,Debug)]
pub enum PipRuntimeEnv_oneof_pip_runtime_env {
    config(PipRuntimeEnv_Config),
    virtual_env_name(::std::string::String),
}

impl PipRuntimeEnv {
    pub fn new() -> PipRuntimeEnv {
        ::std::default::Default::default()
    }

    // .ray.rpc.PipRuntimeEnv.Config config = 1;


    pub fn get_config(&self) -> &PipRuntimeEnv_Config {
        match self.pip_runtime_env {
            ::std::option::Option::Some(PipRuntimeEnv_oneof_pip_runtime_env::config(ref v)) => v,
            _ => <PipRuntimeEnv_Config as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_config(&mut self) {
        self.pip_runtime_env = ::std::option::Option::None;
    }

    pub fn has_config(&self) -> bool {
        match self.pip_runtime_env {
            ::std::option::Option::Some(PipRuntimeEnv_oneof_pip_runtime_env::config(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_config(&mut self, v: PipRuntimeEnv_Config) {
        self.pip_runtime_env = ::std::option::Option::Some(PipRuntimeEnv_oneof_pip_runtime_env::config(v))
    }

    // Mutable pointer to the field.
    pub fn mut_config(&mut self) -> &mut PipRuntimeEnv_Config {
        if let ::std::option::Option::Some(PipRuntimeEnv_oneof_pip_runtime_env::config(_)) = self.pip_runtime_env {
        } else {
            self.pip_runtime_env = ::std::option::Option::Some(PipRuntimeEnv_oneof_pip_runtime_env::config(PipRuntimeEnv_Config::new()));
        }
        match self.pip_runtime_env {
            ::std::option::Option::Some(PipRuntimeEnv_oneof_pip_runtime_env::config(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_config(&mut self) -> PipRuntimeEnv_Config {
        if self.has_config() {
            match self.pip_runtime_env.take() {
                ::std::option::Option::Some(PipRuntimeEnv_oneof_pip_runtime_env::config(v)) => v,
                _ => panic!(),
            }
        } else {
            PipRuntimeEnv_Config::new()
        }
    }

    // string virtual_env_name = 2;


    pub fn get_virtual_env_name(&self) -> &str {
        match self.pip_runtime_env {
            ::std::option::Option::Some(PipRuntimeEnv_oneof_pip_runtime_env::virtual_env_name(ref v)) => v,
            _ => "",
        }
    }
    pub fn clear_virtual_env_name(&mut self) {
        self.pip_runtime_env = ::std::option::Option::None;
    }

    pub fn has_virtual_env_name(&self) -> bool {
        match self.pip_runtime_env {
            ::std::option::Option::Some(PipRuntimeEnv_oneof_pip_runtime_env::virtual_env_name(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_virtual_env_name(&mut self, v: ::std::string::String) {
        self.pip_runtime_env = ::std::option::Option::Some(PipRuntimeEnv_oneof_pip_runtime_env::virtual_env_name(v))
    }

    // Mutable pointer to the field.
    pub fn mut_virtual_env_name(&mut self) -> &mut ::std::string::String {
        if let ::std::option::Option::Some(PipRuntimeEnv_oneof_pip_runtime_env::virtual_env_name(_)) = self.pip_runtime_env {
        } else {
            self.pip_runtime_env = ::std::option::Option::Some(PipRuntimeEnv_oneof_pip_runtime_env::virtual_env_name(::std::string::String::new()));
        }
        match self.pip_runtime_env {
            ::std::option::Option::Some(PipRuntimeEnv_oneof_pip_runtime_env::virtual_env_name(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_virtual_env_name(&mut self) -> ::std::string::String {
        if self.has_virtual_env_name() {
            match self.pip_runtime_env.take() {
                ::std::option::Option::Some(PipRuntimeEnv_oneof_pip_runtime_env::virtual_env_name(v)) => v,
                _ => panic!(),
            }
        } else {
            ::std::string::String::new()
        }
    }
}

impl ::protobuf::Message for PipRuntimeEnv {
    fn is_initialized(&self) -> bool {
        if let Some(PipRuntimeEnv_oneof_pip_runtime_env::config(ref v)) = self.pip_runtime_env {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.pip_runtime_env = ::std::option::Option::Some(PipRuntimeEnv_oneof_pip_runtime_env::config(is.read_message()?));
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.pip_runtime_env = ::std::option::Option::Some(PipRuntimeEnv_oneof_pip_runtime_env::virtual_env_name(is.read_string()?));
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let ::std::option::Option::Some(ref v) = self.pip_runtime_env {
            match v {
                &PipRuntimeEnv_oneof_pip_runtime_env::config(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &PipRuntimeEnv_oneof_pip_runtime_env::virtual_env_name(ref v) => {
                    my_size += ::protobuf::rt::string_size(2, &v);
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let ::std::option::Option::Some(ref v) = self.pip_runtime_env {
            match v {
                &PipRuntimeEnv_oneof_pip_runtime_env::config(ref v) => {
                    os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &PipRuntimeEnv_oneof_pip_runtime_env::virtual_env_name(ref v) => {
                    os.write_string(2, v)?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PipRuntimeEnv {
        PipRuntimeEnv::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, PipRuntimeEnv_Config>(
                "config",
                PipRuntimeEnv::has_config,
                PipRuntimeEnv::get_config,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_string_accessor::<_>(
                "virtual_env_name",
                PipRuntimeEnv::has_virtual_env_name,
                PipRuntimeEnv::get_virtual_env_name,
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<PipRuntimeEnv>(
                "PipRuntimeEnv",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static PipRuntimeEnv {
        static instance: ::protobuf::rt::LazyV2<PipRuntimeEnv> = ::protobuf::rt::LazyV2::INIT;
        instance.get(PipRuntimeEnv::new)
    }
}

impl ::protobuf::Clear for PipRuntimeEnv {
    fn clear(&mut self) {
        self.pip_runtime_env = ::std::option::Option::None;
        self.pip_runtime_env = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PipRuntimeEnv {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PipRuntimeEnv {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct PipRuntimeEnv_Config {
    // message fields
    pub packages: ::protobuf::RepeatedField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PipRuntimeEnv_Config {
    fn default() -> &'a PipRuntimeEnv_Config {
        <PipRuntimeEnv_Config as ::protobuf::Message>::default_instance()
    }
}

impl PipRuntimeEnv_Config {
    pub fn new() -> PipRuntimeEnv_Config {
        ::std::default::Default::default()
    }

    // repeated string packages = 1;


    pub fn get_packages(&self) -> &[::std::string::String] {
        &self.packages
    }
    pub fn clear_packages(&mut self) {
        self.packages.clear();
    }

    // Param is passed by value, moved
    pub fn set_packages(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.packages = v;
    }

    // Mutable pointer to the field.
    pub fn mut_packages(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.packages
    }

    // Take field
    pub fn take_packages(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.packages, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for PipRuntimeEnv_Config {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.packages)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.packages {
            my_size += ::protobuf::rt::string_size(1, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.packages {
            os.write_string(1, &v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PipRuntimeEnv_Config {
        PipRuntimeEnv_Config::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "packages",
                |m: &PipRuntimeEnv_Config| { &m.packages },
                |m: &mut PipRuntimeEnv_Config| { &mut m.packages },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<PipRuntimeEnv_Config>(
                "PipRuntimeEnv.Config",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static PipRuntimeEnv_Config {
        static instance: ::protobuf::rt::LazyV2<PipRuntimeEnv_Config> = ::protobuf::rt::LazyV2::INIT;
        instance.get(PipRuntimeEnv_Config::new)
    }
}

impl ::protobuf::Clear for PipRuntimeEnv_Config {
    fn clear(&mut self) {
        self.packages.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PipRuntimeEnv_Config {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PipRuntimeEnv_Config {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CondaRuntimeEnv {
    // message oneof groups
    pub conda_runtime_env: ::std::option::Option<CondaRuntimeEnv_oneof_conda_runtime_env>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CondaRuntimeEnv {
    fn default() -> &'a CondaRuntimeEnv {
        <CondaRuntimeEnv as ::protobuf::Message>::default_instance()
    }
}

#[derive(Clone,PartialEq,Debug)]
pub enum CondaRuntimeEnv_oneof_conda_runtime_env {
    config(::std::string::String),
    conda_env_name(::std::string::String),
}

impl CondaRuntimeEnv {
    pub fn new() -> CondaRuntimeEnv {
        ::std::default::Default::default()
    }

    // string config = 1;


    pub fn get_config(&self) -> &str {
        match self.conda_runtime_env {
            ::std::option::Option::Some(CondaRuntimeEnv_oneof_conda_runtime_env::config(ref v)) => v,
            _ => "",
        }
    }
    pub fn clear_config(&mut self) {
        self.conda_runtime_env = ::std::option::Option::None;
    }

    pub fn has_config(&self) -> bool {
        match self.conda_runtime_env {
            ::std::option::Option::Some(CondaRuntimeEnv_oneof_conda_runtime_env::config(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_config(&mut self, v: ::std::string::String) {
        self.conda_runtime_env = ::std::option::Option::Some(CondaRuntimeEnv_oneof_conda_runtime_env::config(v))
    }

    // Mutable pointer to the field.
    pub fn mut_config(&mut self) -> &mut ::std::string::String {
        if let ::std::option::Option::Some(CondaRuntimeEnv_oneof_conda_runtime_env::config(_)) = self.conda_runtime_env {
        } else {
            self.conda_runtime_env = ::std::option::Option::Some(CondaRuntimeEnv_oneof_conda_runtime_env::config(::std::string::String::new()));
        }
        match self.conda_runtime_env {
            ::std::option::Option::Some(CondaRuntimeEnv_oneof_conda_runtime_env::config(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_config(&mut self) -> ::std::string::String {
        if self.has_config() {
            match self.conda_runtime_env.take() {
                ::std::option::Option::Some(CondaRuntimeEnv_oneof_conda_runtime_env::config(v)) => v,
                _ => panic!(),
            }
        } else {
            ::std::string::String::new()
        }
    }

    // string conda_env_name = 2;


    pub fn get_conda_env_name(&self) -> &str {
        match self.conda_runtime_env {
            ::std::option::Option::Some(CondaRuntimeEnv_oneof_conda_runtime_env::conda_env_name(ref v)) => v,
            _ => "",
        }
    }
    pub fn clear_conda_env_name(&mut self) {
        self.conda_runtime_env = ::std::option::Option::None;
    }

    pub fn has_conda_env_name(&self) -> bool {
        match self.conda_runtime_env {
            ::std::option::Option::Some(CondaRuntimeEnv_oneof_conda_runtime_env::conda_env_name(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_conda_env_name(&mut self, v: ::std::string::String) {
        self.conda_runtime_env = ::std::option::Option::Some(CondaRuntimeEnv_oneof_conda_runtime_env::conda_env_name(v))
    }

    // Mutable pointer to the field.
    pub fn mut_conda_env_name(&mut self) -> &mut ::std::string::String {
        if let ::std::option::Option::Some(CondaRuntimeEnv_oneof_conda_runtime_env::conda_env_name(_)) = self.conda_runtime_env {
        } else {
            self.conda_runtime_env = ::std::option::Option::Some(CondaRuntimeEnv_oneof_conda_runtime_env::conda_env_name(::std::string::String::new()));
        }
        match self.conda_runtime_env {
            ::std::option::Option::Some(CondaRuntimeEnv_oneof_conda_runtime_env::conda_env_name(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_conda_env_name(&mut self) -> ::std::string::String {
        if self.has_conda_env_name() {
            match self.conda_runtime_env.take() {
                ::std::option::Option::Some(CondaRuntimeEnv_oneof_conda_runtime_env::conda_env_name(v)) => v,
                _ => panic!(),
            }
        } else {
            ::std::string::String::new()
        }
    }
}

impl ::protobuf::Message for CondaRuntimeEnv {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.conda_runtime_env = ::std::option::Option::Some(CondaRuntimeEnv_oneof_conda_runtime_env::config(is.read_string()?));
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.conda_runtime_env = ::std::option::Option::Some(CondaRuntimeEnv_oneof_conda_runtime_env::conda_env_name(is.read_string()?));
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let ::std::option::Option::Some(ref v) = self.conda_runtime_env {
            match v {
                &CondaRuntimeEnv_oneof_conda_runtime_env::config(ref v) => {
                    my_size += ::protobuf::rt::string_size(1, &v);
                },
                &CondaRuntimeEnv_oneof_conda_runtime_env::conda_env_name(ref v) => {
                    my_size += ::protobuf::rt::string_size(2, &v);
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let ::std::option::Option::Some(ref v) = self.conda_runtime_env {
            match v {
                &CondaRuntimeEnv_oneof_conda_runtime_env::config(ref v) => {
                    os.write_string(1, v)?;
                },
                &CondaRuntimeEnv_oneof_conda_runtime_env::conda_env_name(ref v) => {
                    os.write_string(2, v)?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CondaRuntimeEnv {
        CondaRuntimeEnv::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_string_accessor::<_>(
                "config",
                CondaRuntimeEnv::has_config,
                CondaRuntimeEnv::get_config,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_string_accessor::<_>(
                "conda_env_name",
                CondaRuntimeEnv::has_conda_env_name,
                CondaRuntimeEnv::get_conda_env_name,
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CondaRuntimeEnv>(
                "CondaRuntimeEnv",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CondaRuntimeEnv {
        static instance: ::protobuf::rt::LazyV2<CondaRuntimeEnv> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CondaRuntimeEnv::new)
    }
}

impl ::protobuf::Clear for CondaRuntimeEnv {
    fn clear(&mut self) {
        self.conda_runtime_env = ::std::option::Option::None;
        self.conda_runtime_env = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CondaRuntimeEnv {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CondaRuntimeEnv {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ContainerRuntimeEnv {
    // message fields
    pub image: ::std::string::String,
    pub worker_path: ::std::string::String,
    pub run_options: ::protobuf::RepeatedField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ContainerRuntimeEnv {
    fn default() -> &'a ContainerRuntimeEnv {
        <ContainerRuntimeEnv as ::protobuf::Message>::default_instance()
    }
}

impl ContainerRuntimeEnv {
    pub fn new() -> ContainerRuntimeEnv {
        ::std::default::Default::default()
    }

    // string image = 1;


    pub fn get_image(&self) -> &str {
        &self.image
    }
    pub fn clear_image(&mut self) {
        self.image.clear();
    }

    // Param is passed by value, moved
    pub fn set_image(&mut self, v: ::std::string::String) {
        self.image = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_image(&mut self) -> &mut ::std::string::String {
        &mut self.image
    }

    // Take field
    pub fn take_image(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.image, ::std::string::String::new())
    }

    // string worker_path = 2;


    pub fn get_worker_path(&self) -> &str {
        &self.worker_path
    }
    pub fn clear_worker_path(&mut self) {
        self.worker_path.clear();
    }

    // Param is passed by value, moved
    pub fn set_worker_path(&mut self, v: ::std::string::String) {
        self.worker_path = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_worker_path(&mut self) -> &mut ::std::string::String {
        &mut self.worker_path
    }

    // Take field
    pub fn take_worker_path(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.worker_path, ::std::string::String::new())
    }

    // repeated string run_options = 3;


    pub fn get_run_options(&self) -> &[::std::string::String] {
        &self.run_options
    }
    pub fn clear_run_options(&mut self) {
        self.run_options.clear();
    }

    // Param is passed by value, moved
    pub fn set_run_options(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.run_options = v;
    }

    // Mutable pointer to the field.
    pub fn mut_run_options(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.run_options
    }

    // Take field
    pub fn take_run_options(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.run_options, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for ContainerRuntimeEnv {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.image)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.worker_path)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.run_options)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.image.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.image);
        }
        if !self.worker_path.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.worker_path);
        }
        for value in &self.run_options {
            my_size += ::protobuf::rt::string_size(3, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.image.is_empty() {
            os.write_string(1, &self.image)?;
        }
        if !self.worker_path.is_empty() {
            os.write_string(2, &self.worker_path)?;
        }
        for v in &self.run_options {
            os.write_string(3, &v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ContainerRuntimeEnv {
        ContainerRuntimeEnv::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "image",
                |m: &ContainerRuntimeEnv| { &m.image },
                |m: &mut ContainerRuntimeEnv| { &mut m.image },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "worker_path",
                |m: &ContainerRuntimeEnv| { &m.worker_path },
                |m: &mut ContainerRuntimeEnv| { &mut m.worker_path },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "run_options",
                |m: &ContainerRuntimeEnv| { &m.run_options },
                |m: &mut ContainerRuntimeEnv| { &mut m.run_options },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ContainerRuntimeEnv>(
                "ContainerRuntimeEnv",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ContainerRuntimeEnv {
        static instance: ::protobuf::rt::LazyV2<ContainerRuntimeEnv> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ContainerRuntimeEnv::new)
    }
}

impl ::protobuf::Clear for ContainerRuntimeEnv {
    fn clear(&mut self) {
        self.image.clear();
        self.worker_path.clear();
        self.run_options.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ContainerRuntimeEnv {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ContainerRuntimeEnv {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct PluginRuntimeEnv {
    // message fields
    pub plugins: ::protobuf::RepeatedField<PluginRuntimeEnv_Plugin>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PluginRuntimeEnv {
    fn default() -> &'a PluginRuntimeEnv {
        <PluginRuntimeEnv as ::protobuf::Message>::default_instance()
    }
}

impl PluginRuntimeEnv {
    pub fn new() -> PluginRuntimeEnv {
        ::std::default::Default::default()
    }

    // repeated .ray.rpc.PluginRuntimeEnv.Plugin plugins = 1;


    pub fn get_plugins(&self) -> &[PluginRuntimeEnv_Plugin] {
        &self.plugins
    }
    pub fn clear_plugins(&mut self) {
        self.plugins.clear();
    }

    // Param is passed by value, moved
    pub fn set_plugins(&mut self, v: ::protobuf::RepeatedField<PluginRuntimeEnv_Plugin>) {
        self.plugins = v;
    }

    // Mutable pointer to the field.
    pub fn mut_plugins(&mut self) -> &mut ::protobuf::RepeatedField<PluginRuntimeEnv_Plugin> {
        &mut self.plugins
    }

    // Take field
    pub fn take_plugins(&mut self) -> ::protobuf::RepeatedField<PluginRuntimeEnv_Plugin> {
        ::std::mem::replace(&mut self.plugins, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for PluginRuntimeEnv {
    fn is_initialized(&self) -> bool {
        for v in &self.plugins {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.plugins)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.plugins {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.plugins {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PluginRuntimeEnv {
        PluginRuntimeEnv::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<PluginRuntimeEnv_Plugin>>(
                "plugins",
                |m: &PluginRuntimeEnv| { &m.plugins },
                |m: &mut PluginRuntimeEnv| { &mut m.plugins },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<PluginRuntimeEnv>(
                "PluginRuntimeEnv",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static PluginRuntimeEnv {
        static instance: ::protobuf::rt::LazyV2<PluginRuntimeEnv> = ::protobuf::rt::LazyV2::INIT;
        instance.get(PluginRuntimeEnv::new)
    }
}

impl ::protobuf::Clear for PluginRuntimeEnv {
    fn clear(&mut self) {
        self.plugins.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PluginRuntimeEnv {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PluginRuntimeEnv {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct PluginRuntimeEnv_Plugin {
    // message fields
    pub class_path: ::std::string::String,
    pub config: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PluginRuntimeEnv_Plugin {
    fn default() -> &'a PluginRuntimeEnv_Plugin {
        <PluginRuntimeEnv_Plugin as ::protobuf::Message>::default_instance()
    }
}

impl PluginRuntimeEnv_Plugin {
    pub fn new() -> PluginRuntimeEnv_Plugin {
        ::std::default::Default::default()
    }

    // string class_path = 1;


    pub fn get_class_path(&self) -> &str {
        &self.class_path
    }
    pub fn clear_class_path(&mut self) {
        self.class_path.clear();
    }

    // Param is passed by value, moved
    pub fn set_class_path(&mut self, v: ::std::string::String) {
        self.class_path = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_class_path(&mut self) -> &mut ::std::string::String {
        &mut self.class_path
    }

    // Take field
    pub fn take_class_path(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.class_path, ::std::string::String::new())
    }

    // string config = 2;


    pub fn get_config(&self) -> &str {
        &self.config
    }
    pub fn clear_config(&mut self) {
        self.config.clear();
    }

    // Param is passed by value, moved
    pub fn set_config(&mut self, v: ::std::string::String) {
        self.config = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_config(&mut self) -> &mut ::std::string::String {
        &mut self.config
    }

    // Take field
    pub fn take_config(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.config, ::std::string::String::new())
    }
}

impl ::protobuf::Message for PluginRuntimeEnv_Plugin {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.class_path)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.config)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.class_path.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.class_path);
        }
        if !self.config.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.config);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.class_path.is_empty() {
            os.write_string(1, &self.class_path)?;
        }
        if !self.config.is_empty() {
            os.write_string(2, &self.config)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PluginRuntimeEnv_Plugin {
        PluginRuntimeEnv_Plugin::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "class_path",
                |m: &PluginRuntimeEnv_Plugin| { &m.class_path },
                |m: &mut PluginRuntimeEnv_Plugin| { &mut m.class_path },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "config",
                |m: &PluginRuntimeEnv_Plugin| { &m.config },
                |m: &mut PluginRuntimeEnv_Plugin| { &mut m.config },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<PluginRuntimeEnv_Plugin>(
                "PluginRuntimeEnv.Plugin",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static PluginRuntimeEnv_Plugin {
        static instance: ::protobuf::rt::LazyV2<PluginRuntimeEnv_Plugin> = ::protobuf::rt::LazyV2::INIT;
        instance.get(PluginRuntimeEnv_Plugin::new)
    }
}

impl ::protobuf::Clear for PluginRuntimeEnv_Plugin {
    fn clear(&mut self) {
        self.class_path.clear();
        self.config.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PluginRuntimeEnv_Plugin {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PluginRuntimeEnv_Plugin {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct PythonRuntimeEnv {
    // message fields
    pub py_modules: ::protobuf::RepeatedField<::std::string::String>,
    // message oneof groups
    pub python_runtime_env: ::std::option::Option<PythonRuntimeEnv_oneof_python_runtime_env>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PythonRuntimeEnv {
    fn default() -> &'a PythonRuntimeEnv {
        <PythonRuntimeEnv as ::protobuf::Message>::default_instance()
    }
}

#[derive(Clone,PartialEq,Debug)]
pub enum PythonRuntimeEnv_oneof_python_runtime_env {
    pip_runtime_env(PipRuntimeEnv),
    conda_runtime_env(CondaRuntimeEnv),
    container_runtime_env(ContainerRuntimeEnv),
    plugin_runtime_env(PluginRuntimeEnv),
}

impl PythonRuntimeEnv {
    pub fn new() -> PythonRuntimeEnv {
        ::std::default::Default::default()
    }

    // repeated string py_modules = 1;


    pub fn get_py_modules(&self) -> &[::std::string::String] {
        &self.py_modules
    }
    pub fn clear_py_modules(&mut self) {
        self.py_modules.clear();
    }

    // Param is passed by value, moved
    pub fn set_py_modules(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.py_modules = v;
    }

    // Mutable pointer to the field.
    pub fn mut_py_modules(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.py_modules
    }

    // Take field
    pub fn take_py_modules(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.py_modules, ::protobuf::RepeatedField::new())
    }

    // .ray.rpc.PipRuntimeEnv pip_runtime_env = 2;


    pub fn get_pip_runtime_env(&self) -> &PipRuntimeEnv {
        match self.python_runtime_env {
            ::std::option::Option::Some(PythonRuntimeEnv_oneof_python_runtime_env::pip_runtime_env(ref v)) => v,
            _ => <PipRuntimeEnv as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_pip_runtime_env(&mut self) {
        self.python_runtime_env = ::std::option::Option::None;
    }

    pub fn has_pip_runtime_env(&self) -> bool {
        match self.python_runtime_env {
            ::std::option::Option::Some(PythonRuntimeEnv_oneof_python_runtime_env::pip_runtime_env(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_pip_runtime_env(&mut self, v: PipRuntimeEnv) {
        self.python_runtime_env = ::std::option::Option::Some(PythonRuntimeEnv_oneof_python_runtime_env::pip_runtime_env(v))
    }

    // Mutable pointer to the field.
    pub fn mut_pip_runtime_env(&mut self) -> &mut PipRuntimeEnv {
        if let ::std::option::Option::Some(PythonRuntimeEnv_oneof_python_runtime_env::pip_runtime_env(_)) = self.python_runtime_env {
        } else {
            self.python_runtime_env = ::std::option::Option::Some(PythonRuntimeEnv_oneof_python_runtime_env::pip_runtime_env(PipRuntimeEnv::new()));
        }
        match self.python_runtime_env {
            ::std::option::Option::Some(PythonRuntimeEnv_oneof_python_runtime_env::pip_runtime_env(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_pip_runtime_env(&mut self) -> PipRuntimeEnv {
        if self.has_pip_runtime_env() {
            match self.python_runtime_env.take() {
                ::std::option::Option::Some(PythonRuntimeEnv_oneof_python_runtime_env::pip_runtime_env(v)) => v,
                _ => panic!(),
            }
        } else {
            PipRuntimeEnv::new()
        }
    }

    // .ray.rpc.CondaRuntimeEnv conda_runtime_env = 3;


    pub fn get_conda_runtime_env(&self) -> &CondaRuntimeEnv {
        match self.python_runtime_env {
            ::std::option::Option::Some(PythonRuntimeEnv_oneof_python_runtime_env::conda_runtime_env(ref v)) => v,
            _ => <CondaRuntimeEnv as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_conda_runtime_env(&mut self) {
        self.python_runtime_env = ::std::option::Option::None;
    }

    pub fn has_conda_runtime_env(&self) -> bool {
        match self.python_runtime_env {
            ::std::option::Option::Some(PythonRuntimeEnv_oneof_python_runtime_env::conda_runtime_env(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_conda_runtime_env(&mut self, v: CondaRuntimeEnv) {
        self.python_runtime_env = ::std::option::Option::Some(PythonRuntimeEnv_oneof_python_runtime_env::conda_runtime_env(v))
    }

    // Mutable pointer to the field.
    pub fn mut_conda_runtime_env(&mut self) -> &mut CondaRuntimeEnv {
        if let ::std::option::Option::Some(PythonRuntimeEnv_oneof_python_runtime_env::conda_runtime_env(_)) = self.python_runtime_env {
        } else {
            self.python_runtime_env = ::std::option::Option::Some(PythonRuntimeEnv_oneof_python_runtime_env::conda_runtime_env(CondaRuntimeEnv::new()));
        }
        match self.python_runtime_env {
            ::std::option::Option::Some(PythonRuntimeEnv_oneof_python_runtime_env::conda_runtime_env(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_conda_runtime_env(&mut self) -> CondaRuntimeEnv {
        if self.has_conda_runtime_env() {
            match self.python_runtime_env.take() {
                ::std::option::Option::Some(PythonRuntimeEnv_oneof_python_runtime_env::conda_runtime_env(v)) => v,
                _ => panic!(),
            }
        } else {
            CondaRuntimeEnv::new()
        }
    }

    // .ray.rpc.ContainerRuntimeEnv container_runtime_env = 4;


    pub fn get_container_runtime_env(&self) -> &ContainerRuntimeEnv {
        match self.python_runtime_env {
            ::std::option::Option::Some(PythonRuntimeEnv_oneof_python_runtime_env::container_runtime_env(ref v)) => v,
            _ => <ContainerRuntimeEnv as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_container_runtime_env(&mut self) {
        self.python_runtime_env = ::std::option::Option::None;
    }

    pub fn has_container_runtime_env(&self) -> bool {
        match self.python_runtime_env {
            ::std::option::Option::Some(PythonRuntimeEnv_oneof_python_runtime_env::container_runtime_env(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_container_runtime_env(&mut self, v: ContainerRuntimeEnv) {
        self.python_runtime_env = ::std::option::Option::Some(PythonRuntimeEnv_oneof_python_runtime_env::container_runtime_env(v))
    }

    // Mutable pointer to the field.
    pub fn mut_container_runtime_env(&mut self) -> &mut ContainerRuntimeEnv {
        if let ::std::option::Option::Some(PythonRuntimeEnv_oneof_python_runtime_env::container_runtime_env(_)) = self.python_runtime_env {
        } else {
            self.python_runtime_env = ::std::option::Option::Some(PythonRuntimeEnv_oneof_python_runtime_env::container_runtime_env(ContainerRuntimeEnv::new()));
        }
        match self.python_runtime_env {
            ::std::option::Option::Some(PythonRuntimeEnv_oneof_python_runtime_env::container_runtime_env(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_container_runtime_env(&mut self) -> ContainerRuntimeEnv {
        if self.has_container_runtime_env() {
            match self.python_runtime_env.take() {
                ::std::option::Option::Some(PythonRuntimeEnv_oneof_python_runtime_env::container_runtime_env(v)) => v,
                _ => panic!(),
            }
        } else {
            ContainerRuntimeEnv::new()
        }
    }

    // .ray.rpc.PluginRuntimeEnv plugin_runtime_env = 5;


    pub fn get_plugin_runtime_env(&self) -> &PluginRuntimeEnv {
        match self.python_runtime_env {
            ::std::option::Option::Some(PythonRuntimeEnv_oneof_python_runtime_env::plugin_runtime_env(ref v)) => v,
            _ => <PluginRuntimeEnv as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_plugin_runtime_env(&mut self) {
        self.python_runtime_env = ::std::option::Option::None;
    }

    pub fn has_plugin_runtime_env(&self) -> bool {
        match self.python_runtime_env {
            ::std::option::Option::Some(PythonRuntimeEnv_oneof_python_runtime_env::plugin_runtime_env(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_plugin_runtime_env(&mut self, v: PluginRuntimeEnv) {
        self.python_runtime_env = ::std::option::Option::Some(PythonRuntimeEnv_oneof_python_runtime_env::plugin_runtime_env(v))
    }

    // Mutable pointer to the field.
    pub fn mut_plugin_runtime_env(&mut self) -> &mut PluginRuntimeEnv {
        if let ::std::option::Option::Some(PythonRuntimeEnv_oneof_python_runtime_env::plugin_runtime_env(_)) = self.python_runtime_env {
        } else {
            self.python_runtime_env = ::std::option::Option::Some(PythonRuntimeEnv_oneof_python_runtime_env::plugin_runtime_env(PluginRuntimeEnv::new()));
        }
        match self.python_runtime_env {
            ::std::option::Option::Some(PythonRuntimeEnv_oneof_python_runtime_env::plugin_runtime_env(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_plugin_runtime_env(&mut self) -> PluginRuntimeEnv {
        if self.has_plugin_runtime_env() {
            match self.python_runtime_env.take() {
                ::std::option::Option::Some(PythonRuntimeEnv_oneof_python_runtime_env::plugin_runtime_env(v)) => v,
                _ => panic!(),
            }
        } else {
            PluginRuntimeEnv::new()
        }
    }
}

impl ::protobuf::Message for PythonRuntimeEnv {
    fn is_initialized(&self) -> bool {
        if let Some(PythonRuntimeEnv_oneof_python_runtime_env::pip_runtime_env(ref v)) = self.python_runtime_env {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(PythonRuntimeEnv_oneof_python_runtime_env::conda_runtime_env(ref v)) = self.python_runtime_env {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(PythonRuntimeEnv_oneof_python_runtime_env::container_runtime_env(ref v)) = self.python_runtime_env {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(PythonRuntimeEnv_oneof_python_runtime_env::plugin_runtime_env(ref v)) = self.python_runtime_env {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.py_modules)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.python_runtime_env = ::std::option::Option::Some(PythonRuntimeEnv_oneof_python_runtime_env::pip_runtime_env(is.read_message()?));
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.python_runtime_env = ::std::option::Option::Some(PythonRuntimeEnv_oneof_python_runtime_env::conda_runtime_env(is.read_message()?));
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.python_runtime_env = ::std::option::Option::Some(PythonRuntimeEnv_oneof_python_runtime_env::container_runtime_env(is.read_message()?));
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.python_runtime_env = ::std::option::Option::Some(PythonRuntimeEnv_oneof_python_runtime_env::plugin_runtime_env(is.read_message()?));
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.py_modules {
            my_size += ::protobuf::rt::string_size(1, &value);
        };
        if let ::std::option::Option::Some(ref v) = self.python_runtime_env {
            match v {
                &PythonRuntimeEnv_oneof_python_runtime_env::pip_runtime_env(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &PythonRuntimeEnv_oneof_python_runtime_env::conda_runtime_env(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &PythonRuntimeEnv_oneof_python_runtime_env::container_runtime_env(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &PythonRuntimeEnv_oneof_python_runtime_env::plugin_runtime_env(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.py_modules {
            os.write_string(1, &v)?;
        };
        if let ::std::option::Option::Some(ref v) = self.python_runtime_env {
            match v {
                &PythonRuntimeEnv_oneof_python_runtime_env::pip_runtime_env(ref v) => {
                    os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &PythonRuntimeEnv_oneof_python_runtime_env::conda_runtime_env(ref v) => {
                    os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &PythonRuntimeEnv_oneof_python_runtime_env::container_runtime_env(ref v) => {
                    os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &PythonRuntimeEnv_oneof_python_runtime_env::plugin_runtime_env(ref v) => {
                    os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PythonRuntimeEnv {
        PythonRuntimeEnv::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "py_modules",
                |m: &PythonRuntimeEnv| { &m.py_modules },
                |m: &mut PythonRuntimeEnv| { &mut m.py_modules },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, PipRuntimeEnv>(
                "pip_runtime_env",
                PythonRuntimeEnv::has_pip_runtime_env,
                PythonRuntimeEnv::get_pip_runtime_env,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, CondaRuntimeEnv>(
                "conda_runtime_env",
                PythonRuntimeEnv::has_conda_runtime_env,
                PythonRuntimeEnv::get_conda_runtime_env,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, ContainerRuntimeEnv>(
                "container_runtime_env",
                PythonRuntimeEnv::has_container_runtime_env,
                PythonRuntimeEnv::get_container_runtime_env,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, PluginRuntimeEnv>(
                "plugin_runtime_env",
                PythonRuntimeEnv::has_plugin_runtime_env,
                PythonRuntimeEnv::get_plugin_runtime_env,
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<PythonRuntimeEnv>(
                "PythonRuntimeEnv",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static PythonRuntimeEnv {
        static instance: ::protobuf::rt::LazyV2<PythonRuntimeEnv> = ::protobuf::rt::LazyV2::INIT;
        instance.get(PythonRuntimeEnv::new)
    }
}

impl ::protobuf::Clear for PythonRuntimeEnv {
    fn clear(&mut self) {
        self.py_modules.clear();
        self.python_runtime_env = ::std::option::Option::None;
        self.python_runtime_env = ::std::option::Option::None;
        self.python_runtime_env = ::std::option::Option::None;
        self.python_runtime_env = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PythonRuntimeEnv {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PythonRuntimeEnv {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct MavenRuntimeEnv {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a MavenRuntimeEnv {
    fn default() -> &'a MavenRuntimeEnv {
        <MavenRuntimeEnv as ::protobuf::Message>::default_instance()
    }
}

impl MavenRuntimeEnv {
    pub fn new() -> MavenRuntimeEnv {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for MavenRuntimeEnv {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> MavenRuntimeEnv {
        MavenRuntimeEnv::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<MavenRuntimeEnv>(
                "MavenRuntimeEnv",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static MavenRuntimeEnv {
        static instance: ::protobuf::rt::LazyV2<MavenRuntimeEnv> = ::protobuf::rt::LazyV2::INIT;
        instance.get(MavenRuntimeEnv::new)
    }
}

impl ::protobuf::Clear for MavenRuntimeEnv {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for MavenRuntimeEnv {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MavenRuntimeEnv {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct JavaRuntimeEnv {
    // message fields
    pub dependent_jars: ::protobuf::RepeatedField<::std::string::String>,
    pub jvm_options: ::protobuf::RepeatedField<::std::string::String>,
    pub java_home: ::std::string::String,
    // message oneof groups
    pub java_runtime_env: ::std::option::Option<JavaRuntimeEnv_oneof_java_runtime_env>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a JavaRuntimeEnv {
    fn default() -> &'a JavaRuntimeEnv {
        <JavaRuntimeEnv as ::protobuf::Message>::default_instance()
    }
}

#[derive(Clone,PartialEq,Debug)]
pub enum JavaRuntimeEnv_oneof_java_runtime_env {
    maven_runtime_env(MavenRuntimeEnv),
    container_runtime_env(ContainerRuntimeEnv),
    plugin_runtime_env(PluginRuntimeEnv),
}

impl JavaRuntimeEnv {
    pub fn new() -> JavaRuntimeEnv {
        ::std::default::Default::default()
    }

    // repeated string dependent_jars = 1;


    pub fn get_dependent_jars(&self) -> &[::std::string::String] {
        &self.dependent_jars
    }
    pub fn clear_dependent_jars(&mut self) {
        self.dependent_jars.clear();
    }

    // Param is passed by value, moved
    pub fn set_dependent_jars(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.dependent_jars = v;
    }

    // Mutable pointer to the field.
    pub fn mut_dependent_jars(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.dependent_jars
    }

    // Take field
    pub fn take_dependent_jars(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.dependent_jars, ::protobuf::RepeatedField::new())
    }

    // repeated string jvm_options = 2;


    pub fn get_jvm_options(&self) -> &[::std::string::String] {
        &self.jvm_options
    }
    pub fn clear_jvm_options(&mut self) {
        self.jvm_options.clear();
    }

    // Param is passed by value, moved
    pub fn set_jvm_options(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.jvm_options = v;
    }

    // Mutable pointer to the field.
    pub fn mut_jvm_options(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.jvm_options
    }

    // Take field
    pub fn take_jvm_options(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.jvm_options, ::protobuf::RepeatedField::new())
    }

    // string java_home = 3;


    pub fn get_java_home(&self) -> &str {
        &self.java_home
    }
    pub fn clear_java_home(&mut self) {
        self.java_home.clear();
    }

    // Param is passed by value, moved
    pub fn set_java_home(&mut self, v: ::std::string::String) {
        self.java_home = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_java_home(&mut self) -> &mut ::std::string::String {
        &mut self.java_home
    }

    // Take field
    pub fn take_java_home(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.java_home, ::std::string::String::new())
    }

    // .ray.rpc.MavenRuntimeEnv maven_runtime_env = 4;


    pub fn get_maven_runtime_env(&self) -> &MavenRuntimeEnv {
        match self.java_runtime_env {
            ::std::option::Option::Some(JavaRuntimeEnv_oneof_java_runtime_env::maven_runtime_env(ref v)) => v,
            _ => <MavenRuntimeEnv as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_maven_runtime_env(&mut self) {
        self.java_runtime_env = ::std::option::Option::None;
    }

    pub fn has_maven_runtime_env(&self) -> bool {
        match self.java_runtime_env {
            ::std::option::Option::Some(JavaRuntimeEnv_oneof_java_runtime_env::maven_runtime_env(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_maven_runtime_env(&mut self, v: MavenRuntimeEnv) {
        self.java_runtime_env = ::std::option::Option::Some(JavaRuntimeEnv_oneof_java_runtime_env::maven_runtime_env(v))
    }

    // Mutable pointer to the field.
    pub fn mut_maven_runtime_env(&mut self) -> &mut MavenRuntimeEnv {
        if let ::std::option::Option::Some(JavaRuntimeEnv_oneof_java_runtime_env::maven_runtime_env(_)) = self.java_runtime_env {
        } else {
            self.java_runtime_env = ::std::option::Option::Some(JavaRuntimeEnv_oneof_java_runtime_env::maven_runtime_env(MavenRuntimeEnv::new()));
        }
        match self.java_runtime_env {
            ::std::option::Option::Some(JavaRuntimeEnv_oneof_java_runtime_env::maven_runtime_env(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_maven_runtime_env(&mut self) -> MavenRuntimeEnv {
        if self.has_maven_runtime_env() {
            match self.java_runtime_env.take() {
                ::std::option::Option::Some(JavaRuntimeEnv_oneof_java_runtime_env::maven_runtime_env(v)) => v,
                _ => panic!(),
            }
        } else {
            MavenRuntimeEnv::new()
        }
    }

    // .ray.rpc.ContainerRuntimeEnv container_runtime_env = 5;


    pub fn get_container_runtime_env(&self) -> &ContainerRuntimeEnv {
        match self.java_runtime_env {
            ::std::option::Option::Some(JavaRuntimeEnv_oneof_java_runtime_env::container_runtime_env(ref v)) => v,
            _ => <ContainerRuntimeEnv as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_container_runtime_env(&mut self) {
        self.java_runtime_env = ::std::option::Option::None;
    }

    pub fn has_container_runtime_env(&self) -> bool {
        match self.java_runtime_env {
            ::std::option::Option::Some(JavaRuntimeEnv_oneof_java_runtime_env::container_runtime_env(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_container_runtime_env(&mut self, v: ContainerRuntimeEnv) {
        self.java_runtime_env = ::std::option::Option::Some(JavaRuntimeEnv_oneof_java_runtime_env::container_runtime_env(v))
    }

    // Mutable pointer to the field.
    pub fn mut_container_runtime_env(&mut self) -> &mut ContainerRuntimeEnv {
        if let ::std::option::Option::Some(JavaRuntimeEnv_oneof_java_runtime_env::container_runtime_env(_)) = self.java_runtime_env {
        } else {
            self.java_runtime_env = ::std::option::Option::Some(JavaRuntimeEnv_oneof_java_runtime_env::container_runtime_env(ContainerRuntimeEnv::new()));
        }
        match self.java_runtime_env {
            ::std::option::Option::Some(JavaRuntimeEnv_oneof_java_runtime_env::container_runtime_env(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_container_runtime_env(&mut self) -> ContainerRuntimeEnv {
        if self.has_container_runtime_env() {
            match self.java_runtime_env.take() {
                ::std::option::Option::Some(JavaRuntimeEnv_oneof_java_runtime_env::container_runtime_env(v)) => v,
                _ => panic!(),
            }
        } else {
            ContainerRuntimeEnv::new()
        }
    }

    // .ray.rpc.PluginRuntimeEnv plugin_runtime_env = 6;


    pub fn get_plugin_runtime_env(&self) -> &PluginRuntimeEnv {
        match self.java_runtime_env {
            ::std::option::Option::Some(JavaRuntimeEnv_oneof_java_runtime_env::plugin_runtime_env(ref v)) => v,
            _ => <PluginRuntimeEnv as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_plugin_runtime_env(&mut self) {
        self.java_runtime_env = ::std::option::Option::None;
    }

    pub fn has_plugin_runtime_env(&self) -> bool {
        match self.java_runtime_env {
            ::std::option::Option::Some(JavaRuntimeEnv_oneof_java_runtime_env::plugin_runtime_env(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_plugin_runtime_env(&mut self, v: PluginRuntimeEnv) {
        self.java_runtime_env = ::std::option::Option::Some(JavaRuntimeEnv_oneof_java_runtime_env::plugin_runtime_env(v))
    }

    // Mutable pointer to the field.
    pub fn mut_plugin_runtime_env(&mut self) -> &mut PluginRuntimeEnv {
        if let ::std::option::Option::Some(JavaRuntimeEnv_oneof_java_runtime_env::plugin_runtime_env(_)) = self.java_runtime_env {
        } else {
            self.java_runtime_env = ::std::option::Option::Some(JavaRuntimeEnv_oneof_java_runtime_env::plugin_runtime_env(PluginRuntimeEnv::new()));
        }
        match self.java_runtime_env {
            ::std::option::Option::Some(JavaRuntimeEnv_oneof_java_runtime_env::plugin_runtime_env(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_plugin_runtime_env(&mut self) -> PluginRuntimeEnv {
        if self.has_plugin_runtime_env() {
            match self.java_runtime_env.take() {
                ::std::option::Option::Some(JavaRuntimeEnv_oneof_java_runtime_env::plugin_runtime_env(v)) => v,
                _ => panic!(),
            }
        } else {
            PluginRuntimeEnv::new()
        }
    }
}

impl ::protobuf::Message for JavaRuntimeEnv {
    fn is_initialized(&self) -> bool {
        if let Some(JavaRuntimeEnv_oneof_java_runtime_env::maven_runtime_env(ref v)) = self.java_runtime_env {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(JavaRuntimeEnv_oneof_java_runtime_env::container_runtime_env(ref v)) = self.java_runtime_env {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(JavaRuntimeEnv_oneof_java_runtime_env::plugin_runtime_env(ref v)) = self.java_runtime_env {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.dependent_jars)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.jvm_options)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.java_home)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.java_runtime_env = ::std::option::Option::Some(JavaRuntimeEnv_oneof_java_runtime_env::maven_runtime_env(is.read_message()?));
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.java_runtime_env = ::std::option::Option::Some(JavaRuntimeEnv_oneof_java_runtime_env::container_runtime_env(is.read_message()?));
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.java_runtime_env = ::std::option::Option::Some(JavaRuntimeEnv_oneof_java_runtime_env::plugin_runtime_env(is.read_message()?));
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.dependent_jars {
            my_size += ::protobuf::rt::string_size(1, &value);
        };
        for value in &self.jvm_options {
            my_size += ::protobuf::rt::string_size(2, &value);
        };
        if !self.java_home.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.java_home);
        }
        if let ::std::option::Option::Some(ref v) = self.java_runtime_env {
            match v {
                &JavaRuntimeEnv_oneof_java_runtime_env::maven_runtime_env(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &JavaRuntimeEnv_oneof_java_runtime_env::container_runtime_env(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &JavaRuntimeEnv_oneof_java_runtime_env::plugin_runtime_env(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.dependent_jars {
            os.write_string(1, &v)?;
        };
        for v in &self.jvm_options {
            os.write_string(2, &v)?;
        };
        if !self.java_home.is_empty() {
            os.write_string(3, &self.java_home)?;
        }
        if let ::std::option::Option::Some(ref v) = self.java_runtime_env {
            match v {
                &JavaRuntimeEnv_oneof_java_runtime_env::maven_runtime_env(ref v) => {
                    os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &JavaRuntimeEnv_oneof_java_runtime_env::container_runtime_env(ref v) => {
                    os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &JavaRuntimeEnv_oneof_java_runtime_env::plugin_runtime_env(ref v) => {
                    os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> JavaRuntimeEnv {
        JavaRuntimeEnv::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "dependent_jars",
                |m: &JavaRuntimeEnv| { &m.dependent_jars },
                |m: &mut JavaRuntimeEnv| { &mut m.dependent_jars },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "jvm_options",
                |m: &JavaRuntimeEnv| { &m.jvm_options },
                |m: &mut JavaRuntimeEnv| { &mut m.jvm_options },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "java_home",
                |m: &JavaRuntimeEnv| { &m.java_home },
                |m: &mut JavaRuntimeEnv| { &mut m.java_home },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, MavenRuntimeEnv>(
                "maven_runtime_env",
                JavaRuntimeEnv::has_maven_runtime_env,
                JavaRuntimeEnv::get_maven_runtime_env,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, ContainerRuntimeEnv>(
                "container_runtime_env",
                JavaRuntimeEnv::has_container_runtime_env,
                JavaRuntimeEnv::get_container_runtime_env,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, PluginRuntimeEnv>(
                "plugin_runtime_env",
                JavaRuntimeEnv::has_plugin_runtime_env,
                JavaRuntimeEnv::get_plugin_runtime_env,
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<JavaRuntimeEnv>(
                "JavaRuntimeEnv",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static JavaRuntimeEnv {
        static instance: ::protobuf::rt::LazyV2<JavaRuntimeEnv> = ::protobuf::rt::LazyV2::INIT;
        instance.get(JavaRuntimeEnv::new)
    }
}

impl ::protobuf::Clear for JavaRuntimeEnv {
    fn clear(&mut self) {
        self.dependent_jars.clear();
        self.jvm_options.clear();
        self.java_home.clear();
        self.java_runtime_env = ::std::option::Option::None;
        self.java_runtime_env = ::std::option::Option::None;
        self.java_runtime_env = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for JavaRuntimeEnv {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for JavaRuntimeEnv {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CppRuntimeEnv {
    // message fields
    pub dependent_libraries: ::protobuf::RepeatedField<::std::string::String>,
    // message oneof groups
    pub cpp_runtime_env: ::std::option::Option<CppRuntimeEnv_oneof_cpp_runtime_env>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CppRuntimeEnv {
    fn default() -> &'a CppRuntimeEnv {
        <CppRuntimeEnv as ::protobuf::Message>::default_instance()
    }
}

#[derive(Clone,PartialEq,Debug)]
pub enum CppRuntimeEnv_oneof_cpp_runtime_env {
    container_runtime_env(ContainerRuntimeEnv),
    plugin_runtime_env(PluginRuntimeEnv),
}

impl CppRuntimeEnv {
    pub fn new() -> CppRuntimeEnv {
        ::std::default::Default::default()
    }

    // repeated string dependent_libraries = 1;


    pub fn get_dependent_libraries(&self) -> &[::std::string::String] {
        &self.dependent_libraries
    }
    pub fn clear_dependent_libraries(&mut self) {
        self.dependent_libraries.clear();
    }

    // Param is passed by value, moved
    pub fn set_dependent_libraries(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.dependent_libraries = v;
    }

    // Mutable pointer to the field.
    pub fn mut_dependent_libraries(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.dependent_libraries
    }

    // Take field
    pub fn take_dependent_libraries(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.dependent_libraries, ::protobuf::RepeatedField::new())
    }

    // .ray.rpc.ContainerRuntimeEnv container_runtime_env = 2;


    pub fn get_container_runtime_env(&self) -> &ContainerRuntimeEnv {
        match self.cpp_runtime_env {
            ::std::option::Option::Some(CppRuntimeEnv_oneof_cpp_runtime_env::container_runtime_env(ref v)) => v,
            _ => <ContainerRuntimeEnv as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_container_runtime_env(&mut self) {
        self.cpp_runtime_env = ::std::option::Option::None;
    }

    pub fn has_container_runtime_env(&self) -> bool {
        match self.cpp_runtime_env {
            ::std::option::Option::Some(CppRuntimeEnv_oneof_cpp_runtime_env::container_runtime_env(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_container_runtime_env(&mut self, v: ContainerRuntimeEnv) {
        self.cpp_runtime_env = ::std::option::Option::Some(CppRuntimeEnv_oneof_cpp_runtime_env::container_runtime_env(v))
    }

    // Mutable pointer to the field.
    pub fn mut_container_runtime_env(&mut self) -> &mut ContainerRuntimeEnv {
        if let ::std::option::Option::Some(CppRuntimeEnv_oneof_cpp_runtime_env::container_runtime_env(_)) = self.cpp_runtime_env {
        } else {
            self.cpp_runtime_env = ::std::option::Option::Some(CppRuntimeEnv_oneof_cpp_runtime_env::container_runtime_env(ContainerRuntimeEnv::new()));
        }
        match self.cpp_runtime_env {
            ::std::option::Option::Some(CppRuntimeEnv_oneof_cpp_runtime_env::container_runtime_env(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_container_runtime_env(&mut self) -> ContainerRuntimeEnv {
        if self.has_container_runtime_env() {
            match self.cpp_runtime_env.take() {
                ::std::option::Option::Some(CppRuntimeEnv_oneof_cpp_runtime_env::container_runtime_env(v)) => v,
                _ => panic!(),
            }
        } else {
            ContainerRuntimeEnv::new()
        }
    }

    // .ray.rpc.PluginRuntimeEnv plugin_runtime_env = 3;


    pub fn get_plugin_runtime_env(&self) -> &PluginRuntimeEnv {
        match self.cpp_runtime_env {
            ::std::option::Option::Some(CppRuntimeEnv_oneof_cpp_runtime_env::plugin_runtime_env(ref v)) => v,
            _ => <PluginRuntimeEnv as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_plugin_runtime_env(&mut self) {
        self.cpp_runtime_env = ::std::option::Option::None;
    }

    pub fn has_plugin_runtime_env(&self) -> bool {
        match self.cpp_runtime_env {
            ::std::option::Option::Some(CppRuntimeEnv_oneof_cpp_runtime_env::plugin_runtime_env(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_plugin_runtime_env(&mut self, v: PluginRuntimeEnv) {
        self.cpp_runtime_env = ::std::option::Option::Some(CppRuntimeEnv_oneof_cpp_runtime_env::plugin_runtime_env(v))
    }

    // Mutable pointer to the field.
    pub fn mut_plugin_runtime_env(&mut self) -> &mut PluginRuntimeEnv {
        if let ::std::option::Option::Some(CppRuntimeEnv_oneof_cpp_runtime_env::plugin_runtime_env(_)) = self.cpp_runtime_env {
        } else {
            self.cpp_runtime_env = ::std::option::Option::Some(CppRuntimeEnv_oneof_cpp_runtime_env::plugin_runtime_env(PluginRuntimeEnv::new()));
        }
        match self.cpp_runtime_env {
            ::std::option::Option::Some(CppRuntimeEnv_oneof_cpp_runtime_env::plugin_runtime_env(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_plugin_runtime_env(&mut self) -> PluginRuntimeEnv {
        if self.has_plugin_runtime_env() {
            match self.cpp_runtime_env.take() {
                ::std::option::Option::Some(CppRuntimeEnv_oneof_cpp_runtime_env::plugin_runtime_env(v)) => v,
                _ => panic!(),
            }
        } else {
            PluginRuntimeEnv::new()
        }
    }
}

impl ::protobuf::Message for CppRuntimeEnv {
    fn is_initialized(&self) -> bool {
        if let Some(CppRuntimeEnv_oneof_cpp_runtime_env::container_runtime_env(ref v)) = self.cpp_runtime_env {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(CppRuntimeEnv_oneof_cpp_runtime_env::plugin_runtime_env(ref v)) = self.cpp_runtime_env {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.dependent_libraries)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.cpp_runtime_env = ::std::option::Option::Some(CppRuntimeEnv_oneof_cpp_runtime_env::container_runtime_env(is.read_message()?));
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.cpp_runtime_env = ::std::option::Option::Some(CppRuntimeEnv_oneof_cpp_runtime_env::plugin_runtime_env(is.read_message()?));
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.dependent_libraries {
            my_size += ::protobuf::rt::string_size(1, &value);
        };
        if let ::std::option::Option::Some(ref v) = self.cpp_runtime_env {
            match v {
                &CppRuntimeEnv_oneof_cpp_runtime_env::container_runtime_env(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &CppRuntimeEnv_oneof_cpp_runtime_env::plugin_runtime_env(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.dependent_libraries {
            os.write_string(1, &v)?;
        };
        if let ::std::option::Option::Some(ref v) = self.cpp_runtime_env {
            match v {
                &CppRuntimeEnv_oneof_cpp_runtime_env::container_runtime_env(ref v) => {
                    os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &CppRuntimeEnv_oneof_cpp_runtime_env::plugin_runtime_env(ref v) => {
                    os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CppRuntimeEnv {
        CppRuntimeEnv::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "dependent_libraries",
                |m: &CppRuntimeEnv| { &m.dependent_libraries },
                |m: &mut CppRuntimeEnv| { &mut m.dependent_libraries },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, ContainerRuntimeEnv>(
                "container_runtime_env",
                CppRuntimeEnv::has_container_runtime_env,
                CppRuntimeEnv::get_container_runtime_env,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, PluginRuntimeEnv>(
                "plugin_runtime_env",
                CppRuntimeEnv::has_plugin_runtime_env,
                CppRuntimeEnv::get_plugin_runtime_env,
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CppRuntimeEnv>(
                "CppRuntimeEnv",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CppRuntimeEnv {
        static instance: ::protobuf::rt::LazyV2<CppRuntimeEnv> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CppRuntimeEnv::new)
    }
}

impl ::protobuf::Clear for CppRuntimeEnv {
    fn clear(&mut self) {
        self.dependent_libraries.clear();
        self.cpp_runtime_env = ::std::option::Option::None;
        self.cpp_runtime_env = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CppRuntimeEnv {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CppRuntimeEnv {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct RuntimeEnvUris {
    // message fields
    pub working_dir_uri: ::std::string::String,
    pub py_modules_uris: ::protobuf::RepeatedField<::std::string::String>,
    pub conda_uri: ::std::string::String,
    pub pip_uri: ::std::string::String,
    pub plugin_uris: ::protobuf::RepeatedField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a RuntimeEnvUris {
    fn default() -> &'a RuntimeEnvUris {
        <RuntimeEnvUris as ::protobuf::Message>::default_instance()
    }
}

impl RuntimeEnvUris {
    pub fn new() -> RuntimeEnvUris {
        ::std::default::Default::default()
    }

    // string working_dir_uri = 1;


    pub fn get_working_dir_uri(&self) -> &str {
        &self.working_dir_uri
    }
    pub fn clear_working_dir_uri(&mut self) {
        self.working_dir_uri.clear();
    }

    // Param is passed by value, moved
    pub fn set_working_dir_uri(&mut self, v: ::std::string::String) {
        self.working_dir_uri = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_working_dir_uri(&mut self) -> &mut ::std::string::String {
        &mut self.working_dir_uri
    }

    // Take field
    pub fn take_working_dir_uri(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.working_dir_uri, ::std::string::String::new())
    }

    // repeated string py_modules_uris = 2;


    pub fn get_py_modules_uris(&self) -> &[::std::string::String] {
        &self.py_modules_uris
    }
    pub fn clear_py_modules_uris(&mut self) {
        self.py_modules_uris.clear();
    }

    // Param is passed by value, moved
    pub fn set_py_modules_uris(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.py_modules_uris = v;
    }

    // Mutable pointer to the field.
    pub fn mut_py_modules_uris(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.py_modules_uris
    }

    // Take field
    pub fn take_py_modules_uris(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.py_modules_uris, ::protobuf::RepeatedField::new())
    }

    // string conda_uri = 3;


    pub fn get_conda_uri(&self) -> &str {
        &self.conda_uri
    }
    pub fn clear_conda_uri(&mut self) {
        self.conda_uri.clear();
    }

    // Param is passed by value, moved
    pub fn set_conda_uri(&mut self, v: ::std::string::String) {
        self.conda_uri = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_conda_uri(&mut self) -> &mut ::std::string::String {
        &mut self.conda_uri
    }

    // Take field
    pub fn take_conda_uri(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.conda_uri, ::std::string::String::new())
    }

    // string pip_uri = 4;


    pub fn get_pip_uri(&self) -> &str {
        &self.pip_uri
    }
    pub fn clear_pip_uri(&mut self) {
        self.pip_uri.clear();
    }

    // Param is passed by value, moved
    pub fn set_pip_uri(&mut self, v: ::std::string::String) {
        self.pip_uri = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_pip_uri(&mut self) -> &mut ::std::string::String {
        &mut self.pip_uri
    }

    // Take field
    pub fn take_pip_uri(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.pip_uri, ::std::string::String::new())
    }

    // repeated string plugin_uris = 5;


    pub fn get_plugin_uris(&self) -> &[::std::string::String] {
        &self.plugin_uris
    }
    pub fn clear_plugin_uris(&mut self) {
        self.plugin_uris.clear();
    }

    // Param is passed by value, moved
    pub fn set_plugin_uris(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.plugin_uris = v;
    }

    // Mutable pointer to the field.
    pub fn mut_plugin_uris(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.plugin_uris
    }

    // Take field
    pub fn take_plugin_uris(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.plugin_uris, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for RuntimeEnvUris {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.working_dir_uri)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.py_modules_uris)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.conda_uri)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.pip_uri)?;
                },
                5 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.plugin_uris)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.working_dir_uri.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.working_dir_uri);
        }
        for value in &self.py_modules_uris {
            my_size += ::protobuf::rt::string_size(2, &value);
        };
        if !self.conda_uri.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.conda_uri);
        }
        if !self.pip_uri.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.pip_uri);
        }
        for value in &self.plugin_uris {
            my_size += ::protobuf::rt::string_size(5, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.working_dir_uri.is_empty() {
            os.write_string(1, &self.working_dir_uri)?;
        }
        for v in &self.py_modules_uris {
            os.write_string(2, &v)?;
        };
        if !self.conda_uri.is_empty() {
            os.write_string(3, &self.conda_uri)?;
        }
        if !self.pip_uri.is_empty() {
            os.write_string(4, &self.pip_uri)?;
        }
        for v in &self.plugin_uris {
            os.write_string(5, &v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> RuntimeEnvUris {
        RuntimeEnvUris::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "working_dir_uri",
                |m: &RuntimeEnvUris| { &m.working_dir_uri },
                |m: &mut RuntimeEnvUris| { &mut m.working_dir_uri },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "py_modules_uris",
                |m: &RuntimeEnvUris| { &m.py_modules_uris },
                |m: &mut RuntimeEnvUris| { &mut m.py_modules_uris },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "conda_uri",
                |m: &RuntimeEnvUris| { &m.conda_uri },
                |m: &mut RuntimeEnvUris| { &mut m.conda_uri },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "pip_uri",
                |m: &RuntimeEnvUris| { &m.pip_uri },
                |m: &mut RuntimeEnvUris| { &mut m.pip_uri },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "plugin_uris",
                |m: &RuntimeEnvUris| { &m.plugin_uris },
                |m: &mut RuntimeEnvUris| { &mut m.plugin_uris },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<RuntimeEnvUris>(
                "RuntimeEnvUris",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static RuntimeEnvUris {
        static instance: ::protobuf::rt::LazyV2<RuntimeEnvUris> = ::protobuf::rt::LazyV2::INIT;
        instance.get(RuntimeEnvUris::new)
    }
}

impl ::protobuf::Clear for RuntimeEnvUris {
    fn clear(&mut self) {
        self.working_dir_uri.clear();
        self.py_modules_uris.clear();
        self.conda_uri.clear();
        self.pip_uri.clear();
        self.plugin_uris.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RuntimeEnvUris {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RuntimeEnvUris {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct RuntimeEnv {
    // message fields
    pub working_dir: ::std::string::String,
    pub env_vars: ::std::collections::HashMap<::std::string::String, ::std::string::String>,
    pub extensions: ::std::collections::HashMap<::std::string::String, ::std::string::String>,
    pub python_runtime_env: ::protobuf::SingularPtrField<PythonRuntimeEnv>,
    pub java_runtime_env: ::protobuf::SingularPtrField<JavaRuntimeEnv>,
    pub cpp_runtime_env: ::protobuf::SingularPtrField<CppRuntimeEnv>,
    pub uris: ::protobuf::SingularPtrField<RuntimeEnvUris>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a RuntimeEnv {
    fn default() -> &'a RuntimeEnv {
        <RuntimeEnv as ::protobuf::Message>::default_instance()
    }
}

impl RuntimeEnv {
    pub fn new() -> RuntimeEnv {
        ::std::default::Default::default()
    }

    // string working_dir = 1;


    pub fn get_working_dir(&self) -> &str {
        &self.working_dir
    }
    pub fn clear_working_dir(&mut self) {
        self.working_dir.clear();
    }

    // Param is passed by value, moved
    pub fn set_working_dir(&mut self, v: ::std::string::String) {
        self.working_dir = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_working_dir(&mut self) -> &mut ::std::string::String {
        &mut self.working_dir
    }

    // Take field
    pub fn take_working_dir(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.working_dir, ::std::string::String::new())
    }

    // repeated .ray.rpc.RuntimeEnv.EnvVarsEntry env_vars = 2;


    pub fn get_env_vars(&self) -> &::std::collections::HashMap<::std::string::String, ::std::string::String> {
        &self.env_vars
    }
    pub fn clear_env_vars(&mut self) {
        self.env_vars.clear();
    }

    // Param is passed by value, moved
    pub fn set_env_vars(&mut self, v: ::std::collections::HashMap<::std::string::String, ::std::string::String>) {
        self.env_vars = v;
    }

    // Mutable pointer to the field.
    pub fn mut_env_vars(&mut self) -> &mut ::std::collections::HashMap<::std::string::String, ::std::string::String> {
        &mut self.env_vars
    }

    // Take field
    pub fn take_env_vars(&mut self) -> ::std::collections::HashMap<::std::string::String, ::std::string::String> {
        ::std::mem::replace(&mut self.env_vars, ::std::collections::HashMap::new())
    }

    // repeated .ray.rpc.RuntimeEnv.ExtensionsEntry extensions = 3;


    pub fn get_extensions(&self) -> &::std::collections::HashMap<::std::string::String, ::std::string::String> {
        &self.extensions
    }
    pub fn clear_extensions(&mut self) {
        self.extensions.clear();
    }

    // Param is passed by value, moved
    pub fn set_extensions(&mut self, v: ::std::collections::HashMap<::std::string::String, ::std::string::String>) {
        self.extensions = v;
    }

    // Mutable pointer to the field.
    pub fn mut_extensions(&mut self) -> &mut ::std::collections::HashMap<::std::string::String, ::std::string::String> {
        &mut self.extensions
    }

    // Take field
    pub fn take_extensions(&mut self) -> ::std::collections::HashMap<::std::string::String, ::std::string::String> {
        ::std::mem::replace(&mut self.extensions, ::std::collections::HashMap::new())
    }

    // .ray.rpc.PythonRuntimeEnv python_runtime_env = 4;


    pub fn get_python_runtime_env(&self) -> &PythonRuntimeEnv {
        self.python_runtime_env.as_ref().unwrap_or_else(|| <PythonRuntimeEnv as ::protobuf::Message>::default_instance())
    }
    pub fn clear_python_runtime_env(&mut self) {
        self.python_runtime_env.clear();
    }

    pub fn has_python_runtime_env(&self) -> bool {
        self.python_runtime_env.is_some()
    }

    // Param is passed by value, moved
    pub fn set_python_runtime_env(&mut self, v: PythonRuntimeEnv) {
        self.python_runtime_env = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_python_runtime_env(&mut self) -> &mut PythonRuntimeEnv {
        if self.python_runtime_env.is_none() {
            self.python_runtime_env.set_default();
        }
        self.python_runtime_env.as_mut().unwrap()
    }

    // Take field
    pub fn take_python_runtime_env(&mut self) -> PythonRuntimeEnv {
        self.python_runtime_env.take().unwrap_or_else(|| PythonRuntimeEnv::new())
    }

    // .ray.rpc.JavaRuntimeEnv java_runtime_env = 5;


    pub fn get_java_runtime_env(&self) -> &JavaRuntimeEnv {
        self.java_runtime_env.as_ref().unwrap_or_else(|| <JavaRuntimeEnv as ::protobuf::Message>::default_instance())
    }
    pub fn clear_java_runtime_env(&mut self) {
        self.java_runtime_env.clear();
    }

    pub fn has_java_runtime_env(&self) -> bool {
        self.java_runtime_env.is_some()
    }

    // Param is passed by value, moved
    pub fn set_java_runtime_env(&mut self, v: JavaRuntimeEnv) {
        self.java_runtime_env = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_java_runtime_env(&mut self) -> &mut JavaRuntimeEnv {
        if self.java_runtime_env.is_none() {
            self.java_runtime_env.set_default();
        }
        self.java_runtime_env.as_mut().unwrap()
    }

    // Take field
    pub fn take_java_runtime_env(&mut self) -> JavaRuntimeEnv {
        self.java_runtime_env.take().unwrap_or_else(|| JavaRuntimeEnv::new())
    }

    // .ray.rpc.CppRuntimeEnv cpp_runtime_env = 6;


    pub fn get_cpp_runtime_env(&self) -> &CppRuntimeEnv {
        self.cpp_runtime_env.as_ref().unwrap_or_else(|| <CppRuntimeEnv as ::protobuf::Message>::default_instance())
    }
    pub fn clear_cpp_runtime_env(&mut self) {
        self.cpp_runtime_env.clear();
    }

    pub fn has_cpp_runtime_env(&self) -> bool {
        self.cpp_runtime_env.is_some()
    }

    // Param is passed by value, moved
    pub fn set_cpp_runtime_env(&mut self, v: CppRuntimeEnv) {
        self.cpp_runtime_env = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_cpp_runtime_env(&mut self) -> &mut CppRuntimeEnv {
        if self.cpp_runtime_env.is_none() {
            self.cpp_runtime_env.set_default();
        }
        self.cpp_runtime_env.as_mut().unwrap()
    }

    // Take field
    pub fn take_cpp_runtime_env(&mut self) -> CppRuntimeEnv {
        self.cpp_runtime_env.take().unwrap_or_else(|| CppRuntimeEnv::new())
    }

    // .ray.rpc.RuntimeEnvUris uris = 7;


    pub fn get_uris(&self) -> &RuntimeEnvUris {
        self.uris.as_ref().unwrap_or_else(|| <RuntimeEnvUris as ::protobuf::Message>::default_instance())
    }
    pub fn clear_uris(&mut self) {
        self.uris.clear();
    }

    pub fn has_uris(&self) -> bool {
        self.uris.is_some()
    }

    // Param is passed by value, moved
    pub fn set_uris(&mut self, v: RuntimeEnvUris) {
        self.uris = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_uris(&mut self) -> &mut RuntimeEnvUris {
        if self.uris.is_none() {
            self.uris.set_default();
        }
        self.uris.as_mut().unwrap()
    }

    // Take field
    pub fn take_uris(&mut self) -> RuntimeEnvUris {
        self.uris.take().unwrap_or_else(|| RuntimeEnvUris::new())
    }
}

impl ::protobuf::Message for RuntimeEnv {
    fn is_initialized(&self) -> bool {
        for v in &self.python_runtime_env {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.java_runtime_env {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.cpp_runtime_env {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.uris {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.working_dir)?;
                },
                2 => {
                    ::protobuf::rt::read_map_into::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(wire_type, is, &mut self.env_vars)?;
                },
                3 => {
                    ::protobuf::rt::read_map_into::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(wire_type, is, &mut self.extensions)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.python_runtime_env)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.java_runtime_env)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.cpp_runtime_env)?;
                },
                7 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.uris)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.working_dir.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.working_dir);
        }
        my_size += ::protobuf::rt::compute_map_size::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(2, &self.env_vars);
        my_size += ::protobuf::rt::compute_map_size::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(3, &self.extensions);
        if let Some(ref v) = self.python_runtime_env.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.java_runtime_env.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.cpp_runtime_env.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.uris.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.working_dir.is_empty() {
            os.write_string(1, &self.working_dir)?;
        }
        ::protobuf::rt::write_map_with_cached_sizes::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(2, &self.env_vars, os)?;
        ::protobuf::rt::write_map_with_cached_sizes::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(3, &self.extensions, os)?;
        if let Some(ref v) = self.python_runtime_env.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.java_runtime_env.as_ref() {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.cpp_runtime_env.as_ref() {
            os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.uris.as_ref() {
            os.write_tag(7, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> RuntimeEnv {
        RuntimeEnv::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "working_dir",
                |m: &RuntimeEnv| { &m.working_dir },
                |m: &mut RuntimeEnv| { &mut m.working_dir },
            ));
            fields.push(::protobuf::reflect::accessor::make_map_accessor::<_, ::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(
                "env_vars",
                |m: &RuntimeEnv| { &m.env_vars },
                |m: &mut RuntimeEnv| { &mut m.env_vars },
            ));
            fields.push(::protobuf::reflect::accessor::make_map_accessor::<_, ::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(
                "extensions",
                |m: &RuntimeEnv| { &m.extensions },
                |m: &mut RuntimeEnv| { &mut m.extensions },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<PythonRuntimeEnv>>(
                "python_runtime_env",
                |m: &RuntimeEnv| { &m.python_runtime_env },
                |m: &mut RuntimeEnv| { &mut m.python_runtime_env },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<JavaRuntimeEnv>>(
                "java_runtime_env",
                |m: &RuntimeEnv| { &m.java_runtime_env },
                |m: &mut RuntimeEnv| { &mut m.java_runtime_env },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CppRuntimeEnv>>(
                "cpp_runtime_env",
                |m: &RuntimeEnv| { &m.cpp_runtime_env },
                |m: &mut RuntimeEnv| { &mut m.cpp_runtime_env },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<RuntimeEnvUris>>(
                "uris",
                |m: &RuntimeEnv| { &m.uris },
                |m: &mut RuntimeEnv| { &mut m.uris },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<RuntimeEnv>(
                "RuntimeEnv",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static RuntimeEnv {
        static instance: ::protobuf::rt::LazyV2<RuntimeEnv> = ::protobuf::rt::LazyV2::INIT;
        instance.get(RuntimeEnv::new)
    }
}

impl ::protobuf::Clear for RuntimeEnv {
    fn clear(&mut self) {
        self.working_dir.clear();
        self.env_vars.clear();
        self.extensions.clear();
        self.python_runtime_env.clear();
        self.java_runtime_env.clear();
        self.cpp_runtime_env.clear();
        self.uris.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RuntimeEnv {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RuntimeEnv {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct RuntimeEnvInfo {
    // message fields
    pub serialized_runtime_env: ::std::string::String,
    pub uris: ::protobuf::RepeatedField<::std::string::String>,
    pub runtime_env_eager_install: bool,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a RuntimeEnvInfo {
    fn default() -> &'a RuntimeEnvInfo {
        <RuntimeEnvInfo as ::protobuf::Message>::default_instance()
    }
}

impl RuntimeEnvInfo {
    pub fn new() -> RuntimeEnvInfo {
        ::std::default::Default::default()
    }

    // string serialized_runtime_env = 1;


    pub fn get_serialized_runtime_env(&self) -> &str {
        &self.serialized_runtime_env
    }
    pub fn clear_serialized_runtime_env(&mut self) {
        self.serialized_runtime_env.clear();
    }

    // Param is passed by value, moved
    pub fn set_serialized_runtime_env(&mut self, v: ::std::string::String) {
        self.serialized_runtime_env = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_serialized_runtime_env(&mut self) -> &mut ::std::string::String {
        &mut self.serialized_runtime_env
    }

    // Take field
    pub fn take_serialized_runtime_env(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.serialized_runtime_env, ::std::string::String::new())
    }

    // repeated string uris = 2;


    pub fn get_uris(&self) -> &[::std::string::String] {
        &self.uris
    }
    pub fn clear_uris(&mut self) {
        self.uris.clear();
    }

    // Param is passed by value, moved
    pub fn set_uris(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.uris = v;
    }

    // Mutable pointer to the field.
    pub fn mut_uris(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.uris
    }

    // Take field
    pub fn take_uris(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.uris, ::protobuf::RepeatedField::new())
    }

    // bool runtime_env_eager_install = 3;


    pub fn get_runtime_env_eager_install(&self) -> bool {
        self.runtime_env_eager_install
    }
    pub fn clear_runtime_env_eager_install(&mut self) {
        self.runtime_env_eager_install = false;
    }

    // Param is passed by value, moved
    pub fn set_runtime_env_eager_install(&mut self, v: bool) {
        self.runtime_env_eager_install = v;
    }
}

impl ::protobuf::Message for RuntimeEnvInfo {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.serialized_runtime_env)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.uris)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.runtime_env_eager_install = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.serialized_runtime_env.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.serialized_runtime_env);
        }
        for value in &self.uris {
            my_size += ::protobuf::rt::string_size(2, &value);
        };
        if self.runtime_env_eager_install != false {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.serialized_runtime_env.is_empty() {
            os.write_string(1, &self.serialized_runtime_env)?;
        }
        for v in &self.uris {
            os.write_string(2, &v)?;
        };
        if self.runtime_env_eager_install != false {
            os.write_bool(3, self.runtime_env_eager_install)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> RuntimeEnvInfo {
        RuntimeEnvInfo::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "serialized_runtime_env",
                |m: &RuntimeEnvInfo| { &m.serialized_runtime_env },
                |m: &mut RuntimeEnvInfo| { &mut m.serialized_runtime_env },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "uris",
                |m: &RuntimeEnvInfo| { &m.uris },
                |m: &mut RuntimeEnvInfo| { &mut m.uris },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "runtime_env_eager_install",
                |m: &RuntimeEnvInfo| { &m.runtime_env_eager_install },
                |m: &mut RuntimeEnvInfo| { &mut m.runtime_env_eager_install },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<RuntimeEnvInfo>(
                "RuntimeEnvInfo",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static RuntimeEnvInfo {
        static instance: ::protobuf::rt::LazyV2<RuntimeEnvInfo> = ::protobuf::rt::LazyV2::INIT;
        instance.get(RuntimeEnvInfo::new)
    }
}

impl ::protobuf::Clear for RuntimeEnvInfo {
    fn clear(&mut self) {
        self.serialized_runtime_env.clear();
        self.uris.clear();
        self.runtime_env_eager_install = false;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RuntimeEnvInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RuntimeEnvInfo {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n)src/ray/protobuf/runtime_env_common.proto\x12\x07ray.rpc\"\xad\x01\n\
    \rPipRuntimeEnv\x127\n\x06config\x18\x01\x20\x01(\x0b2\x1d.ray.rpc.PipRu\
    ntimeEnv.ConfigH\0R\x06config\x12*\n\x10virtual_env_name\x18\x02\x20\x01\
    (\tH\0R\x0evirtualEnvName\x1a$\n\x06Config\x12\x1a\n\x08packages\x18\x01\
    \x20\x03(\tR\x08packagesB\x11\n\x0fpip_runtime_env\"h\n\x0fCondaRuntimeE\
    nv\x12\x18\n\x06config\x18\x01\x20\x01(\tH\0R\x06config\x12&\n\x0econda_\
    env_name\x18\x02\x20\x01(\tH\0R\x0ccondaEnvNameB\x13\n\x11conda_runtime_\
    env\"m\n\x13ContainerRuntimeEnv\x12\x14\n\x05image\x18\x01\x20\x01(\tR\
    \x05image\x12\x1f\n\x0bworker_path\x18\x02\x20\x01(\tR\nworkerPath\x12\
    \x1f\n\x0brun_options\x18\x03\x20\x03(\tR\nrunOptions\"\x8f\x01\n\x10Plu\
    ginRuntimeEnv\x12:\n\x07plugins\x18\x01\x20\x03(\x0b2\x20.ray.rpc.Plugin\
    RuntimeEnv.PluginR\x07plugins\x1a?\n\x06Plugin\x12\x1d\n\nclass_path\x18\
    \x01\x20\x01(\tR\tclassPath\x12\x16\n\x06config\x18\x02\x20\x01(\tR\x06c\
    onfig\"\xf0\x02\n\x10PythonRuntimeEnv\x12\x1d\n\npy_modules\x18\x01\x20\
    \x03(\tR\tpyModules\x12@\n\x0fpip_runtime_env\x18\x02\x20\x01(\x0b2\x16.\
    ray.rpc.PipRuntimeEnvH\0R\rpipRuntimeEnv\x12F\n\x11conda_runtime_env\x18\
    \x03\x20\x01(\x0b2\x18.ray.rpc.CondaRuntimeEnvH\0R\x0fcondaRuntimeEnv\
    \x12R\n\x15container_runtime_env\x18\x04\x20\x01(\x0b2\x1c.ray.rpc.Conta\
    inerRuntimeEnvH\0R\x13containerRuntimeEnv\x12I\n\x12plugin_runtime_env\
    \x18\x05\x20\x01(\x0b2\x19.ray.rpc.PluginRuntimeEnvH\0R\x10pluginRuntime\
    EnvB\x14\n\x12python_runtime_env\"\x11\n\x0fMavenRuntimeEnv\"\xf0\x02\n\
    \x0eJavaRuntimeEnv\x12%\n\x0edependent_jars\x18\x01\x20\x03(\tR\rdepende\
    ntJars\x12\x1f\n\x0bjvm_options\x18\x02\x20\x03(\tR\njvmOptions\x12\x1b\
    \n\tjava_home\x18\x03\x20\x01(\tR\x08javaHome\x12F\n\x11maven_runtime_en\
    v\x18\x04\x20\x01(\x0b2\x18.ray.rpc.MavenRuntimeEnvH\0R\x0fmavenRuntimeE\
    nv\x12R\n\x15container_runtime_env\x18\x05\x20\x01(\x0b2\x1c.ray.rpc.Con\
    tainerRuntimeEnvH\0R\x13containerRuntimeEnv\x12I\n\x12plugin_runtime_env\
    \x18\x06\x20\x01(\x0b2\x19.ray.rpc.PluginRuntimeEnvH\0R\x10pluginRuntime\
    EnvB\x12\n\x10java_runtime_env\"\xf2\x01\n\rCppRuntimeEnv\x12/\n\x13depe\
    ndent_libraries\x18\x01\x20\x03(\tR\x12dependentLibraries\x12R\n\x15cont\
    ainer_runtime_env\x18\x02\x20\x01(\x0b2\x1c.ray.rpc.ContainerRuntimeEnvH\
    \0R\x13containerRuntimeEnv\x12I\n\x12plugin_runtime_env\x18\x03\x20\x01(\
    \x0b2\x19.ray.rpc.PluginRuntimeEnvH\0R\x10pluginRuntimeEnvB\x11\n\x0fcpp\
    _runtime_env\"\xb7\x01\n\x0eRuntimeEnvUris\x12&\n\x0fworking_dir_uri\x18\
    \x01\x20\x01(\tR\rworkingDirUri\x12&\n\x0fpy_modules_uris\x18\x02\x20\
    \x03(\tR\rpyModulesUris\x12\x1b\n\tconda_uri\x18\x03\x20\x01(\tR\x08cond\
    aUri\x12\x17\n\x07pip_uri\x18\x04\x20\x01(\tR\x06pipUri\x12\x1f\n\x0bplu\
    gin_uris\x18\x05\x20\x03(\tR\npluginUris\"\xa3\x04\n\nRuntimeEnv\x12\x1f\
    \n\x0bworking_dir\x18\x01\x20\x01(\tR\nworkingDir\x12;\n\x08env_vars\x18\
    \x02\x20\x03(\x0b2\x20.ray.rpc.RuntimeEnv.EnvVarsEntryR\x07envVars\x12C\
    \n\nextensions\x18\x03\x20\x03(\x0b2#.ray.rpc.RuntimeEnv.ExtensionsEntry\
    R\nextensions\x12G\n\x12python_runtime_env\x18\x04\x20\x01(\x0b2\x19.ray\
    .rpc.PythonRuntimeEnvR\x10pythonRuntimeEnv\x12A\n\x10java_runtime_env\
    \x18\x05\x20\x01(\x0b2\x17.ray.rpc.JavaRuntimeEnvR\x0ejavaRuntimeEnv\x12\
    >\n\x0fcpp_runtime_env\x18\x06\x20\x01(\x0b2\x16.ray.rpc.CppRuntimeEnvR\
    \rcppRuntimeEnv\x12+\n\x04uris\x18\x07\x20\x01(\x0b2\x17.ray.rpc.Runtime\
    EnvUrisR\x04uris\x1a:\n\x0cEnvVarsEntry\x12\x10\n\x03key\x18\x01\x20\x01\
    (\tR\x03key\x12\x14\n\x05value\x18\x02\x20\x01(\tR\x05value:\x028\x01\
    \x1a=\n\x0fExtensionsEntry\x12\x10\n\x03key\x18\x01\x20\x01(\tR\x03key\
    \x12\x14\n\x05value\x18\x02\x20\x01(\tR\x05value:\x028\x01\"\x95\x01\n\
    \x0eRuntimeEnvInfo\x124\n\x16serialized_runtime_env\x18\x01\x20\x01(\tR\
    \x14serializedRuntimeEnv\x12\x12\n\x04uris\x18\x02\x20\x03(\tR\x04uris\
    \x129\n\x19runtime_env_eager_install\x18\x03\x20\x01(\x08R\x16runtimeEnv\
    EagerInstallB\x1d\n\x18io.ray.runtime.generated\xf8\x01\x01b\x06proto3\
";

static file_descriptor_proto_lazy: ::protobuf::rt::LazyV2<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::rt::LazyV2::INIT;

fn parse_descriptor_proto() -> ::protobuf::descriptor::FileDescriptorProto {
    ::protobuf::parse_from_bytes(file_descriptor_proto_data).unwrap()
}

pub fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    file_descriptor_proto_lazy.get(|| {
        parse_descriptor_proto()
    })
}
