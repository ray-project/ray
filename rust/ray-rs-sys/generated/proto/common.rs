// This file is generated by rust-protobuf 2.18.2. Do not edit
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![cfg_attr(rustfmt, rustfmt::skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_imports)]
#![allow(unused_results)]
//! Generated file from `src/ray/protobuf/common.proto`

/// Generated files are compatible only with the same version
/// of protobuf runtime.
// const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_2_18_2;

#[derive(PartialEq,Clone,Default)]
pub struct PlacementGroupSchedulingStrategy {
    // message fields
    pub placement_group_id: ::std::vec::Vec<u8>,
    pub placement_group_bundle_index: i64,
    pub placement_group_capture_child_tasks: bool,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PlacementGroupSchedulingStrategy {
    fn default() -> &'a PlacementGroupSchedulingStrategy {
        <PlacementGroupSchedulingStrategy as ::protobuf::Message>::default_instance()
    }
}

impl PlacementGroupSchedulingStrategy {
    pub fn new() -> PlacementGroupSchedulingStrategy {
        ::std::default::Default::default()
    }

    // bytes placement_group_id = 1;


    pub fn get_placement_group_id(&self) -> &[u8] {
        &self.placement_group_id
    }
    pub fn clear_placement_group_id(&mut self) {
        self.placement_group_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_placement_group_id(&mut self, v: ::std::vec::Vec<u8>) {
        self.placement_group_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_placement_group_id(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.placement_group_id
    }

    // Take field
    pub fn take_placement_group_id(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.placement_group_id, ::std::vec::Vec::new())
    }

    // int64 placement_group_bundle_index = 2;


    pub fn get_placement_group_bundle_index(&self) -> i64 {
        self.placement_group_bundle_index
    }
    pub fn clear_placement_group_bundle_index(&mut self) {
        self.placement_group_bundle_index = 0;
    }

    // Param is passed by value, moved
    pub fn set_placement_group_bundle_index(&mut self, v: i64) {
        self.placement_group_bundle_index = v;
    }

    // bool placement_group_capture_child_tasks = 3;


    pub fn get_placement_group_capture_child_tasks(&self) -> bool {
        self.placement_group_capture_child_tasks
    }
    pub fn clear_placement_group_capture_child_tasks(&mut self) {
        self.placement_group_capture_child_tasks = false;
    }

    // Param is passed by value, moved
    pub fn set_placement_group_capture_child_tasks(&mut self, v: bool) {
        self.placement_group_capture_child_tasks = v;
    }
}

impl ::protobuf::Message for PlacementGroupSchedulingStrategy {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.placement_group_id)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.placement_group_bundle_index = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.placement_group_capture_child_tasks = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.placement_group_id.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.placement_group_id);
        }
        if self.placement_group_bundle_index != 0 {
            my_size += ::protobuf::rt::value_size(2, self.placement_group_bundle_index, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.placement_group_capture_child_tasks != false {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.placement_group_id.is_empty() {
            os.write_bytes(1, &self.placement_group_id)?;
        }
        if self.placement_group_bundle_index != 0 {
            os.write_int64(2, self.placement_group_bundle_index)?;
        }
        if self.placement_group_capture_child_tasks != false {
            os.write_bool(3, self.placement_group_capture_child_tasks)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PlacementGroupSchedulingStrategy {
        PlacementGroupSchedulingStrategy::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "placement_group_id",
                |m: &PlacementGroupSchedulingStrategy| { &m.placement_group_id },
                |m: &mut PlacementGroupSchedulingStrategy| { &mut m.placement_group_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "placement_group_bundle_index",
                |m: &PlacementGroupSchedulingStrategy| { &m.placement_group_bundle_index },
                |m: &mut PlacementGroupSchedulingStrategy| { &mut m.placement_group_bundle_index },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "placement_group_capture_child_tasks",
                |m: &PlacementGroupSchedulingStrategy| { &m.placement_group_capture_child_tasks },
                |m: &mut PlacementGroupSchedulingStrategy| { &mut m.placement_group_capture_child_tasks },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<PlacementGroupSchedulingStrategy>(
                "PlacementGroupSchedulingStrategy",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static PlacementGroupSchedulingStrategy {
        static instance: ::protobuf::rt::LazyV2<PlacementGroupSchedulingStrategy> = ::protobuf::rt::LazyV2::INIT;
        instance.get(PlacementGroupSchedulingStrategy::new)
    }
}

impl ::protobuf::Clear for PlacementGroupSchedulingStrategy {
    fn clear(&mut self) {
        self.placement_group_id.clear();
        self.placement_group_bundle_index = 0;
        self.placement_group_capture_child_tasks = false;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PlacementGroupSchedulingStrategy {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PlacementGroupSchedulingStrategy {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct DefaultSchedulingStrategy {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a DefaultSchedulingStrategy {
    fn default() -> &'a DefaultSchedulingStrategy {
        <DefaultSchedulingStrategy as ::protobuf::Message>::default_instance()
    }
}

impl DefaultSchedulingStrategy {
    pub fn new() -> DefaultSchedulingStrategy {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for DefaultSchedulingStrategy {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DefaultSchedulingStrategy {
        DefaultSchedulingStrategy::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<DefaultSchedulingStrategy>(
                "DefaultSchedulingStrategy",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static DefaultSchedulingStrategy {
        static instance: ::protobuf::rt::LazyV2<DefaultSchedulingStrategy> = ::protobuf::rt::LazyV2::INIT;
        instance.get(DefaultSchedulingStrategy::new)
    }
}

impl ::protobuf::Clear for DefaultSchedulingStrategy {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DefaultSchedulingStrategy {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DefaultSchedulingStrategy {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct SpreadSchedulingStrategy {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SpreadSchedulingStrategy {
    fn default() -> &'a SpreadSchedulingStrategy {
        <SpreadSchedulingStrategy as ::protobuf::Message>::default_instance()
    }
}

impl SpreadSchedulingStrategy {
    pub fn new() -> SpreadSchedulingStrategy {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for SpreadSchedulingStrategy {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SpreadSchedulingStrategy {
        SpreadSchedulingStrategy::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<SpreadSchedulingStrategy>(
                "SpreadSchedulingStrategy",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static SpreadSchedulingStrategy {
        static instance: ::protobuf::rt::LazyV2<SpreadSchedulingStrategy> = ::protobuf::rt::LazyV2::INIT;
        instance.get(SpreadSchedulingStrategy::new)
    }
}

impl ::protobuf::Clear for SpreadSchedulingStrategy {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SpreadSchedulingStrategy {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SpreadSchedulingStrategy {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct SchedulingStrategy {
    // message oneof groups
    pub scheduling_strategy: ::std::option::Option<SchedulingStrategy_oneof_scheduling_strategy>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SchedulingStrategy {
    fn default() -> &'a SchedulingStrategy {
        <SchedulingStrategy as ::protobuf::Message>::default_instance()
    }
}

#[derive(Clone,PartialEq,Debug)]
pub enum SchedulingStrategy_oneof_scheduling_strategy {
    default_scheduling_strategy(DefaultSchedulingStrategy),
    placement_group_scheduling_strategy(PlacementGroupSchedulingStrategy),
    spread_scheduling_strategy(SpreadSchedulingStrategy),
}

impl SchedulingStrategy {
    pub fn new() -> SchedulingStrategy {
        ::std::default::Default::default()
    }

    // .ray.rpc.DefaultSchedulingStrategy default_scheduling_strategy = 1;


    pub fn get_default_scheduling_strategy(&self) -> &DefaultSchedulingStrategy {
        match self.scheduling_strategy {
            ::std::option::Option::Some(SchedulingStrategy_oneof_scheduling_strategy::default_scheduling_strategy(ref v)) => v,
            _ => <DefaultSchedulingStrategy as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_default_scheduling_strategy(&mut self) {
        self.scheduling_strategy = ::std::option::Option::None;
    }

    pub fn has_default_scheduling_strategy(&self) -> bool {
        match self.scheduling_strategy {
            ::std::option::Option::Some(SchedulingStrategy_oneof_scheduling_strategy::default_scheduling_strategy(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_default_scheduling_strategy(&mut self, v: DefaultSchedulingStrategy) {
        self.scheduling_strategy = ::std::option::Option::Some(SchedulingStrategy_oneof_scheduling_strategy::default_scheduling_strategy(v))
    }

    // Mutable pointer to the field.
    pub fn mut_default_scheduling_strategy(&mut self) -> &mut DefaultSchedulingStrategy {
        if let ::std::option::Option::Some(SchedulingStrategy_oneof_scheduling_strategy::default_scheduling_strategy(_)) = self.scheduling_strategy {
        } else {
            self.scheduling_strategy = ::std::option::Option::Some(SchedulingStrategy_oneof_scheduling_strategy::default_scheduling_strategy(DefaultSchedulingStrategy::new()));
        }
        match self.scheduling_strategy {
            ::std::option::Option::Some(SchedulingStrategy_oneof_scheduling_strategy::default_scheduling_strategy(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_default_scheduling_strategy(&mut self) -> DefaultSchedulingStrategy {
        if self.has_default_scheduling_strategy() {
            match self.scheduling_strategy.take() {
                ::std::option::Option::Some(SchedulingStrategy_oneof_scheduling_strategy::default_scheduling_strategy(v)) => v,
                _ => panic!(),
            }
        } else {
            DefaultSchedulingStrategy::new()
        }
    }

    // .ray.rpc.PlacementGroupSchedulingStrategy placement_group_scheduling_strategy = 2;


    pub fn get_placement_group_scheduling_strategy(&self) -> &PlacementGroupSchedulingStrategy {
        match self.scheduling_strategy {
            ::std::option::Option::Some(SchedulingStrategy_oneof_scheduling_strategy::placement_group_scheduling_strategy(ref v)) => v,
            _ => <PlacementGroupSchedulingStrategy as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_placement_group_scheduling_strategy(&mut self) {
        self.scheduling_strategy = ::std::option::Option::None;
    }

    pub fn has_placement_group_scheduling_strategy(&self) -> bool {
        match self.scheduling_strategy {
            ::std::option::Option::Some(SchedulingStrategy_oneof_scheduling_strategy::placement_group_scheduling_strategy(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_placement_group_scheduling_strategy(&mut self, v: PlacementGroupSchedulingStrategy) {
        self.scheduling_strategy = ::std::option::Option::Some(SchedulingStrategy_oneof_scheduling_strategy::placement_group_scheduling_strategy(v))
    }

    // Mutable pointer to the field.
    pub fn mut_placement_group_scheduling_strategy(&mut self) -> &mut PlacementGroupSchedulingStrategy {
        if let ::std::option::Option::Some(SchedulingStrategy_oneof_scheduling_strategy::placement_group_scheduling_strategy(_)) = self.scheduling_strategy {
        } else {
            self.scheduling_strategy = ::std::option::Option::Some(SchedulingStrategy_oneof_scheduling_strategy::placement_group_scheduling_strategy(PlacementGroupSchedulingStrategy::new()));
        }
        match self.scheduling_strategy {
            ::std::option::Option::Some(SchedulingStrategy_oneof_scheduling_strategy::placement_group_scheduling_strategy(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_placement_group_scheduling_strategy(&mut self) -> PlacementGroupSchedulingStrategy {
        if self.has_placement_group_scheduling_strategy() {
            match self.scheduling_strategy.take() {
                ::std::option::Option::Some(SchedulingStrategy_oneof_scheduling_strategy::placement_group_scheduling_strategy(v)) => v,
                _ => panic!(),
            }
        } else {
            PlacementGroupSchedulingStrategy::new()
        }
    }

    // .ray.rpc.SpreadSchedulingStrategy spread_scheduling_strategy = 3;


    pub fn get_spread_scheduling_strategy(&self) -> &SpreadSchedulingStrategy {
        match self.scheduling_strategy {
            ::std::option::Option::Some(SchedulingStrategy_oneof_scheduling_strategy::spread_scheduling_strategy(ref v)) => v,
            _ => <SpreadSchedulingStrategy as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_spread_scheduling_strategy(&mut self) {
        self.scheduling_strategy = ::std::option::Option::None;
    }

    pub fn has_spread_scheduling_strategy(&self) -> bool {
        match self.scheduling_strategy {
            ::std::option::Option::Some(SchedulingStrategy_oneof_scheduling_strategy::spread_scheduling_strategy(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_spread_scheduling_strategy(&mut self, v: SpreadSchedulingStrategy) {
        self.scheduling_strategy = ::std::option::Option::Some(SchedulingStrategy_oneof_scheduling_strategy::spread_scheduling_strategy(v))
    }

    // Mutable pointer to the field.
    pub fn mut_spread_scheduling_strategy(&mut self) -> &mut SpreadSchedulingStrategy {
        if let ::std::option::Option::Some(SchedulingStrategy_oneof_scheduling_strategy::spread_scheduling_strategy(_)) = self.scheduling_strategy {
        } else {
            self.scheduling_strategy = ::std::option::Option::Some(SchedulingStrategy_oneof_scheduling_strategy::spread_scheduling_strategy(SpreadSchedulingStrategy::new()));
        }
        match self.scheduling_strategy {
            ::std::option::Option::Some(SchedulingStrategy_oneof_scheduling_strategy::spread_scheduling_strategy(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_spread_scheduling_strategy(&mut self) -> SpreadSchedulingStrategy {
        if self.has_spread_scheduling_strategy() {
            match self.scheduling_strategy.take() {
                ::std::option::Option::Some(SchedulingStrategy_oneof_scheduling_strategy::spread_scheduling_strategy(v)) => v,
                _ => panic!(),
            }
        } else {
            SpreadSchedulingStrategy::new()
        }
    }
}

impl ::protobuf::Message for SchedulingStrategy {
    fn is_initialized(&self) -> bool {
        if let Some(SchedulingStrategy_oneof_scheduling_strategy::default_scheduling_strategy(ref v)) = self.scheduling_strategy {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(SchedulingStrategy_oneof_scheduling_strategy::placement_group_scheduling_strategy(ref v)) = self.scheduling_strategy {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(SchedulingStrategy_oneof_scheduling_strategy::spread_scheduling_strategy(ref v)) = self.scheduling_strategy {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.scheduling_strategy = ::std::option::Option::Some(SchedulingStrategy_oneof_scheduling_strategy::default_scheduling_strategy(is.read_message()?));
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.scheduling_strategy = ::std::option::Option::Some(SchedulingStrategy_oneof_scheduling_strategy::placement_group_scheduling_strategy(is.read_message()?));
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.scheduling_strategy = ::std::option::Option::Some(SchedulingStrategy_oneof_scheduling_strategy::spread_scheduling_strategy(is.read_message()?));
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let ::std::option::Option::Some(ref v) = self.scheduling_strategy {
            match v {
                &SchedulingStrategy_oneof_scheduling_strategy::default_scheduling_strategy(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &SchedulingStrategy_oneof_scheduling_strategy::placement_group_scheduling_strategy(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &SchedulingStrategy_oneof_scheduling_strategy::spread_scheduling_strategy(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let ::std::option::Option::Some(ref v) = self.scheduling_strategy {
            match v {
                &SchedulingStrategy_oneof_scheduling_strategy::default_scheduling_strategy(ref v) => {
                    os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &SchedulingStrategy_oneof_scheduling_strategy::placement_group_scheduling_strategy(ref v) => {
                    os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &SchedulingStrategy_oneof_scheduling_strategy::spread_scheduling_strategy(ref v) => {
                    os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SchedulingStrategy {
        SchedulingStrategy::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, DefaultSchedulingStrategy>(
                "default_scheduling_strategy",
                SchedulingStrategy::has_default_scheduling_strategy,
                SchedulingStrategy::get_default_scheduling_strategy,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, PlacementGroupSchedulingStrategy>(
                "placement_group_scheduling_strategy",
                SchedulingStrategy::has_placement_group_scheduling_strategy,
                SchedulingStrategy::get_placement_group_scheduling_strategy,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, SpreadSchedulingStrategy>(
                "spread_scheduling_strategy",
                SchedulingStrategy::has_spread_scheduling_strategy,
                SchedulingStrategy::get_spread_scheduling_strategy,
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<SchedulingStrategy>(
                "SchedulingStrategy",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static SchedulingStrategy {
        static instance: ::protobuf::rt::LazyV2<SchedulingStrategy> = ::protobuf::rt::LazyV2::INIT;
        instance.get(SchedulingStrategy::new)
    }
}

impl ::protobuf::Clear for SchedulingStrategy {
    fn clear(&mut self) {
        self.scheduling_strategy = ::std::option::Option::None;
        self.scheduling_strategy = ::std::option::Option::None;
        self.scheduling_strategy = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SchedulingStrategy {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SchedulingStrategy {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Address {
    // message fields
    pub raylet_id: ::std::vec::Vec<u8>,
    pub ip_address: ::std::string::String,
    pub port: i32,
    pub worker_id: ::std::vec::Vec<u8>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Address {
    fn default() -> &'a Address {
        <Address as ::protobuf::Message>::default_instance()
    }
}

impl Address {
    pub fn new() -> Address {
        ::std::default::Default::default()
    }

    // bytes raylet_id = 1;


    pub fn get_raylet_id(&self) -> &[u8] {
        &self.raylet_id
    }
    pub fn clear_raylet_id(&mut self) {
        self.raylet_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_raylet_id(&mut self, v: ::std::vec::Vec<u8>) {
        self.raylet_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_raylet_id(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.raylet_id
    }

    // Take field
    pub fn take_raylet_id(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.raylet_id, ::std::vec::Vec::new())
    }

    // string ip_address = 2;


    pub fn get_ip_address(&self) -> &str {
        &self.ip_address
    }
    pub fn clear_ip_address(&mut self) {
        self.ip_address.clear();
    }

    // Param is passed by value, moved
    pub fn set_ip_address(&mut self, v: ::std::string::String) {
        self.ip_address = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_ip_address(&mut self) -> &mut ::std::string::String {
        &mut self.ip_address
    }

    // Take field
    pub fn take_ip_address(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.ip_address, ::std::string::String::new())
    }

    // int32 port = 3;


    pub fn get_port(&self) -> i32 {
        self.port
    }
    pub fn clear_port(&mut self) {
        self.port = 0;
    }

    // Param is passed by value, moved
    pub fn set_port(&mut self, v: i32) {
        self.port = v;
    }

    // bytes worker_id = 4;


    pub fn get_worker_id(&self) -> &[u8] {
        &self.worker_id
    }
    pub fn clear_worker_id(&mut self) {
        self.worker_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_worker_id(&mut self, v: ::std::vec::Vec<u8>) {
        self.worker_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_worker_id(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.worker_id
    }

    // Take field
    pub fn take_worker_id(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.worker_id, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for Address {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.raylet_id)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.ip_address)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.port = tmp;
                },
                4 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.worker_id)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.raylet_id.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.raylet_id);
        }
        if !self.ip_address.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.ip_address);
        }
        if self.port != 0 {
            my_size += ::protobuf::rt::value_size(3, self.port, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.worker_id.is_empty() {
            my_size += ::protobuf::rt::bytes_size(4, &self.worker_id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.raylet_id.is_empty() {
            os.write_bytes(1, &self.raylet_id)?;
        }
        if !self.ip_address.is_empty() {
            os.write_string(2, &self.ip_address)?;
        }
        if self.port != 0 {
            os.write_int32(3, self.port)?;
        }
        if !self.worker_id.is_empty() {
            os.write_bytes(4, &self.worker_id)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Address {
        Address::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "raylet_id",
                |m: &Address| { &m.raylet_id },
                |m: &mut Address| { &mut m.raylet_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "ip_address",
                |m: &Address| { &m.ip_address },
                |m: &mut Address| { &mut m.ip_address },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "port",
                |m: &Address| { &m.port },
                |m: &mut Address| { &mut m.port },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "worker_id",
                |m: &Address| { &m.worker_id },
                |m: &mut Address| { &mut m.worker_id },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Address>(
                "Address",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Address {
        static instance: ::protobuf::rt::LazyV2<Address> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Address::new)
    }
}

impl ::protobuf::Clear for Address {
    fn clear(&mut self) {
        self.raylet_id.clear();
        self.ip_address.clear();
        self.port = 0;
        self.worker_id.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Address {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Address {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct JavaFunctionDescriptor {
    // message fields
    pub class_name: ::std::string::String,
    pub function_name: ::std::string::String,
    pub signature: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a JavaFunctionDescriptor {
    fn default() -> &'a JavaFunctionDescriptor {
        <JavaFunctionDescriptor as ::protobuf::Message>::default_instance()
    }
}

impl JavaFunctionDescriptor {
    pub fn new() -> JavaFunctionDescriptor {
        ::std::default::Default::default()
    }

    // string class_name = 1;


    pub fn get_class_name(&self) -> &str {
        &self.class_name
    }
    pub fn clear_class_name(&mut self) {
        self.class_name.clear();
    }

    // Param is passed by value, moved
    pub fn set_class_name(&mut self, v: ::std::string::String) {
        self.class_name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_class_name(&mut self) -> &mut ::std::string::String {
        &mut self.class_name
    }

    // Take field
    pub fn take_class_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.class_name, ::std::string::String::new())
    }

    // string function_name = 2;


    pub fn get_function_name(&self) -> &str {
        &self.function_name
    }
    pub fn clear_function_name(&mut self) {
        self.function_name.clear();
    }

    // Param is passed by value, moved
    pub fn set_function_name(&mut self, v: ::std::string::String) {
        self.function_name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_function_name(&mut self) -> &mut ::std::string::String {
        &mut self.function_name
    }

    // Take field
    pub fn take_function_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.function_name, ::std::string::String::new())
    }

    // string signature = 3;


    pub fn get_signature(&self) -> &str {
        &self.signature
    }
    pub fn clear_signature(&mut self) {
        self.signature.clear();
    }

    // Param is passed by value, moved
    pub fn set_signature(&mut self, v: ::std::string::String) {
        self.signature = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_signature(&mut self) -> &mut ::std::string::String {
        &mut self.signature
    }

    // Take field
    pub fn take_signature(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.signature, ::std::string::String::new())
    }
}

impl ::protobuf::Message for JavaFunctionDescriptor {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.class_name)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.function_name)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.signature)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.class_name.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.class_name);
        }
        if !self.function_name.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.function_name);
        }
        if !self.signature.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.signature);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.class_name.is_empty() {
            os.write_string(1, &self.class_name)?;
        }
        if !self.function_name.is_empty() {
            os.write_string(2, &self.function_name)?;
        }
        if !self.signature.is_empty() {
            os.write_string(3, &self.signature)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> JavaFunctionDescriptor {
        JavaFunctionDescriptor::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "class_name",
                |m: &JavaFunctionDescriptor| { &m.class_name },
                |m: &mut JavaFunctionDescriptor| { &mut m.class_name },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "function_name",
                |m: &JavaFunctionDescriptor| { &m.function_name },
                |m: &mut JavaFunctionDescriptor| { &mut m.function_name },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "signature",
                |m: &JavaFunctionDescriptor| { &m.signature },
                |m: &mut JavaFunctionDescriptor| { &mut m.signature },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<JavaFunctionDescriptor>(
                "JavaFunctionDescriptor",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static JavaFunctionDescriptor {
        static instance: ::protobuf::rt::LazyV2<JavaFunctionDescriptor> = ::protobuf::rt::LazyV2::INIT;
        instance.get(JavaFunctionDescriptor::new)
    }
}

impl ::protobuf::Clear for JavaFunctionDescriptor {
    fn clear(&mut self) {
        self.class_name.clear();
        self.function_name.clear();
        self.signature.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for JavaFunctionDescriptor {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for JavaFunctionDescriptor {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct PythonFunctionDescriptor {
    // message fields
    pub module_name: ::std::string::String,
    pub class_name: ::std::string::String,
    pub function_name: ::std::string::String,
    pub function_hash: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PythonFunctionDescriptor {
    fn default() -> &'a PythonFunctionDescriptor {
        <PythonFunctionDescriptor as ::protobuf::Message>::default_instance()
    }
}

impl PythonFunctionDescriptor {
    pub fn new() -> PythonFunctionDescriptor {
        ::std::default::Default::default()
    }

    // string module_name = 1;


    pub fn get_module_name(&self) -> &str {
        &self.module_name
    }
    pub fn clear_module_name(&mut self) {
        self.module_name.clear();
    }

    // Param is passed by value, moved
    pub fn set_module_name(&mut self, v: ::std::string::String) {
        self.module_name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_module_name(&mut self) -> &mut ::std::string::String {
        &mut self.module_name
    }

    // Take field
    pub fn take_module_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.module_name, ::std::string::String::new())
    }

    // string class_name = 2;


    pub fn get_class_name(&self) -> &str {
        &self.class_name
    }
    pub fn clear_class_name(&mut self) {
        self.class_name.clear();
    }

    // Param is passed by value, moved
    pub fn set_class_name(&mut self, v: ::std::string::String) {
        self.class_name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_class_name(&mut self) -> &mut ::std::string::String {
        &mut self.class_name
    }

    // Take field
    pub fn take_class_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.class_name, ::std::string::String::new())
    }

    // string function_name = 3;


    pub fn get_function_name(&self) -> &str {
        &self.function_name
    }
    pub fn clear_function_name(&mut self) {
        self.function_name.clear();
    }

    // Param is passed by value, moved
    pub fn set_function_name(&mut self, v: ::std::string::String) {
        self.function_name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_function_name(&mut self) -> &mut ::std::string::String {
        &mut self.function_name
    }

    // Take field
    pub fn take_function_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.function_name, ::std::string::String::new())
    }

    // string function_hash = 4;


    pub fn get_function_hash(&self) -> &str {
        &self.function_hash
    }
    pub fn clear_function_hash(&mut self) {
        self.function_hash.clear();
    }

    // Param is passed by value, moved
    pub fn set_function_hash(&mut self, v: ::std::string::String) {
        self.function_hash = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_function_hash(&mut self) -> &mut ::std::string::String {
        &mut self.function_hash
    }

    // Take field
    pub fn take_function_hash(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.function_hash, ::std::string::String::new())
    }
}

impl ::protobuf::Message for PythonFunctionDescriptor {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.module_name)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.class_name)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.function_name)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.function_hash)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.module_name.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.module_name);
        }
        if !self.class_name.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.class_name);
        }
        if !self.function_name.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.function_name);
        }
        if !self.function_hash.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.function_hash);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.module_name.is_empty() {
            os.write_string(1, &self.module_name)?;
        }
        if !self.class_name.is_empty() {
            os.write_string(2, &self.class_name)?;
        }
        if !self.function_name.is_empty() {
            os.write_string(3, &self.function_name)?;
        }
        if !self.function_hash.is_empty() {
            os.write_string(4, &self.function_hash)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PythonFunctionDescriptor {
        PythonFunctionDescriptor::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "module_name",
                |m: &PythonFunctionDescriptor| { &m.module_name },
                |m: &mut PythonFunctionDescriptor| { &mut m.module_name },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "class_name",
                |m: &PythonFunctionDescriptor| { &m.class_name },
                |m: &mut PythonFunctionDescriptor| { &mut m.class_name },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "function_name",
                |m: &PythonFunctionDescriptor| { &m.function_name },
                |m: &mut PythonFunctionDescriptor| { &mut m.function_name },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "function_hash",
                |m: &PythonFunctionDescriptor| { &m.function_hash },
                |m: &mut PythonFunctionDescriptor| { &mut m.function_hash },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<PythonFunctionDescriptor>(
                "PythonFunctionDescriptor",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static PythonFunctionDescriptor {
        static instance: ::protobuf::rt::LazyV2<PythonFunctionDescriptor> = ::protobuf::rt::LazyV2::INIT;
        instance.get(PythonFunctionDescriptor::new)
    }
}

impl ::protobuf::Clear for PythonFunctionDescriptor {
    fn clear(&mut self) {
        self.module_name.clear();
        self.class_name.clear();
        self.function_name.clear();
        self.function_hash.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PythonFunctionDescriptor {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PythonFunctionDescriptor {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CppFunctionDescriptor {
    // message fields
    pub function_name: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CppFunctionDescriptor {
    fn default() -> &'a CppFunctionDescriptor {
        <CppFunctionDescriptor as ::protobuf::Message>::default_instance()
    }
}

impl CppFunctionDescriptor {
    pub fn new() -> CppFunctionDescriptor {
        ::std::default::Default::default()
    }

    // string function_name = 1;


    pub fn get_function_name(&self) -> &str {
        &self.function_name
    }
    pub fn clear_function_name(&mut self) {
        self.function_name.clear();
    }

    // Param is passed by value, moved
    pub fn set_function_name(&mut self, v: ::std::string::String) {
        self.function_name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_function_name(&mut self) -> &mut ::std::string::String {
        &mut self.function_name
    }

    // Take field
    pub fn take_function_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.function_name, ::std::string::String::new())
    }
}

impl ::protobuf::Message for CppFunctionDescriptor {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.function_name)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.function_name.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.function_name);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.function_name.is_empty() {
            os.write_string(1, &self.function_name)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CppFunctionDescriptor {
        CppFunctionDescriptor::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "function_name",
                |m: &CppFunctionDescriptor| { &m.function_name },
                |m: &mut CppFunctionDescriptor| { &mut m.function_name },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CppFunctionDescriptor>(
                "CppFunctionDescriptor",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CppFunctionDescriptor {
        static instance: ::protobuf::rt::LazyV2<CppFunctionDescriptor> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CppFunctionDescriptor::new)
    }
}

impl ::protobuf::Clear for CppFunctionDescriptor {
    fn clear(&mut self) {
        self.function_name.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CppFunctionDescriptor {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CppFunctionDescriptor {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct RustFunctionDescriptor {
    // message fields
    pub function_name: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a RustFunctionDescriptor {
    fn default() -> &'a RustFunctionDescriptor {
        <RustFunctionDescriptor as ::protobuf::Message>::default_instance()
    }
}

impl RustFunctionDescriptor {
    pub fn new() -> RustFunctionDescriptor {
        ::std::default::Default::default()
    }

    // string function_name = 1;


    pub fn get_function_name(&self) -> &str {
        &self.function_name
    }
    pub fn clear_function_name(&mut self) {
        self.function_name.clear();
    }

    // Param is passed by value, moved
    pub fn set_function_name(&mut self, v: ::std::string::String) {
        self.function_name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_function_name(&mut self) -> &mut ::std::string::String {
        &mut self.function_name
    }

    // Take field
    pub fn take_function_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.function_name, ::std::string::String::new())
    }
}

impl ::protobuf::Message for RustFunctionDescriptor {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.function_name)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.function_name.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.function_name);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.function_name.is_empty() {
            os.write_string(1, &self.function_name)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> RustFunctionDescriptor {
        RustFunctionDescriptor::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "function_name",
                |m: &RustFunctionDescriptor| { &m.function_name },
                |m: &mut RustFunctionDescriptor| { &mut m.function_name },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<RustFunctionDescriptor>(
                "RustFunctionDescriptor",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static RustFunctionDescriptor {
        static instance: ::protobuf::rt::LazyV2<RustFunctionDescriptor> = ::protobuf::rt::LazyV2::INIT;
        instance.get(RustFunctionDescriptor::new)
    }
}

impl ::protobuf::Clear for RustFunctionDescriptor {
    fn clear(&mut self) {
        self.function_name.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RustFunctionDescriptor {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RustFunctionDescriptor {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct FunctionDescriptor {
    // message oneof groups
    pub function_descriptor: ::std::option::Option<FunctionDescriptor_oneof_function_descriptor>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a FunctionDescriptor {
    fn default() -> &'a FunctionDescriptor {
        <FunctionDescriptor as ::protobuf::Message>::default_instance()
    }
}

#[derive(Clone,PartialEq,Debug)]
pub enum FunctionDescriptor_oneof_function_descriptor {
    java_function_descriptor(JavaFunctionDescriptor),
    python_function_descriptor(PythonFunctionDescriptor),
    cpp_function_descriptor(CppFunctionDescriptor),
    rust_function_descriptor(RustFunctionDescriptor),
}

impl FunctionDescriptor {
    pub fn new() -> FunctionDescriptor {
        ::std::default::Default::default()
    }

    // .ray.rpc.JavaFunctionDescriptor java_function_descriptor = 1;


    pub fn get_java_function_descriptor(&self) -> &JavaFunctionDescriptor {
        match self.function_descriptor {
            ::std::option::Option::Some(FunctionDescriptor_oneof_function_descriptor::java_function_descriptor(ref v)) => v,
            _ => <JavaFunctionDescriptor as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_java_function_descriptor(&mut self) {
        self.function_descriptor = ::std::option::Option::None;
    }

    pub fn has_java_function_descriptor(&self) -> bool {
        match self.function_descriptor {
            ::std::option::Option::Some(FunctionDescriptor_oneof_function_descriptor::java_function_descriptor(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_java_function_descriptor(&mut self, v: JavaFunctionDescriptor) {
        self.function_descriptor = ::std::option::Option::Some(FunctionDescriptor_oneof_function_descriptor::java_function_descriptor(v))
    }

    // Mutable pointer to the field.
    pub fn mut_java_function_descriptor(&mut self) -> &mut JavaFunctionDescriptor {
        if let ::std::option::Option::Some(FunctionDescriptor_oneof_function_descriptor::java_function_descriptor(_)) = self.function_descriptor {
        } else {
            self.function_descriptor = ::std::option::Option::Some(FunctionDescriptor_oneof_function_descriptor::java_function_descriptor(JavaFunctionDescriptor::new()));
        }
        match self.function_descriptor {
            ::std::option::Option::Some(FunctionDescriptor_oneof_function_descriptor::java_function_descriptor(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_java_function_descriptor(&mut self) -> JavaFunctionDescriptor {
        if self.has_java_function_descriptor() {
            match self.function_descriptor.take() {
                ::std::option::Option::Some(FunctionDescriptor_oneof_function_descriptor::java_function_descriptor(v)) => v,
                _ => panic!(),
            }
        } else {
            JavaFunctionDescriptor::new()
        }
    }

    // .ray.rpc.PythonFunctionDescriptor python_function_descriptor = 2;


    pub fn get_python_function_descriptor(&self) -> &PythonFunctionDescriptor {
        match self.function_descriptor {
            ::std::option::Option::Some(FunctionDescriptor_oneof_function_descriptor::python_function_descriptor(ref v)) => v,
            _ => <PythonFunctionDescriptor as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_python_function_descriptor(&mut self) {
        self.function_descriptor = ::std::option::Option::None;
    }

    pub fn has_python_function_descriptor(&self) -> bool {
        match self.function_descriptor {
            ::std::option::Option::Some(FunctionDescriptor_oneof_function_descriptor::python_function_descriptor(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_python_function_descriptor(&mut self, v: PythonFunctionDescriptor) {
        self.function_descriptor = ::std::option::Option::Some(FunctionDescriptor_oneof_function_descriptor::python_function_descriptor(v))
    }

    // Mutable pointer to the field.
    pub fn mut_python_function_descriptor(&mut self) -> &mut PythonFunctionDescriptor {
        if let ::std::option::Option::Some(FunctionDescriptor_oneof_function_descriptor::python_function_descriptor(_)) = self.function_descriptor {
        } else {
            self.function_descriptor = ::std::option::Option::Some(FunctionDescriptor_oneof_function_descriptor::python_function_descriptor(PythonFunctionDescriptor::new()));
        }
        match self.function_descriptor {
            ::std::option::Option::Some(FunctionDescriptor_oneof_function_descriptor::python_function_descriptor(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_python_function_descriptor(&mut self) -> PythonFunctionDescriptor {
        if self.has_python_function_descriptor() {
            match self.function_descriptor.take() {
                ::std::option::Option::Some(FunctionDescriptor_oneof_function_descriptor::python_function_descriptor(v)) => v,
                _ => panic!(),
            }
        } else {
            PythonFunctionDescriptor::new()
        }
    }

    // .ray.rpc.CppFunctionDescriptor cpp_function_descriptor = 3;


    pub fn get_cpp_function_descriptor(&self) -> &CppFunctionDescriptor {
        match self.function_descriptor {
            ::std::option::Option::Some(FunctionDescriptor_oneof_function_descriptor::cpp_function_descriptor(ref v)) => v,
            _ => <CppFunctionDescriptor as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_cpp_function_descriptor(&mut self) {
        self.function_descriptor = ::std::option::Option::None;
    }

    pub fn has_cpp_function_descriptor(&self) -> bool {
        match self.function_descriptor {
            ::std::option::Option::Some(FunctionDescriptor_oneof_function_descriptor::cpp_function_descriptor(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_cpp_function_descriptor(&mut self, v: CppFunctionDescriptor) {
        self.function_descriptor = ::std::option::Option::Some(FunctionDescriptor_oneof_function_descriptor::cpp_function_descriptor(v))
    }

    // Mutable pointer to the field.
    pub fn mut_cpp_function_descriptor(&mut self) -> &mut CppFunctionDescriptor {
        if let ::std::option::Option::Some(FunctionDescriptor_oneof_function_descriptor::cpp_function_descriptor(_)) = self.function_descriptor {
        } else {
            self.function_descriptor = ::std::option::Option::Some(FunctionDescriptor_oneof_function_descriptor::cpp_function_descriptor(CppFunctionDescriptor::new()));
        }
        match self.function_descriptor {
            ::std::option::Option::Some(FunctionDescriptor_oneof_function_descriptor::cpp_function_descriptor(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_cpp_function_descriptor(&mut self) -> CppFunctionDescriptor {
        if self.has_cpp_function_descriptor() {
            match self.function_descriptor.take() {
                ::std::option::Option::Some(FunctionDescriptor_oneof_function_descriptor::cpp_function_descriptor(v)) => v,
                _ => panic!(),
            }
        } else {
            CppFunctionDescriptor::new()
        }
    }

    // .ray.rpc.RustFunctionDescriptor rust_function_descriptor = 4;


    pub fn get_rust_function_descriptor(&self) -> &RustFunctionDescriptor {
        match self.function_descriptor {
            ::std::option::Option::Some(FunctionDescriptor_oneof_function_descriptor::rust_function_descriptor(ref v)) => v,
            _ => <RustFunctionDescriptor as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_rust_function_descriptor(&mut self) {
        self.function_descriptor = ::std::option::Option::None;
    }

    pub fn has_rust_function_descriptor(&self) -> bool {
        match self.function_descriptor {
            ::std::option::Option::Some(FunctionDescriptor_oneof_function_descriptor::rust_function_descriptor(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_rust_function_descriptor(&mut self, v: RustFunctionDescriptor) {
        self.function_descriptor = ::std::option::Option::Some(FunctionDescriptor_oneof_function_descriptor::rust_function_descriptor(v))
    }

    // Mutable pointer to the field.
    pub fn mut_rust_function_descriptor(&mut self) -> &mut RustFunctionDescriptor {
        if let ::std::option::Option::Some(FunctionDescriptor_oneof_function_descriptor::rust_function_descriptor(_)) = self.function_descriptor {
        } else {
            self.function_descriptor = ::std::option::Option::Some(FunctionDescriptor_oneof_function_descriptor::rust_function_descriptor(RustFunctionDescriptor::new()));
        }
        match self.function_descriptor {
            ::std::option::Option::Some(FunctionDescriptor_oneof_function_descriptor::rust_function_descriptor(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_rust_function_descriptor(&mut self) -> RustFunctionDescriptor {
        if self.has_rust_function_descriptor() {
            match self.function_descriptor.take() {
                ::std::option::Option::Some(FunctionDescriptor_oneof_function_descriptor::rust_function_descriptor(v)) => v,
                _ => panic!(),
            }
        } else {
            RustFunctionDescriptor::new()
        }
    }
}

impl ::protobuf::Message for FunctionDescriptor {
    fn is_initialized(&self) -> bool {
        if let Some(FunctionDescriptor_oneof_function_descriptor::java_function_descriptor(ref v)) = self.function_descriptor {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(FunctionDescriptor_oneof_function_descriptor::python_function_descriptor(ref v)) = self.function_descriptor {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(FunctionDescriptor_oneof_function_descriptor::cpp_function_descriptor(ref v)) = self.function_descriptor {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(FunctionDescriptor_oneof_function_descriptor::rust_function_descriptor(ref v)) = self.function_descriptor {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.function_descriptor = ::std::option::Option::Some(FunctionDescriptor_oneof_function_descriptor::java_function_descriptor(is.read_message()?));
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.function_descriptor = ::std::option::Option::Some(FunctionDescriptor_oneof_function_descriptor::python_function_descriptor(is.read_message()?));
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.function_descriptor = ::std::option::Option::Some(FunctionDescriptor_oneof_function_descriptor::cpp_function_descriptor(is.read_message()?));
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.function_descriptor = ::std::option::Option::Some(FunctionDescriptor_oneof_function_descriptor::rust_function_descriptor(is.read_message()?));
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let ::std::option::Option::Some(ref v) = self.function_descriptor {
            match v {
                &FunctionDescriptor_oneof_function_descriptor::java_function_descriptor(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &FunctionDescriptor_oneof_function_descriptor::python_function_descriptor(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &FunctionDescriptor_oneof_function_descriptor::cpp_function_descriptor(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &FunctionDescriptor_oneof_function_descriptor::rust_function_descriptor(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let ::std::option::Option::Some(ref v) = self.function_descriptor {
            match v {
                &FunctionDescriptor_oneof_function_descriptor::java_function_descriptor(ref v) => {
                    os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &FunctionDescriptor_oneof_function_descriptor::python_function_descriptor(ref v) => {
                    os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &FunctionDescriptor_oneof_function_descriptor::cpp_function_descriptor(ref v) => {
                    os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &FunctionDescriptor_oneof_function_descriptor::rust_function_descriptor(ref v) => {
                    os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> FunctionDescriptor {
        FunctionDescriptor::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, JavaFunctionDescriptor>(
                "java_function_descriptor",
                FunctionDescriptor::has_java_function_descriptor,
                FunctionDescriptor::get_java_function_descriptor,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, PythonFunctionDescriptor>(
                "python_function_descriptor",
                FunctionDescriptor::has_python_function_descriptor,
                FunctionDescriptor::get_python_function_descriptor,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, CppFunctionDescriptor>(
                "cpp_function_descriptor",
                FunctionDescriptor::has_cpp_function_descriptor,
                FunctionDescriptor::get_cpp_function_descriptor,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, RustFunctionDescriptor>(
                "rust_function_descriptor",
                FunctionDescriptor::has_rust_function_descriptor,
                FunctionDescriptor::get_rust_function_descriptor,
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<FunctionDescriptor>(
                "FunctionDescriptor",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static FunctionDescriptor {
        static instance: ::protobuf::rt::LazyV2<FunctionDescriptor> = ::protobuf::rt::LazyV2::INIT;
        instance.get(FunctionDescriptor::new)
    }
}

impl ::protobuf::Clear for FunctionDescriptor {
    fn clear(&mut self) {
        self.function_descriptor = ::std::option::Option::None;
        self.function_descriptor = ::std::option::Option::None;
        self.function_descriptor = ::std::option::Option::None;
        self.function_descriptor = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for FunctionDescriptor {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for FunctionDescriptor {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ConcurrencyGroup {
    // message fields
    pub name: ::std::string::String,
    pub max_concurrency: i32,
    pub function_descriptors: ::protobuf::RepeatedField<FunctionDescriptor>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ConcurrencyGroup {
    fn default() -> &'a ConcurrencyGroup {
        <ConcurrencyGroup as ::protobuf::Message>::default_instance()
    }
}

impl ConcurrencyGroup {
    pub fn new() -> ConcurrencyGroup {
        ::std::default::Default::default()
    }

    // string name = 1;


    pub fn get_name(&self) -> &str {
        &self.name
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        &mut self.name
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.name, ::std::string::String::new())
    }

    // int32 max_concurrency = 2;


    pub fn get_max_concurrency(&self) -> i32 {
        self.max_concurrency
    }
    pub fn clear_max_concurrency(&mut self) {
        self.max_concurrency = 0;
    }

    // Param is passed by value, moved
    pub fn set_max_concurrency(&mut self, v: i32) {
        self.max_concurrency = v;
    }

    // repeated .ray.rpc.FunctionDescriptor function_descriptors = 3;


    pub fn get_function_descriptors(&self) -> &[FunctionDescriptor] {
        &self.function_descriptors
    }
    pub fn clear_function_descriptors(&mut self) {
        self.function_descriptors.clear();
    }

    // Param is passed by value, moved
    pub fn set_function_descriptors(&mut self, v: ::protobuf::RepeatedField<FunctionDescriptor>) {
        self.function_descriptors = v;
    }

    // Mutable pointer to the field.
    pub fn mut_function_descriptors(&mut self) -> &mut ::protobuf::RepeatedField<FunctionDescriptor> {
        &mut self.function_descriptors
    }

    // Take field
    pub fn take_function_descriptors(&mut self) -> ::protobuf::RepeatedField<FunctionDescriptor> {
        ::std::mem::replace(&mut self.function_descriptors, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for ConcurrencyGroup {
    fn is_initialized(&self) -> bool {
        for v in &self.function_descriptors {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.name)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.max_concurrency = tmp;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.function_descriptors)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.name);
        }
        if self.max_concurrency != 0 {
            my_size += ::protobuf::rt::value_size(2, self.max_concurrency, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.function_descriptors {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.name.is_empty() {
            os.write_string(1, &self.name)?;
        }
        if self.max_concurrency != 0 {
            os.write_int32(2, self.max_concurrency)?;
        }
        for v in &self.function_descriptors {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ConcurrencyGroup {
        ConcurrencyGroup::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "name",
                |m: &ConcurrencyGroup| { &m.name },
                |m: &mut ConcurrencyGroup| { &mut m.name },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "max_concurrency",
                |m: &ConcurrencyGroup| { &m.max_concurrency },
                |m: &mut ConcurrencyGroup| { &mut m.max_concurrency },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<FunctionDescriptor>>(
                "function_descriptors",
                |m: &ConcurrencyGroup| { &m.function_descriptors },
                |m: &mut ConcurrencyGroup| { &mut m.function_descriptors },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ConcurrencyGroup>(
                "ConcurrencyGroup",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ConcurrencyGroup {
        static instance: ::protobuf::rt::LazyV2<ConcurrencyGroup> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ConcurrencyGroup::new)
    }
}

impl ::protobuf::Clear for ConcurrencyGroup {
    fn clear(&mut self) {
        self.name.clear();
        self.max_concurrency = 0;
        self.function_descriptors.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ConcurrencyGroup {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ConcurrencyGroup {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct RayErrorInfo {
    // message oneof groups
    pub error: ::std::option::Option<RayErrorInfo_oneof_error>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a RayErrorInfo {
    fn default() -> &'a RayErrorInfo {
        <RayErrorInfo as ::protobuf::Message>::default_instance()
    }
}

#[derive(Clone,PartialEq,Debug)]
pub enum RayErrorInfo_oneof_error {
    actor_died_error(ActorDeathCause),
    runtime_env_setup_failed_error(RuntimeEnvFailedContext),
}

impl RayErrorInfo {
    pub fn new() -> RayErrorInfo {
        ::std::default::Default::default()
    }

    // .ray.rpc.ActorDeathCause actor_died_error = 2;


    pub fn get_actor_died_error(&self) -> &ActorDeathCause {
        match self.error {
            ::std::option::Option::Some(RayErrorInfo_oneof_error::actor_died_error(ref v)) => v,
            _ => <ActorDeathCause as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_actor_died_error(&mut self) {
        self.error = ::std::option::Option::None;
    }

    pub fn has_actor_died_error(&self) -> bool {
        match self.error {
            ::std::option::Option::Some(RayErrorInfo_oneof_error::actor_died_error(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_actor_died_error(&mut self, v: ActorDeathCause) {
        self.error = ::std::option::Option::Some(RayErrorInfo_oneof_error::actor_died_error(v))
    }

    // Mutable pointer to the field.
    pub fn mut_actor_died_error(&mut self) -> &mut ActorDeathCause {
        if let ::std::option::Option::Some(RayErrorInfo_oneof_error::actor_died_error(_)) = self.error {
        } else {
            self.error = ::std::option::Option::Some(RayErrorInfo_oneof_error::actor_died_error(ActorDeathCause::new()));
        }
        match self.error {
            ::std::option::Option::Some(RayErrorInfo_oneof_error::actor_died_error(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_actor_died_error(&mut self) -> ActorDeathCause {
        if self.has_actor_died_error() {
            match self.error.take() {
                ::std::option::Option::Some(RayErrorInfo_oneof_error::actor_died_error(v)) => v,
                _ => panic!(),
            }
        } else {
            ActorDeathCause::new()
        }
    }

    // .ray.rpc.RuntimeEnvFailedContext runtime_env_setup_failed_error = 3;


    pub fn get_runtime_env_setup_failed_error(&self) -> &RuntimeEnvFailedContext {
        match self.error {
            ::std::option::Option::Some(RayErrorInfo_oneof_error::runtime_env_setup_failed_error(ref v)) => v,
            _ => <RuntimeEnvFailedContext as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_runtime_env_setup_failed_error(&mut self) {
        self.error = ::std::option::Option::None;
    }

    pub fn has_runtime_env_setup_failed_error(&self) -> bool {
        match self.error {
            ::std::option::Option::Some(RayErrorInfo_oneof_error::runtime_env_setup_failed_error(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_runtime_env_setup_failed_error(&mut self, v: RuntimeEnvFailedContext) {
        self.error = ::std::option::Option::Some(RayErrorInfo_oneof_error::runtime_env_setup_failed_error(v))
    }

    // Mutable pointer to the field.
    pub fn mut_runtime_env_setup_failed_error(&mut self) -> &mut RuntimeEnvFailedContext {
        if let ::std::option::Option::Some(RayErrorInfo_oneof_error::runtime_env_setup_failed_error(_)) = self.error {
        } else {
            self.error = ::std::option::Option::Some(RayErrorInfo_oneof_error::runtime_env_setup_failed_error(RuntimeEnvFailedContext::new()));
        }
        match self.error {
            ::std::option::Option::Some(RayErrorInfo_oneof_error::runtime_env_setup_failed_error(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_runtime_env_setup_failed_error(&mut self) -> RuntimeEnvFailedContext {
        if self.has_runtime_env_setup_failed_error() {
            match self.error.take() {
                ::std::option::Option::Some(RayErrorInfo_oneof_error::runtime_env_setup_failed_error(v)) => v,
                _ => panic!(),
            }
        } else {
            RuntimeEnvFailedContext::new()
        }
    }
}

impl ::protobuf::Message for RayErrorInfo {
    fn is_initialized(&self) -> bool {
        if let Some(RayErrorInfo_oneof_error::actor_died_error(ref v)) = self.error {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(RayErrorInfo_oneof_error::runtime_env_setup_failed_error(ref v)) = self.error {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.error = ::std::option::Option::Some(RayErrorInfo_oneof_error::actor_died_error(is.read_message()?));
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.error = ::std::option::Option::Some(RayErrorInfo_oneof_error::runtime_env_setup_failed_error(is.read_message()?));
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let ::std::option::Option::Some(ref v) = self.error {
            match v {
                &RayErrorInfo_oneof_error::actor_died_error(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &RayErrorInfo_oneof_error::runtime_env_setup_failed_error(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let ::std::option::Option::Some(ref v) = self.error {
            match v {
                &RayErrorInfo_oneof_error::actor_died_error(ref v) => {
                    os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &RayErrorInfo_oneof_error::runtime_env_setup_failed_error(ref v) => {
                    os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> RayErrorInfo {
        RayErrorInfo::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, ActorDeathCause>(
                "actor_died_error",
                RayErrorInfo::has_actor_died_error,
                RayErrorInfo::get_actor_died_error,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, RuntimeEnvFailedContext>(
                "runtime_env_setup_failed_error",
                RayErrorInfo::has_runtime_env_setup_failed_error,
                RayErrorInfo::get_runtime_env_setup_failed_error,
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<RayErrorInfo>(
                "RayErrorInfo",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static RayErrorInfo {
        static instance: ::protobuf::rt::LazyV2<RayErrorInfo> = ::protobuf::rt::LazyV2::INIT;
        instance.get(RayErrorInfo::new)
    }
}

impl ::protobuf::Clear for RayErrorInfo {
    fn clear(&mut self) {
        self.error = ::std::option::Option::None;
        self.error = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RayErrorInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RayErrorInfo {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct RayException {
    // message fields
    pub language: Language,
    pub serialized_exception: ::std::vec::Vec<u8>,
    pub formatted_exception_string: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a RayException {
    fn default() -> &'a RayException {
        <RayException as ::protobuf::Message>::default_instance()
    }
}

impl RayException {
    pub fn new() -> RayException {
        ::std::default::Default::default()
    }

    // .ray.rpc.Language language = 1;


    pub fn get_language(&self) -> Language {
        self.language
    }
    pub fn clear_language(&mut self) {
        self.language = Language::PYTHON;
    }

    // Param is passed by value, moved
    pub fn set_language(&mut self, v: Language) {
        self.language = v;
    }

    // bytes serialized_exception = 2;


    pub fn get_serialized_exception(&self) -> &[u8] {
        &self.serialized_exception
    }
    pub fn clear_serialized_exception(&mut self) {
        self.serialized_exception.clear();
    }

    // Param is passed by value, moved
    pub fn set_serialized_exception(&mut self, v: ::std::vec::Vec<u8>) {
        self.serialized_exception = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_serialized_exception(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.serialized_exception
    }

    // Take field
    pub fn take_serialized_exception(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.serialized_exception, ::std::vec::Vec::new())
    }

    // string formatted_exception_string = 3;


    pub fn get_formatted_exception_string(&self) -> &str {
        &self.formatted_exception_string
    }
    pub fn clear_formatted_exception_string(&mut self) {
        self.formatted_exception_string.clear();
    }

    // Param is passed by value, moved
    pub fn set_formatted_exception_string(&mut self, v: ::std::string::String) {
        self.formatted_exception_string = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_formatted_exception_string(&mut self) -> &mut ::std::string::String {
        &mut self.formatted_exception_string
    }

    // Take field
    pub fn take_formatted_exception_string(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.formatted_exception_string, ::std::string::String::new())
    }
}

impl ::protobuf::Message for RayException {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.language, 1, &mut self.unknown_fields)?
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.serialized_exception)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.formatted_exception_string)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.language != Language::PYTHON {
            my_size += ::protobuf::rt::enum_size(1, self.language);
        }
        if !self.serialized_exception.is_empty() {
            my_size += ::protobuf::rt::bytes_size(2, &self.serialized_exception);
        }
        if !self.formatted_exception_string.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.formatted_exception_string);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.language != Language::PYTHON {
            os.write_enum(1, ::protobuf::ProtobufEnum::value(&self.language))?;
        }
        if !self.serialized_exception.is_empty() {
            os.write_bytes(2, &self.serialized_exception)?;
        }
        if !self.formatted_exception_string.is_empty() {
            os.write_string(3, &self.formatted_exception_string)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> RayException {
        RayException::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<Language>>(
                "language",
                |m: &RayException| { &m.language },
                |m: &mut RayException| { &mut m.language },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "serialized_exception",
                |m: &RayException| { &m.serialized_exception },
                |m: &mut RayException| { &mut m.serialized_exception },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "formatted_exception_string",
                |m: &RayException| { &m.formatted_exception_string },
                |m: &mut RayException| { &mut m.formatted_exception_string },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<RayException>(
                "RayException",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static RayException {
        static instance: ::protobuf::rt::LazyV2<RayException> = ::protobuf::rt::LazyV2::INIT;
        instance.get(RayException::new)
    }
}

impl ::protobuf::Clear for RayException {
    fn clear(&mut self) {
        self.language = Language::PYTHON;
        self.serialized_exception.clear();
        self.formatted_exception_string.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RayException {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RayException {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ActorDeathCause {
    // message oneof groups
    pub context: ::std::option::Option<ActorDeathCause_oneof_context>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ActorDeathCause {
    fn default() -> &'a ActorDeathCause {
        <ActorDeathCause as ::protobuf::Message>::default_instance()
    }
}

#[derive(Clone,PartialEq,Debug)]
pub enum ActorDeathCause_oneof_context {
    creation_task_failure_context(RayException),
    runtime_env_failed_context(RuntimeEnvFailedContext),
    actor_died_error_context(ActorDiedErrorContext),
}

impl ActorDeathCause {
    pub fn new() -> ActorDeathCause {
        ::std::default::Default::default()
    }

    // .ray.rpc.RayException creation_task_failure_context = 1;


    pub fn get_creation_task_failure_context(&self) -> &RayException {
        match self.context {
            ::std::option::Option::Some(ActorDeathCause_oneof_context::creation_task_failure_context(ref v)) => v,
            _ => <RayException as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_creation_task_failure_context(&mut self) {
        self.context = ::std::option::Option::None;
    }

    pub fn has_creation_task_failure_context(&self) -> bool {
        match self.context {
            ::std::option::Option::Some(ActorDeathCause_oneof_context::creation_task_failure_context(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_creation_task_failure_context(&mut self, v: RayException) {
        self.context = ::std::option::Option::Some(ActorDeathCause_oneof_context::creation_task_failure_context(v))
    }

    // Mutable pointer to the field.
    pub fn mut_creation_task_failure_context(&mut self) -> &mut RayException {
        if let ::std::option::Option::Some(ActorDeathCause_oneof_context::creation_task_failure_context(_)) = self.context {
        } else {
            self.context = ::std::option::Option::Some(ActorDeathCause_oneof_context::creation_task_failure_context(RayException::new()));
        }
        match self.context {
            ::std::option::Option::Some(ActorDeathCause_oneof_context::creation_task_failure_context(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_creation_task_failure_context(&mut self) -> RayException {
        if self.has_creation_task_failure_context() {
            match self.context.take() {
                ::std::option::Option::Some(ActorDeathCause_oneof_context::creation_task_failure_context(v)) => v,
                _ => panic!(),
            }
        } else {
            RayException::new()
        }
    }

    // .ray.rpc.RuntimeEnvFailedContext runtime_env_failed_context = 2;


    pub fn get_runtime_env_failed_context(&self) -> &RuntimeEnvFailedContext {
        match self.context {
            ::std::option::Option::Some(ActorDeathCause_oneof_context::runtime_env_failed_context(ref v)) => v,
            _ => <RuntimeEnvFailedContext as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_runtime_env_failed_context(&mut self) {
        self.context = ::std::option::Option::None;
    }

    pub fn has_runtime_env_failed_context(&self) -> bool {
        match self.context {
            ::std::option::Option::Some(ActorDeathCause_oneof_context::runtime_env_failed_context(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_runtime_env_failed_context(&mut self, v: RuntimeEnvFailedContext) {
        self.context = ::std::option::Option::Some(ActorDeathCause_oneof_context::runtime_env_failed_context(v))
    }

    // Mutable pointer to the field.
    pub fn mut_runtime_env_failed_context(&mut self) -> &mut RuntimeEnvFailedContext {
        if let ::std::option::Option::Some(ActorDeathCause_oneof_context::runtime_env_failed_context(_)) = self.context {
        } else {
            self.context = ::std::option::Option::Some(ActorDeathCause_oneof_context::runtime_env_failed_context(RuntimeEnvFailedContext::new()));
        }
        match self.context {
            ::std::option::Option::Some(ActorDeathCause_oneof_context::runtime_env_failed_context(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_runtime_env_failed_context(&mut self) -> RuntimeEnvFailedContext {
        if self.has_runtime_env_failed_context() {
            match self.context.take() {
                ::std::option::Option::Some(ActorDeathCause_oneof_context::runtime_env_failed_context(v)) => v,
                _ => panic!(),
            }
        } else {
            RuntimeEnvFailedContext::new()
        }
    }

    // .ray.rpc.ActorDiedErrorContext actor_died_error_context = 3;


    pub fn get_actor_died_error_context(&self) -> &ActorDiedErrorContext {
        match self.context {
            ::std::option::Option::Some(ActorDeathCause_oneof_context::actor_died_error_context(ref v)) => v,
            _ => <ActorDiedErrorContext as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_actor_died_error_context(&mut self) {
        self.context = ::std::option::Option::None;
    }

    pub fn has_actor_died_error_context(&self) -> bool {
        match self.context {
            ::std::option::Option::Some(ActorDeathCause_oneof_context::actor_died_error_context(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_actor_died_error_context(&mut self, v: ActorDiedErrorContext) {
        self.context = ::std::option::Option::Some(ActorDeathCause_oneof_context::actor_died_error_context(v))
    }

    // Mutable pointer to the field.
    pub fn mut_actor_died_error_context(&mut self) -> &mut ActorDiedErrorContext {
        if let ::std::option::Option::Some(ActorDeathCause_oneof_context::actor_died_error_context(_)) = self.context {
        } else {
            self.context = ::std::option::Option::Some(ActorDeathCause_oneof_context::actor_died_error_context(ActorDiedErrorContext::new()));
        }
        match self.context {
            ::std::option::Option::Some(ActorDeathCause_oneof_context::actor_died_error_context(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_actor_died_error_context(&mut self) -> ActorDiedErrorContext {
        if self.has_actor_died_error_context() {
            match self.context.take() {
                ::std::option::Option::Some(ActorDeathCause_oneof_context::actor_died_error_context(v)) => v,
                _ => panic!(),
            }
        } else {
            ActorDiedErrorContext::new()
        }
    }
}

impl ::protobuf::Message for ActorDeathCause {
    fn is_initialized(&self) -> bool {
        if let Some(ActorDeathCause_oneof_context::creation_task_failure_context(ref v)) = self.context {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(ActorDeathCause_oneof_context::runtime_env_failed_context(ref v)) = self.context {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(ActorDeathCause_oneof_context::actor_died_error_context(ref v)) = self.context {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.context = ::std::option::Option::Some(ActorDeathCause_oneof_context::creation_task_failure_context(is.read_message()?));
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.context = ::std::option::Option::Some(ActorDeathCause_oneof_context::runtime_env_failed_context(is.read_message()?));
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.context = ::std::option::Option::Some(ActorDeathCause_oneof_context::actor_died_error_context(is.read_message()?));
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let ::std::option::Option::Some(ref v) = self.context {
            match v {
                &ActorDeathCause_oneof_context::creation_task_failure_context(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &ActorDeathCause_oneof_context::runtime_env_failed_context(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &ActorDeathCause_oneof_context::actor_died_error_context(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let ::std::option::Option::Some(ref v) = self.context {
            match v {
                &ActorDeathCause_oneof_context::creation_task_failure_context(ref v) => {
                    os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &ActorDeathCause_oneof_context::runtime_env_failed_context(ref v) => {
                    os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &ActorDeathCause_oneof_context::actor_died_error_context(ref v) => {
                    os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ActorDeathCause {
        ActorDeathCause::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, RayException>(
                "creation_task_failure_context",
                ActorDeathCause::has_creation_task_failure_context,
                ActorDeathCause::get_creation_task_failure_context,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, RuntimeEnvFailedContext>(
                "runtime_env_failed_context",
                ActorDeathCause::has_runtime_env_failed_context,
                ActorDeathCause::get_runtime_env_failed_context,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, ActorDiedErrorContext>(
                "actor_died_error_context",
                ActorDeathCause::has_actor_died_error_context,
                ActorDeathCause::get_actor_died_error_context,
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ActorDeathCause>(
                "ActorDeathCause",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ActorDeathCause {
        static instance: ::protobuf::rt::LazyV2<ActorDeathCause> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ActorDeathCause::new)
    }
}

impl ::protobuf::Clear for ActorDeathCause {
    fn clear(&mut self) {
        self.context = ::std::option::Option::None;
        self.context = ::std::option::Option::None;
        self.context = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ActorDeathCause {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ActorDeathCause {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct RuntimeEnvFailedContext {
    // message fields
    pub error_message: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a RuntimeEnvFailedContext {
    fn default() -> &'a RuntimeEnvFailedContext {
        <RuntimeEnvFailedContext as ::protobuf::Message>::default_instance()
    }
}

impl RuntimeEnvFailedContext {
    pub fn new() -> RuntimeEnvFailedContext {
        ::std::default::Default::default()
    }

    // string error_message = 1;


    pub fn get_error_message(&self) -> &str {
        &self.error_message
    }
    pub fn clear_error_message(&mut self) {
        self.error_message.clear();
    }

    // Param is passed by value, moved
    pub fn set_error_message(&mut self, v: ::std::string::String) {
        self.error_message = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_error_message(&mut self) -> &mut ::std::string::String {
        &mut self.error_message
    }

    // Take field
    pub fn take_error_message(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.error_message, ::std::string::String::new())
    }
}

impl ::protobuf::Message for RuntimeEnvFailedContext {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.error_message)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.error_message.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.error_message);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.error_message.is_empty() {
            os.write_string(1, &self.error_message)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> RuntimeEnvFailedContext {
        RuntimeEnvFailedContext::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "error_message",
                |m: &RuntimeEnvFailedContext| { &m.error_message },
                |m: &mut RuntimeEnvFailedContext| { &mut m.error_message },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<RuntimeEnvFailedContext>(
                "RuntimeEnvFailedContext",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static RuntimeEnvFailedContext {
        static instance: ::protobuf::rt::LazyV2<RuntimeEnvFailedContext> = ::protobuf::rt::LazyV2::INIT;
        instance.get(RuntimeEnvFailedContext::new)
    }
}

impl ::protobuf::Clear for RuntimeEnvFailedContext {
    fn clear(&mut self) {
        self.error_message.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RuntimeEnvFailedContext {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RuntimeEnvFailedContext {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ActorDiedErrorContext {
    // message fields
    pub error_message: ::std::string::String,
    pub owner_id: ::std::vec::Vec<u8>,
    pub owner_ip_address: ::std::string::String,
    pub node_ip_address: ::std::string::String,
    pub pid: u32,
    pub name: ::std::string::String,
    pub ray_namespace: ::std::string::String,
    pub class_name: ::std::string::String,
    pub actor_id: ::std::vec::Vec<u8>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ActorDiedErrorContext {
    fn default() -> &'a ActorDiedErrorContext {
        <ActorDiedErrorContext as ::protobuf::Message>::default_instance()
    }
}

impl ActorDiedErrorContext {
    pub fn new() -> ActorDiedErrorContext {
        ::std::default::Default::default()
    }

    // string error_message = 1;


    pub fn get_error_message(&self) -> &str {
        &self.error_message
    }
    pub fn clear_error_message(&mut self) {
        self.error_message.clear();
    }

    // Param is passed by value, moved
    pub fn set_error_message(&mut self, v: ::std::string::String) {
        self.error_message = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_error_message(&mut self) -> &mut ::std::string::String {
        &mut self.error_message
    }

    // Take field
    pub fn take_error_message(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.error_message, ::std::string::String::new())
    }

    // bytes owner_id = 2;


    pub fn get_owner_id(&self) -> &[u8] {
        &self.owner_id
    }
    pub fn clear_owner_id(&mut self) {
        self.owner_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_owner_id(&mut self, v: ::std::vec::Vec<u8>) {
        self.owner_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_owner_id(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.owner_id
    }

    // Take field
    pub fn take_owner_id(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.owner_id, ::std::vec::Vec::new())
    }

    // string owner_ip_address = 3;


    pub fn get_owner_ip_address(&self) -> &str {
        &self.owner_ip_address
    }
    pub fn clear_owner_ip_address(&mut self) {
        self.owner_ip_address.clear();
    }

    // Param is passed by value, moved
    pub fn set_owner_ip_address(&mut self, v: ::std::string::String) {
        self.owner_ip_address = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_owner_ip_address(&mut self) -> &mut ::std::string::String {
        &mut self.owner_ip_address
    }

    // Take field
    pub fn take_owner_ip_address(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.owner_ip_address, ::std::string::String::new())
    }

    // string node_ip_address = 4;


    pub fn get_node_ip_address(&self) -> &str {
        &self.node_ip_address
    }
    pub fn clear_node_ip_address(&mut self) {
        self.node_ip_address.clear();
    }

    // Param is passed by value, moved
    pub fn set_node_ip_address(&mut self, v: ::std::string::String) {
        self.node_ip_address = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_node_ip_address(&mut self) -> &mut ::std::string::String {
        &mut self.node_ip_address
    }

    // Take field
    pub fn take_node_ip_address(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.node_ip_address, ::std::string::String::new())
    }

    // uint32 pid = 5;


    pub fn get_pid(&self) -> u32 {
        self.pid
    }
    pub fn clear_pid(&mut self) {
        self.pid = 0;
    }

    // Param is passed by value, moved
    pub fn set_pid(&mut self, v: u32) {
        self.pid = v;
    }

    // string name = 6;


    pub fn get_name(&self) -> &str {
        &self.name
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        &mut self.name
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.name, ::std::string::String::new())
    }

    // string ray_namespace = 7;


    pub fn get_ray_namespace(&self) -> &str {
        &self.ray_namespace
    }
    pub fn clear_ray_namespace(&mut self) {
        self.ray_namespace.clear();
    }

    // Param is passed by value, moved
    pub fn set_ray_namespace(&mut self, v: ::std::string::String) {
        self.ray_namespace = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_ray_namespace(&mut self) -> &mut ::std::string::String {
        &mut self.ray_namespace
    }

    // Take field
    pub fn take_ray_namespace(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.ray_namespace, ::std::string::String::new())
    }

    // string class_name = 8;


    pub fn get_class_name(&self) -> &str {
        &self.class_name
    }
    pub fn clear_class_name(&mut self) {
        self.class_name.clear();
    }

    // Param is passed by value, moved
    pub fn set_class_name(&mut self, v: ::std::string::String) {
        self.class_name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_class_name(&mut self) -> &mut ::std::string::String {
        &mut self.class_name
    }

    // Take field
    pub fn take_class_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.class_name, ::std::string::String::new())
    }

    // bytes actor_id = 9;


    pub fn get_actor_id(&self) -> &[u8] {
        &self.actor_id
    }
    pub fn clear_actor_id(&mut self) {
        self.actor_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_actor_id(&mut self, v: ::std::vec::Vec<u8>) {
        self.actor_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_actor_id(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.actor_id
    }

    // Take field
    pub fn take_actor_id(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.actor_id, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for ActorDiedErrorContext {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.error_message)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.owner_id)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.owner_ip_address)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.node_ip_address)?;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.pid = tmp;
                },
                6 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.name)?;
                },
                7 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.ray_namespace)?;
                },
                8 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.class_name)?;
                },
                9 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.actor_id)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.error_message.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.error_message);
        }
        if !self.owner_id.is_empty() {
            my_size += ::protobuf::rt::bytes_size(2, &self.owner_id);
        }
        if !self.owner_ip_address.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.owner_ip_address);
        }
        if !self.node_ip_address.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.node_ip_address);
        }
        if self.pid != 0 {
            my_size += ::protobuf::rt::value_size(5, self.pid, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(6, &self.name);
        }
        if !self.ray_namespace.is_empty() {
            my_size += ::protobuf::rt::string_size(7, &self.ray_namespace);
        }
        if !self.class_name.is_empty() {
            my_size += ::protobuf::rt::string_size(8, &self.class_name);
        }
        if !self.actor_id.is_empty() {
            my_size += ::protobuf::rt::bytes_size(9, &self.actor_id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.error_message.is_empty() {
            os.write_string(1, &self.error_message)?;
        }
        if !self.owner_id.is_empty() {
            os.write_bytes(2, &self.owner_id)?;
        }
        if !self.owner_ip_address.is_empty() {
            os.write_string(3, &self.owner_ip_address)?;
        }
        if !self.node_ip_address.is_empty() {
            os.write_string(4, &self.node_ip_address)?;
        }
        if self.pid != 0 {
            os.write_uint32(5, self.pid)?;
        }
        if !self.name.is_empty() {
            os.write_string(6, &self.name)?;
        }
        if !self.ray_namespace.is_empty() {
            os.write_string(7, &self.ray_namespace)?;
        }
        if !self.class_name.is_empty() {
            os.write_string(8, &self.class_name)?;
        }
        if !self.actor_id.is_empty() {
            os.write_bytes(9, &self.actor_id)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ActorDiedErrorContext {
        ActorDiedErrorContext::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "error_message",
                |m: &ActorDiedErrorContext| { &m.error_message },
                |m: &mut ActorDiedErrorContext| { &mut m.error_message },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "owner_id",
                |m: &ActorDiedErrorContext| { &m.owner_id },
                |m: &mut ActorDiedErrorContext| { &mut m.owner_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "owner_ip_address",
                |m: &ActorDiedErrorContext| { &m.owner_ip_address },
                |m: &mut ActorDiedErrorContext| { &mut m.owner_ip_address },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "node_ip_address",
                |m: &ActorDiedErrorContext| { &m.node_ip_address },
                |m: &mut ActorDiedErrorContext| { &mut m.node_ip_address },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "pid",
                |m: &ActorDiedErrorContext| { &m.pid },
                |m: &mut ActorDiedErrorContext| { &mut m.pid },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "name",
                |m: &ActorDiedErrorContext| { &m.name },
                |m: &mut ActorDiedErrorContext| { &mut m.name },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "ray_namespace",
                |m: &ActorDiedErrorContext| { &m.ray_namespace },
                |m: &mut ActorDiedErrorContext| { &mut m.ray_namespace },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "class_name",
                |m: &ActorDiedErrorContext| { &m.class_name },
                |m: &mut ActorDiedErrorContext| { &mut m.class_name },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "actor_id",
                |m: &ActorDiedErrorContext| { &m.actor_id },
                |m: &mut ActorDiedErrorContext| { &mut m.actor_id },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ActorDiedErrorContext>(
                "ActorDiedErrorContext",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ActorDiedErrorContext {
        static instance: ::protobuf::rt::LazyV2<ActorDiedErrorContext> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ActorDiedErrorContext::new)
    }
}

impl ::protobuf::Clear for ActorDiedErrorContext {
    fn clear(&mut self) {
        self.error_message.clear();
        self.owner_id.clear();
        self.owner_ip_address.clear();
        self.node_ip_address.clear();
        self.pid = 0;
        self.name.clear();
        self.ray_namespace.clear();
        self.class_name.clear();
        self.actor_id.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ActorDiedErrorContext {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ActorDiedErrorContext {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct TaskSpec {
    // message fields
    pub field_type: TaskType,
    pub name: ::std::string::String,
    pub language: Language,
    pub function_descriptor: ::protobuf::SingularPtrField<FunctionDescriptor>,
    pub job_id: ::std::vec::Vec<u8>,
    pub task_id: ::std::vec::Vec<u8>,
    pub parent_task_id: ::std::vec::Vec<u8>,
    pub parent_counter: u64,
    pub caller_id: ::std::vec::Vec<u8>,
    pub caller_address: ::protobuf::SingularPtrField<Address>,
    pub args: ::protobuf::RepeatedField<TaskArg>,
    pub num_returns: u64,
    pub required_resources: ::std::collections::HashMap<::std::string::String, f64>,
    pub required_placement_resources: ::std::collections::HashMap<::std::string::String, f64>,
    pub actor_creation_task_spec: ::protobuf::SingularPtrField<ActorCreationTaskSpec>,
    pub actor_task_spec: ::protobuf::SingularPtrField<ActorTaskSpec>,
    pub max_retries: i32,
    pub skip_execution: bool,
    pub debugger_breakpoint: ::std::vec::Vec<u8>,
    pub runtime_env_info: ::protobuf::SingularPtrField<super::runtime_env_common::RuntimeEnvInfo>,
    pub concurrency_group_name: ::std::string::String,
    pub retry_exceptions: bool,
    pub depth: i64,
    pub scheduling_strategy: ::protobuf::SingularPtrField<SchedulingStrategy>,
    pub attempt_number: u64,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a TaskSpec {
    fn default() -> &'a TaskSpec {
        <TaskSpec as ::protobuf::Message>::default_instance()
    }
}

impl TaskSpec {
    pub fn new() -> TaskSpec {
        ::std::default::Default::default()
    }

    // .ray.rpc.TaskType type = 1;


    pub fn get_field_type(&self) -> TaskType {
        self.field_type
    }
    pub fn clear_field_type(&mut self) {
        self.field_type = TaskType::NORMAL_TASK;
    }

    // Param is passed by value, moved
    pub fn set_field_type(&mut self, v: TaskType) {
        self.field_type = v;
    }

    // string name = 2;


    pub fn get_name(&self) -> &str {
        &self.name
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        &mut self.name
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.name, ::std::string::String::new())
    }

    // .ray.rpc.Language language = 3;


    pub fn get_language(&self) -> Language {
        self.language
    }
    pub fn clear_language(&mut self) {
        self.language = Language::PYTHON;
    }

    // Param is passed by value, moved
    pub fn set_language(&mut self, v: Language) {
        self.language = v;
    }

    // .ray.rpc.FunctionDescriptor function_descriptor = 4;


    pub fn get_function_descriptor(&self) -> &FunctionDescriptor {
        self.function_descriptor.as_ref().unwrap_or_else(|| <FunctionDescriptor as ::protobuf::Message>::default_instance())
    }
    pub fn clear_function_descriptor(&mut self) {
        self.function_descriptor.clear();
    }

    pub fn has_function_descriptor(&self) -> bool {
        self.function_descriptor.is_some()
    }

    // Param is passed by value, moved
    pub fn set_function_descriptor(&mut self, v: FunctionDescriptor) {
        self.function_descriptor = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_function_descriptor(&mut self) -> &mut FunctionDescriptor {
        if self.function_descriptor.is_none() {
            self.function_descriptor.set_default();
        }
        self.function_descriptor.as_mut().unwrap()
    }

    // Take field
    pub fn take_function_descriptor(&mut self) -> FunctionDescriptor {
        self.function_descriptor.take().unwrap_or_else(|| FunctionDescriptor::new())
    }

    // bytes job_id = 5;


    pub fn get_job_id(&self) -> &[u8] {
        &self.job_id
    }
    pub fn clear_job_id(&mut self) {
        self.job_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_job_id(&mut self, v: ::std::vec::Vec<u8>) {
        self.job_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_job_id(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.job_id
    }

    // Take field
    pub fn take_job_id(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.job_id, ::std::vec::Vec::new())
    }

    // bytes task_id = 6;


    pub fn get_task_id(&self) -> &[u8] {
        &self.task_id
    }
    pub fn clear_task_id(&mut self) {
        self.task_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_task_id(&mut self, v: ::std::vec::Vec<u8>) {
        self.task_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_task_id(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.task_id
    }

    // Take field
    pub fn take_task_id(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.task_id, ::std::vec::Vec::new())
    }

    // bytes parent_task_id = 7;


    pub fn get_parent_task_id(&self) -> &[u8] {
        &self.parent_task_id
    }
    pub fn clear_parent_task_id(&mut self) {
        self.parent_task_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_parent_task_id(&mut self, v: ::std::vec::Vec<u8>) {
        self.parent_task_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_parent_task_id(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.parent_task_id
    }

    // Take field
    pub fn take_parent_task_id(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.parent_task_id, ::std::vec::Vec::new())
    }

    // uint64 parent_counter = 8;


    pub fn get_parent_counter(&self) -> u64 {
        self.parent_counter
    }
    pub fn clear_parent_counter(&mut self) {
        self.parent_counter = 0;
    }

    // Param is passed by value, moved
    pub fn set_parent_counter(&mut self, v: u64) {
        self.parent_counter = v;
    }

    // bytes caller_id = 9;


    pub fn get_caller_id(&self) -> &[u8] {
        &self.caller_id
    }
    pub fn clear_caller_id(&mut self) {
        self.caller_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_caller_id(&mut self, v: ::std::vec::Vec<u8>) {
        self.caller_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_caller_id(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.caller_id
    }

    // Take field
    pub fn take_caller_id(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.caller_id, ::std::vec::Vec::new())
    }

    // .ray.rpc.Address caller_address = 10;


    pub fn get_caller_address(&self) -> &Address {
        self.caller_address.as_ref().unwrap_or_else(|| <Address as ::protobuf::Message>::default_instance())
    }
    pub fn clear_caller_address(&mut self) {
        self.caller_address.clear();
    }

    pub fn has_caller_address(&self) -> bool {
        self.caller_address.is_some()
    }

    // Param is passed by value, moved
    pub fn set_caller_address(&mut self, v: Address) {
        self.caller_address = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_caller_address(&mut self) -> &mut Address {
        if self.caller_address.is_none() {
            self.caller_address.set_default();
        }
        self.caller_address.as_mut().unwrap()
    }

    // Take field
    pub fn take_caller_address(&mut self) -> Address {
        self.caller_address.take().unwrap_or_else(|| Address::new())
    }

    // repeated .ray.rpc.TaskArg args = 11;


    pub fn get_args(&self) -> &[TaskArg] {
        &self.args
    }
    pub fn clear_args(&mut self) {
        self.args.clear();
    }

    // Param is passed by value, moved
    pub fn set_args(&mut self, v: ::protobuf::RepeatedField<TaskArg>) {
        self.args = v;
    }

    // Mutable pointer to the field.
    pub fn mut_args(&mut self) -> &mut ::protobuf::RepeatedField<TaskArg> {
        &mut self.args
    }

    // Take field
    pub fn take_args(&mut self) -> ::protobuf::RepeatedField<TaskArg> {
        ::std::mem::replace(&mut self.args, ::protobuf::RepeatedField::new())
    }

    // uint64 num_returns = 12;


    pub fn get_num_returns(&self) -> u64 {
        self.num_returns
    }
    pub fn clear_num_returns(&mut self) {
        self.num_returns = 0;
    }

    // Param is passed by value, moved
    pub fn set_num_returns(&mut self, v: u64) {
        self.num_returns = v;
    }

    // repeated .ray.rpc.TaskSpec.RequiredResourcesEntry required_resources = 13;


    pub fn get_required_resources(&self) -> &::std::collections::HashMap<::std::string::String, f64> {
        &self.required_resources
    }
    pub fn clear_required_resources(&mut self) {
        self.required_resources.clear();
    }

    // Param is passed by value, moved
    pub fn set_required_resources(&mut self, v: ::std::collections::HashMap<::std::string::String, f64>) {
        self.required_resources = v;
    }

    // Mutable pointer to the field.
    pub fn mut_required_resources(&mut self) -> &mut ::std::collections::HashMap<::std::string::String, f64> {
        &mut self.required_resources
    }

    // Take field
    pub fn take_required_resources(&mut self) -> ::std::collections::HashMap<::std::string::String, f64> {
        ::std::mem::replace(&mut self.required_resources, ::std::collections::HashMap::new())
    }

    // repeated .ray.rpc.TaskSpec.RequiredPlacementResourcesEntry required_placement_resources = 14;


    pub fn get_required_placement_resources(&self) -> &::std::collections::HashMap<::std::string::String, f64> {
        &self.required_placement_resources
    }
    pub fn clear_required_placement_resources(&mut self) {
        self.required_placement_resources.clear();
    }

    // Param is passed by value, moved
    pub fn set_required_placement_resources(&mut self, v: ::std::collections::HashMap<::std::string::String, f64>) {
        self.required_placement_resources = v;
    }

    // Mutable pointer to the field.
    pub fn mut_required_placement_resources(&mut self) -> &mut ::std::collections::HashMap<::std::string::String, f64> {
        &mut self.required_placement_resources
    }

    // Take field
    pub fn take_required_placement_resources(&mut self) -> ::std::collections::HashMap<::std::string::String, f64> {
        ::std::mem::replace(&mut self.required_placement_resources, ::std::collections::HashMap::new())
    }

    // .ray.rpc.ActorCreationTaskSpec actor_creation_task_spec = 15;


    pub fn get_actor_creation_task_spec(&self) -> &ActorCreationTaskSpec {
        self.actor_creation_task_spec.as_ref().unwrap_or_else(|| <ActorCreationTaskSpec as ::protobuf::Message>::default_instance())
    }
    pub fn clear_actor_creation_task_spec(&mut self) {
        self.actor_creation_task_spec.clear();
    }

    pub fn has_actor_creation_task_spec(&self) -> bool {
        self.actor_creation_task_spec.is_some()
    }

    // Param is passed by value, moved
    pub fn set_actor_creation_task_spec(&mut self, v: ActorCreationTaskSpec) {
        self.actor_creation_task_spec = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_actor_creation_task_spec(&mut self) -> &mut ActorCreationTaskSpec {
        if self.actor_creation_task_spec.is_none() {
            self.actor_creation_task_spec.set_default();
        }
        self.actor_creation_task_spec.as_mut().unwrap()
    }

    // Take field
    pub fn take_actor_creation_task_spec(&mut self) -> ActorCreationTaskSpec {
        self.actor_creation_task_spec.take().unwrap_or_else(|| ActorCreationTaskSpec::new())
    }

    // .ray.rpc.ActorTaskSpec actor_task_spec = 16;


    pub fn get_actor_task_spec(&self) -> &ActorTaskSpec {
        self.actor_task_spec.as_ref().unwrap_or_else(|| <ActorTaskSpec as ::protobuf::Message>::default_instance())
    }
    pub fn clear_actor_task_spec(&mut self) {
        self.actor_task_spec.clear();
    }

    pub fn has_actor_task_spec(&self) -> bool {
        self.actor_task_spec.is_some()
    }

    // Param is passed by value, moved
    pub fn set_actor_task_spec(&mut self, v: ActorTaskSpec) {
        self.actor_task_spec = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_actor_task_spec(&mut self) -> &mut ActorTaskSpec {
        if self.actor_task_spec.is_none() {
            self.actor_task_spec.set_default();
        }
        self.actor_task_spec.as_mut().unwrap()
    }

    // Take field
    pub fn take_actor_task_spec(&mut self) -> ActorTaskSpec {
        self.actor_task_spec.take().unwrap_or_else(|| ActorTaskSpec::new())
    }

    // int32 max_retries = 17;


    pub fn get_max_retries(&self) -> i32 {
        self.max_retries
    }
    pub fn clear_max_retries(&mut self) {
        self.max_retries = 0;
    }

    // Param is passed by value, moved
    pub fn set_max_retries(&mut self, v: i32) {
        self.max_retries = v;
    }

    // bool skip_execution = 21;


    pub fn get_skip_execution(&self) -> bool {
        self.skip_execution
    }
    pub fn clear_skip_execution(&mut self) {
        self.skip_execution = false;
    }

    // Param is passed by value, moved
    pub fn set_skip_execution(&mut self, v: bool) {
        self.skip_execution = v;
    }

    // bytes debugger_breakpoint = 22;


    pub fn get_debugger_breakpoint(&self) -> &[u8] {
        &self.debugger_breakpoint
    }
    pub fn clear_debugger_breakpoint(&mut self) {
        self.debugger_breakpoint.clear();
    }

    // Param is passed by value, moved
    pub fn set_debugger_breakpoint(&mut self, v: ::std::vec::Vec<u8>) {
        self.debugger_breakpoint = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_debugger_breakpoint(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.debugger_breakpoint
    }

    // Take field
    pub fn take_debugger_breakpoint(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.debugger_breakpoint, ::std::vec::Vec::new())
    }

    // .ray.rpc.RuntimeEnvInfo runtime_env_info = 23;


    pub fn get_runtime_env_info(&self) -> &super::runtime_env_common::RuntimeEnvInfo {
        self.runtime_env_info.as_ref().unwrap_or_else(|| <super::runtime_env_common::RuntimeEnvInfo as ::protobuf::Message>::default_instance())
    }
    pub fn clear_runtime_env_info(&mut self) {
        self.runtime_env_info.clear();
    }

    pub fn has_runtime_env_info(&self) -> bool {
        self.runtime_env_info.is_some()
    }

    // Param is passed by value, moved
    pub fn set_runtime_env_info(&mut self, v: super::runtime_env_common::RuntimeEnvInfo) {
        self.runtime_env_info = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_runtime_env_info(&mut self) -> &mut super::runtime_env_common::RuntimeEnvInfo {
        if self.runtime_env_info.is_none() {
            self.runtime_env_info.set_default();
        }
        self.runtime_env_info.as_mut().unwrap()
    }

    // Take field
    pub fn take_runtime_env_info(&mut self) -> super::runtime_env_common::RuntimeEnvInfo {
        self.runtime_env_info.take().unwrap_or_else(|| super::runtime_env_common::RuntimeEnvInfo::new())
    }

    // string concurrency_group_name = 24;


    pub fn get_concurrency_group_name(&self) -> &str {
        &self.concurrency_group_name
    }
    pub fn clear_concurrency_group_name(&mut self) {
        self.concurrency_group_name.clear();
    }

    // Param is passed by value, moved
    pub fn set_concurrency_group_name(&mut self, v: ::std::string::String) {
        self.concurrency_group_name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_concurrency_group_name(&mut self) -> &mut ::std::string::String {
        &mut self.concurrency_group_name
    }

    // Take field
    pub fn take_concurrency_group_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.concurrency_group_name, ::std::string::String::new())
    }

    // bool retry_exceptions = 25;


    pub fn get_retry_exceptions(&self) -> bool {
        self.retry_exceptions
    }
    pub fn clear_retry_exceptions(&mut self) {
        self.retry_exceptions = false;
    }

    // Param is passed by value, moved
    pub fn set_retry_exceptions(&mut self, v: bool) {
        self.retry_exceptions = v;
    }

    // int64 depth = 26;


    pub fn get_depth(&self) -> i64 {
        self.depth
    }
    pub fn clear_depth(&mut self) {
        self.depth = 0;
    }

    // Param is passed by value, moved
    pub fn set_depth(&mut self, v: i64) {
        self.depth = v;
    }

    // .ray.rpc.SchedulingStrategy scheduling_strategy = 27;


    pub fn get_scheduling_strategy(&self) -> &SchedulingStrategy {
        self.scheduling_strategy.as_ref().unwrap_or_else(|| <SchedulingStrategy as ::protobuf::Message>::default_instance())
    }
    pub fn clear_scheduling_strategy(&mut self) {
        self.scheduling_strategy.clear();
    }

    pub fn has_scheduling_strategy(&self) -> bool {
        self.scheduling_strategy.is_some()
    }

    // Param is passed by value, moved
    pub fn set_scheduling_strategy(&mut self, v: SchedulingStrategy) {
        self.scheduling_strategy = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_scheduling_strategy(&mut self) -> &mut SchedulingStrategy {
        if self.scheduling_strategy.is_none() {
            self.scheduling_strategy.set_default();
        }
        self.scheduling_strategy.as_mut().unwrap()
    }

    // Take field
    pub fn take_scheduling_strategy(&mut self) -> SchedulingStrategy {
        self.scheduling_strategy.take().unwrap_or_else(|| SchedulingStrategy::new())
    }

    // uint64 attempt_number = 28;


    pub fn get_attempt_number(&self) -> u64 {
        self.attempt_number
    }
    pub fn clear_attempt_number(&mut self) {
        self.attempt_number = 0;
    }

    // Param is passed by value, moved
    pub fn set_attempt_number(&mut self, v: u64) {
        self.attempt_number = v;
    }
}

impl ::protobuf::Message for TaskSpec {
    fn is_initialized(&self) -> bool {
        for v in &self.function_descriptor {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.caller_address {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.args {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.actor_creation_task_spec {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.actor_task_spec {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.runtime_env_info {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.scheduling_strategy {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.field_type, 1, &mut self.unknown_fields)?
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.name)?;
                },
                3 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.language, 3, &mut self.unknown_fields)?
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.function_descriptor)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.job_id)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.task_id)?;
                },
                7 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.parent_task_id)?;
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.parent_counter = tmp;
                },
                9 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.caller_id)?;
                },
                10 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.caller_address)?;
                },
                11 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.args)?;
                },
                12 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.num_returns = tmp;
                },
                13 => {
                    ::protobuf::rt::read_map_into::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeDouble>(wire_type, is, &mut self.required_resources)?;
                },
                14 => {
                    ::protobuf::rt::read_map_into::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeDouble>(wire_type, is, &mut self.required_placement_resources)?;
                },
                15 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.actor_creation_task_spec)?;
                },
                16 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.actor_task_spec)?;
                },
                17 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.max_retries = tmp;
                },
                21 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.skip_execution = tmp;
                },
                22 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.debugger_breakpoint)?;
                },
                23 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.runtime_env_info)?;
                },
                24 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.concurrency_group_name)?;
                },
                25 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.retry_exceptions = tmp;
                },
                26 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.depth = tmp;
                },
                27 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.scheduling_strategy)?;
                },
                28 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.attempt_number = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.field_type != TaskType::NORMAL_TASK {
            my_size += ::protobuf::rt::enum_size(1, self.field_type);
        }
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.name);
        }
        if self.language != Language::PYTHON {
            my_size += ::protobuf::rt::enum_size(3, self.language);
        }
        if let Some(ref v) = self.function_descriptor.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.job_id.is_empty() {
            my_size += ::protobuf::rt::bytes_size(5, &self.job_id);
        }
        if !self.task_id.is_empty() {
            my_size += ::protobuf::rt::bytes_size(6, &self.task_id);
        }
        if !self.parent_task_id.is_empty() {
            my_size += ::protobuf::rt::bytes_size(7, &self.parent_task_id);
        }
        if self.parent_counter != 0 {
            my_size += ::protobuf::rt::value_size(8, self.parent_counter, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.caller_id.is_empty() {
            my_size += ::protobuf::rt::bytes_size(9, &self.caller_id);
        }
        if let Some(ref v) = self.caller_address.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.args {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if self.num_returns != 0 {
            my_size += ::protobuf::rt::value_size(12, self.num_returns, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::compute_map_size::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeDouble>(13, &self.required_resources);
        my_size += ::protobuf::rt::compute_map_size::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeDouble>(14, &self.required_placement_resources);
        if let Some(ref v) = self.actor_creation_task_spec.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.actor_task_spec.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.max_retries != 0 {
            my_size += ::protobuf::rt::value_size(17, self.max_retries, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.skip_execution != false {
            my_size += 3;
        }
        if !self.debugger_breakpoint.is_empty() {
            my_size += ::protobuf::rt::bytes_size(22, &self.debugger_breakpoint);
        }
        if let Some(ref v) = self.runtime_env_info.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.concurrency_group_name.is_empty() {
            my_size += ::protobuf::rt::string_size(24, &self.concurrency_group_name);
        }
        if self.retry_exceptions != false {
            my_size += 3;
        }
        if self.depth != 0 {
            my_size += ::protobuf::rt::value_size(26, self.depth, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.scheduling_strategy.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.attempt_number != 0 {
            my_size += ::protobuf::rt::value_size(28, self.attempt_number, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.field_type != TaskType::NORMAL_TASK {
            os.write_enum(1, ::protobuf::ProtobufEnum::value(&self.field_type))?;
        }
        if !self.name.is_empty() {
            os.write_string(2, &self.name)?;
        }
        if self.language != Language::PYTHON {
            os.write_enum(3, ::protobuf::ProtobufEnum::value(&self.language))?;
        }
        if let Some(ref v) = self.function_descriptor.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.job_id.is_empty() {
            os.write_bytes(5, &self.job_id)?;
        }
        if !self.task_id.is_empty() {
            os.write_bytes(6, &self.task_id)?;
        }
        if !self.parent_task_id.is_empty() {
            os.write_bytes(7, &self.parent_task_id)?;
        }
        if self.parent_counter != 0 {
            os.write_uint64(8, self.parent_counter)?;
        }
        if !self.caller_id.is_empty() {
            os.write_bytes(9, &self.caller_id)?;
        }
        if let Some(ref v) = self.caller_address.as_ref() {
            os.write_tag(10, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.args {
            os.write_tag(11, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if self.num_returns != 0 {
            os.write_uint64(12, self.num_returns)?;
        }
        ::protobuf::rt::write_map_with_cached_sizes::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeDouble>(13, &self.required_resources, os)?;
        ::protobuf::rt::write_map_with_cached_sizes::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeDouble>(14, &self.required_placement_resources, os)?;
        if let Some(ref v) = self.actor_creation_task_spec.as_ref() {
            os.write_tag(15, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.actor_task_spec.as_ref() {
            os.write_tag(16, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.max_retries != 0 {
            os.write_int32(17, self.max_retries)?;
        }
        if self.skip_execution != false {
            os.write_bool(21, self.skip_execution)?;
        }
        if !self.debugger_breakpoint.is_empty() {
            os.write_bytes(22, &self.debugger_breakpoint)?;
        }
        if let Some(ref v) = self.runtime_env_info.as_ref() {
            os.write_tag(23, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.concurrency_group_name.is_empty() {
            os.write_string(24, &self.concurrency_group_name)?;
        }
        if self.retry_exceptions != false {
            os.write_bool(25, self.retry_exceptions)?;
        }
        if self.depth != 0 {
            os.write_int64(26, self.depth)?;
        }
        if let Some(ref v) = self.scheduling_strategy.as_ref() {
            os.write_tag(27, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.attempt_number != 0 {
            os.write_uint64(28, self.attempt_number)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> TaskSpec {
        TaskSpec::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<TaskType>>(
                "type",
                |m: &TaskSpec| { &m.field_type },
                |m: &mut TaskSpec| { &mut m.field_type },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "name",
                |m: &TaskSpec| { &m.name },
                |m: &mut TaskSpec| { &mut m.name },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<Language>>(
                "language",
                |m: &TaskSpec| { &m.language },
                |m: &mut TaskSpec| { &mut m.language },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<FunctionDescriptor>>(
                "function_descriptor",
                |m: &TaskSpec| { &m.function_descriptor },
                |m: &mut TaskSpec| { &mut m.function_descriptor },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "job_id",
                |m: &TaskSpec| { &m.job_id },
                |m: &mut TaskSpec| { &mut m.job_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "task_id",
                |m: &TaskSpec| { &m.task_id },
                |m: &mut TaskSpec| { &mut m.task_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "parent_task_id",
                |m: &TaskSpec| { &m.parent_task_id },
                |m: &mut TaskSpec| { &mut m.parent_task_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "parent_counter",
                |m: &TaskSpec| { &m.parent_counter },
                |m: &mut TaskSpec| { &mut m.parent_counter },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "caller_id",
                |m: &TaskSpec| { &m.caller_id },
                |m: &mut TaskSpec| { &mut m.caller_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Address>>(
                "caller_address",
                |m: &TaskSpec| { &m.caller_address },
                |m: &mut TaskSpec| { &mut m.caller_address },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<TaskArg>>(
                "args",
                |m: &TaskSpec| { &m.args },
                |m: &mut TaskSpec| { &mut m.args },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "num_returns",
                |m: &TaskSpec| { &m.num_returns },
                |m: &mut TaskSpec| { &mut m.num_returns },
            ));
            fields.push(::protobuf::reflect::accessor::make_map_accessor::<_, ::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeDouble>(
                "required_resources",
                |m: &TaskSpec| { &m.required_resources },
                |m: &mut TaskSpec| { &mut m.required_resources },
            ));
            fields.push(::protobuf::reflect::accessor::make_map_accessor::<_, ::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeDouble>(
                "required_placement_resources",
                |m: &TaskSpec| { &m.required_placement_resources },
                |m: &mut TaskSpec| { &mut m.required_placement_resources },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ActorCreationTaskSpec>>(
                "actor_creation_task_spec",
                |m: &TaskSpec| { &m.actor_creation_task_spec },
                |m: &mut TaskSpec| { &mut m.actor_creation_task_spec },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ActorTaskSpec>>(
                "actor_task_spec",
                |m: &TaskSpec| { &m.actor_task_spec },
                |m: &mut TaskSpec| { &mut m.actor_task_spec },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "max_retries",
                |m: &TaskSpec| { &m.max_retries },
                |m: &mut TaskSpec| { &mut m.max_retries },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "skip_execution",
                |m: &TaskSpec| { &m.skip_execution },
                |m: &mut TaskSpec| { &mut m.skip_execution },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "debugger_breakpoint",
                |m: &TaskSpec| { &m.debugger_breakpoint },
                |m: &mut TaskSpec| { &mut m.debugger_breakpoint },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::runtime_env_common::RuntimeEnvInfo>>(
                "runtime_env_info",
                |m: &TaskSpec| { &m.runtime_env_info },
                |m: &mut TaskSpec| { &mut m.runtime_env_info },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "concurrency_group_name",
                |m: &TaskSpec| { &m.concurrency_group_name },
                |m: &mut TaskSpec| { &mut m.concurrency_group_name },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "retry_exceptions",
                |m: &TaskSpec| { &m.retry_exceptions },
                |m: &mut TaskSpec| { &mut m.retry_exceptions },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "depth",
                |m: &TaskSpec| { &m.depth },
                |m: &mut TaskSpec| { &mut m.depth },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<SchedulingStrategy>>(
                "scheduling_strategy",
                |m: &TaskSpec| { &m.scheduling_strategy },
                |m: &mut TaskSpec| { &mut m.scheduling_strategy },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "attempt_number",
                |m: &TaskSpec| { &m.attempt_number },
                |m: &mut TaskSpec| { &mut m.attempt_number },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<TaskSpec>(
                "TaskSpec",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static TaskSpec {
        static instance: ::protobuf::rt::LazyV2<TaskSpec> = ::protobuf::rt::LazyV2::INIT;
        instance.get(TaskSpec::new)
    }
}

impl ::protobuf::Clear for TaskSpec {
    fn clear(&mut self) {
        self.field_type = TaskType::NORMAL_TASK;
        self.name.clear();
        self.language = Language::PYTHON;
        self.function_descriptor.clear();
        self.job_id.clear();
        self.task_id.clear();
        self.parent_task_id.clear();
        self.parent_counter = 0;
        self.caller_id.clear();
        self.caller_address.clear();
        self.args.clear();
        self.num_returns = 0;
        self.required_resources.clear();
        self.required_placement_resources.clear();
        self.actor_creation_task_spec.clear();
        self.actor_task_spec.clear();
        self.max_retries = 0;
        self.skip_execution = false;
        self.debugger_breakpoint.clear();
        self.runtime_env_info.clear();
        self.concurrency_group_name.clear();
        self.retry_exceptions = false;
        self.depth = 0;
        self.scheduling_strategy.clear();
        self.attempt_number = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for TaskSpec {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TaskSpec {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Bundle {
    // message fields
    pub bundle_id: ::protobuf::SingularPtrField<Bundle_BundleIdentifier>,
    pub unit_resources: ::std::collections::HashMap<::std::string::String, f64>,
    pub node_id: ::std::vec::Vec<u8>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Bundle {
    fn default() -> &'a Bundle {
        <Bundle as ::protobuf::Message>::default_instance()
    }
}

impl Bundle {
    pub fn new() -> Bundle {
        ::std::default::Default::default()
    }

    // .ray.rpc.Bundle.BundleIdentifier bundle_id = 1;


    pub fn get_bundle_id(&self) -> &Bundle_BundleIdentifier {
        self.bundle_id.as_ref().unwrap_or_else(|| <Bundle_BundleIdentifier as ::protobuf::Message>::default_instance())
    }
    pub fn clear_bundle_id(&mut self) {
        self.bundle_id.clear();
    }

    pub fn has_bundle_id(&self) -> bool {
        self.bundle_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_bundle_id(&mut self, v: Bundle_BundleIdentifier) {
        self.bundle_id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_bundle_id(&mut self) -> &mut Bundle_BundleIdentifier {
        if self.bundle_id.is_none() {
            self.bundle_id.set_default();
        }
        self.bundle_id.as_mut().unwrap()
    }

    // Take field
    pub fn take_bundle_id(&mut self) -> Bundle_BundleIdentifier {
        self.bundle_id.take().unwrap_or_else(|| Bundle_BundleIdentifier::new())
    }

    // repeated .ray.rpc.Bundle.UnitResourcesEntry unit_resources = 2;


    pub fn get_unit_resources(&self) -> &::std::collections::HashMap<::std::string::String, f64> {
        &self.unit_resources
    }
    pub fn clear_unit_resources(&mut self) {
        self.unit_resources.clear();
    }

    // Param is passed by value, moved
    pub fn set_unit_resources(&mut self, v: ::std::collections::HashMap<::std::string::String, f64>) {
        self.unit_resources = v;
    }

    // Mutable pointer to the field.
    pub fn mut_unit_resources(&mut self) -> &mut ::std::collections::HashMap<::std::string::String, f64> {
        &mut self.unit_resources
    }

    // Take field
    pub fn take_unit_resources(&mut self) -> ::std::collections::HashMap<::std::string::String, f64> {
        ::std::mem::replace(&mut self.unit_resources, ::std::collections::HashMap::new())
    }

    // bytes node_id = 3;


    pub fn get_node_id(&self) -> &[u8] {
        &self.node_id
    }
    pub fn clear_node_id(&mut self) {
        self.node_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_node_id(&mut self, v: ::std::vec::Vec<u8>) {
        self.node_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_node_id(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.node_id
    }

    // Take field
    pub fn take_node_id(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.node_id, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for Bundle {
    fn is_initialized(&self) -> bool {
        for v in &self.bundle_id {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.bundle_id)?;
                },
                2 => {
                    ::protobuf::rt::read_map_into::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeDouble>(wire_type, is, &mut self.unit_resources)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.node_id)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.bundle_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::compute_map_size::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeDouble>(2, &self.unit_resources);
        if !self.node_id.is_empty() {
            my_size += ::protobuf::rt::bytes_size(3, &self.node_id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.bundle_id.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        ::protobuf::rt::write_map_with_cached_sizes::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeDouble>(2, &self.unit_resources, os)?;
        if !self.node_id.is_empty() {
            os.write_bytes(3, &self.node_id)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Bundle {
        Bundle::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Bundle_BundleIdentifier>>(
                "bundle_id",
                |m: &Bundle| { &m.bundle_id },
                |m: &mut Bundle| { &mut m.bundle_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_map_accessor::<_, ::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeDouble>(
                "unit_resources",
                |m: &Bundle| { &m.unit_resources },
                |m: &mut Bundle| { &mut m.unit_resources },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "node_id",
                |m: &Bundle| { &m.node_id },
                |m: &mut Bundle| { &mut m.node_id },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Bundle>(
                "Bundle",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Bundle {
        static instance: ::protobuf::rt::LazyV2<Bundle> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Bundle::new)
    }
}

impl ::protobuf::Clear for Bundle {
    fn clear(&mut self) {
        self.bundle_id.clear();
        self.unit_resources.clear();
        self.node_id.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Bundle {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Bundle {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Bundle_BundleIdentifier {
    // message fields
    pub placement_group_id: ::std::vec::Vec<u8>,
    pub bundle_index: i32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Bundle_BundleIdentifier {
    fn default() -> &'a Bundle_BundleIdentifier {
        <Bundle_BundleIdentifier as ::protobuf::Message>::default_instance()
    }
}

impl Bundle_BundleIdentifier {
    pub fn new() -> Bundle_BundleIdentifier {
        ::std::default::Default::default()
    }

    // bytes placement_group_id = 1;


    pub fn get_placement_group_id(&self) -> &[u8] {
        &self.placement_group_id
    }
    pub fn clear_placement_group_id(&mut self) {
        self.placement_group_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_placement_group_id(&mut self, v: ::std::vec::Vec<u8>) {
        self.placement_group_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_placement_group_id(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.placement_group_id
    }

    // Take field
    pub fn take_placement_group_id(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.placement_group_id, ::std::vec::Vec::new())
    }

    // int32 bundle_index = 2;


    pub fn get_bundle_index(&self) -> i32 {
        self.bundle_index
    }
    pub fn clear_bundle_index(&mut self) {
        self.bundle_index = 0;
    }

    // Param is passed by value, moved
    pub fn set_bundle_index(&mut self, v: i32) {
        self.bundle_index = v;
    }
}

impl ::protobuf::Message for Bundle_BundleIdentifier {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.placement_group_id)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.bundle_index = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.placement_group_id.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.placement_group_id);
        }
        if self.bundle_index != 0 {
            my_size += ::protobuf::rt::value_size(2, self.bundle_index, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.placement_group_id.is_empty() {
            os.write_bytes(1, &self.placement_group_id)?;
        }
        if self.bundle_index != 0 {
            os.write_int32(2, self.bundle_index)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Bundle_BundleIdentifier {
        Bundle_BundleIdentifier::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "placement_group_id",
                |m: &Bundle_BundleIdentifier| { &m.placement_group_id },
                |m: &mut Bundle_BundleIdentifier| { &mut m.placement_group_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "bundle_index",
                |m: &Bundle_BundleIdentifier| { &m.bundle_index },
                |m: &mut Bundle_BundleIdentifier| { &mut m.bundle_index },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Bundle_BundleIdentifier>(
                "Bundle.BundleIdentifier",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Bundle_BundleIdentifier {
        static instance: ::protobuf::rt::LazyV2<Bundle_BundleIdentifier> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Bundle_BundleIdentifier::new)
    }
}

impl ::protobuf::Clear for Bundle_BundleIdentifier {
    fn clear(&mut self) {
        self.placement_group_id.clear();
        self.bundle_index = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Bundle_BundleIdentifier {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Bundle_BundleIdentifier {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct PlacementGroupSpec {
    // message fields
    pub placement_group_id: ::std::vec::Vec<u8>,
    pub name: ::std::string::String,
    pub bundles: ::protobuf::RepeatedField<Bundle>,
    pub strategy: PlacementStrategy,
    pub creator_job_id: ::std::vec::Vec<u8>,
    pub creator_actor_id: ::std::vec::Vec<u8>,
    pub creator_job_dead: bool,
    pub creator_actor_dead: bool,
    pub is_detached: bool,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PlacementGroupSpec {
    fn default() -> &'a PlacementGroupSpec {
        <PlacementGroupSpec as ::protobuf::Message>::default_instance()
    }
}

impl PlacementGroupSpec {
    pub fn new() -> PlacementGroupSpec {
        ::std::default::Default::default()
    }

    // bytes placement_group_id = 1;


    pub fn get_placement_group_id(&self) -> &[u8] {
        &self.placement_group_id
    }
    pub fn clear_placement_group_id(&mut self) {
        self.placement_group_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_placement_group_id(&mut self, v: ::std::vec::Vec<u8>) {
        self.placement_group_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_placement_group_id(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.placement_group_id
    }

    // Take field
    pub fn take_placement_group_id(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.placement_group_id, ::std::vec::Vec::new())
    }

    // string name = 2;


    pub fn get_name(&self) -> &str {
        &self.name
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        &mut self.name
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.name, ::std::string::String::new())
    }

    // repeated .ray.rpc.Bundle bundles = 3;


    pub fn get_bundles(&self) -> &[Bundle] {
        &self.bundles
    }
    pub fn clear_bundles(&mut self) {
        self.bundles.clear();
    }

    // Param is passed by value, moved
    pub fn set_bundles(&mut self, v: ::protobuf::RepeatedField<Bundle>) {
        self.bundles = v;
    }

    // Mutable pointer to the field.
    pub fn mut_bundles(&mut self) -> &mut ::protobuf::RepeatedField<Bundle> {
        &mut self.bundles
    }

    // Take field
    pub fn take_bundles(&mut self) -> ::protobuf::RepeatedField<Bundle> {
        ::std::mem::replace(&mut self.bundles, ::protobuf::RepeatedField::new())
    }

    // .ray.rpc.PlacementStrategy strategy = 4;


    pub fn get_strategy(&self) -> PlacementStrategy {
        self.strategy
    }
    pub fn clear_strategy(&mut self) {
        self.strategy = PlacementStrategy::PACK;
    }

    // Param is passed by value, moved
    pub fn set_strategy(&mut self, v: PlacementStrategy) {
        self.strategy = v;
    }

    // bytes creator_job_id = 5;


    pub fn get_creator_job_id(&self) -> &[u8] {
        &self.creator_job_id
    }
    pub fn clear_creator_job_id(&mut self) {
        self.creator_job_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_creator_job_id(&mut self, v: ::std::vec::Vec<u8>) {
        self.creator_job_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_creator_job_id(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.creator_job_id
    }

    // Take field
    pub fn take_creator_job_id(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.creator_job_id, ::std::vec::Vec::new())
    }

    // bytes creator_actor_id = 6;


    pub fn get_creator_actor_id(&self) -> &[u8] {
        &self.creator_actor_id
    }
    pub fn clear_creator_actor_id(&mut self) {
        self.creator_actor_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_creator_actor_id(&mut self, v: ::std::vec::Vec<u8>) {
        self.creator_actor_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_creator_actor_id(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.creator_actor_id
    }

    // Take field
    pub fn take_creator_actor_id(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.creator_actor_id, ::std::vec::Vec::new())
    }

    // bool creator_job_dead = 7;


    pub fn get_creator_job_dead(&self) -> bool {
        self.creator_job_dead
    }
    pub fn clear_creator_job_dead(&mut self) {
        self.creator_job_dead = false;
    }

    // Param is passed by value, moved
    pub fn set_creator_job_dead(&mut self, v: bool) {
        self.creator_job_dead = v;
    }

    // bool creator_actor_dead = 8;


    pub fn get_creator_actor_dead(&self) -> bool {
        self.creator_actor_dead
    }
    pub fn clear_creator_actor_dead(&mut self) {
        self.creator_actor_dead = false;
    }

    // Param is passed by value, moved
    pub fn set_creator_actor_dead(&mut self, v: bool) {
        self.creator_actor_dead = v;
    }

    // bool is_detached = 9;


    pub fn get_is_detached(&self) -> bool {
        self.is_detached
    }
    pub fn clear_is_detached(&mut self) {
        self.is_detached = false;
    }

    // Param is passed by value, moved
    pub fn set_is_detached(&mut self, v: bool) {
        self.is_detached = v;
    }
}

impl ::protobuf::Message for PlacementGroupSpec {
    fn is_initialized(&self) -> bool {
        for v in &self.bundles {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.placement_group_id)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.name)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.bundles)?;
                },
                4 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.strategy, 4, &mut self.unknown_fields)?
                },
                5 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.creator_job_id)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.creator_actor_id)?;
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.creator_job_dead = tmp;
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.creator_actor_dead = tmp;
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.is_detached = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.placement_group_id.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.placement_group_id);
        }
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.name);
        }
        for value in &self.bundles {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if self.strategy != PlacementStrategy::PACK {
            my_size += ::protobuf::rt::enum_size(4, self.strategy);
        }
        if !self.creator_job_id.is_empty() {
            my_size += ::protobuf::rt::bytes_size(5, &self.creator_job_id);
        }
        if !self.creator_actor_id.is_empty() {
            my_size += ::protobuf::rt::bytes_size(6, &self.creator_actor_id);
        }
        if self.creator_job_dead != false {
            my_size += 2;
        }
        if self.creator_actor_dead != false {
            my_size += 2;
        }
        if self.is_detached != false {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.placement_group_id.is_empty() {
            os.write_bytes(1, &self.placement_group_id)?;
        }
        if !self.name.is_empty() {
            os.write_string(2, &self.name)?;
        }
        for v in &self.bundles {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if self.strategy != PlacementStrategy::PACK {
            os.write_enum(4, ::protobuf::ProtobufEnum::value(&self.strategy))?;
        }
        if !self.creator_job_id.is_empty() {
            os.write_bytes(5, &self.creator_job_id)?;
        }
        if !self.creator_actor_id.is_empty() {
            os.write_bytes(6, &self.creator_actor_id)?;
        }
        if self.creator_job_dead != false {
            os.write_bool(7, self.creator_job_dead)?;
        }
        if self.creator_actor_dead != false {
            os.write_bool(8, self.creator_actor_dead)?;
        }
        if self.is_detached != false {
            os.write_bool(9, self.is_detached)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PlacementGroupSpec {
        PlacementGroupSpec::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "placement_group_id",
                |m: &PlacementGroupSpec| { &m.placement_group_id },
                |m: &mut PlacementGroupSpec| { &mut m.placement_group_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "name",
                |m: &PlacementGroupSpec| { &m.name },
                |m: &mut PlacementGroupSpec| { &mut m.name },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Bundle>>(
                "bundles",
                |m: &PlacementGroupSpec| { &m.bundles },
                |m: &mut PlacementGroupSpec| { &mut m.bundles },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<PlacementStrategy>>(
                "strategy",
                |m: &PlacementGroupSpec| { &m.strategy },
                |m: &mut PlacementGroupSpec| { &mut m.strategy },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "creator_job_id",
                |m: &PlacementGroupSpec| { &m.creator_job_id },
                |m: &mut PlacementGroupSpec| { &mut m.creator_job_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "creator_actor_id",
                |m: &PlacementGroupSpec| { &m.creator_actor_id },
                |m: &mut PlacementGroupSpec| { &mut m.creator_actor_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "creator_job_dead",
                |m: &PlacementGroupSpec| { &m.creator_job_dead },
                |m: &mut PlacementGroupSpec| { &mut m.creator_job_dead },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "creator_actor_dead",
                |m: &PlacementGroupSpec| { &m.creator_actor_dead },
                |m: &mut PlacementGroupSpec| { &mut m.creator_actor_dead },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "is_detached",
                |m: &PlacementGroupSpec| { &m.is_detached },
                |m: &mut PlacementGroupSpec| { &mut m.is_detached },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<PlacementGroupSpec>(
                "PlacementGroupSpec",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static PlacementGroupSpec {
        static instance: ::protobuf::rt::LazyV2<PlacementGroupSpec> = ::protobuf::rt::LazyV2::INIT;
        instance.get(PlacementGroupSpec::new)
    }
}

impl ::protobuf::Clear for PlacementGroupSpec {
    fn clear(&mut self) {
        self.placement_group_id.clear();
        self.name.clear();
        self.bundles.clear();
        self.strategy = PlacementStrategy::PACK;
        self.creator_job_id.clear();
        self.creator_actor_id.clear();
        self.creator_job_dead = false;
        self.creator_actor_dead = false;
        self.is_detached = false;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PlacementGroupSpec {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PlacementGroupSpec {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ObjectReference {
    // message fields
    pub object_id: ::std::vec::Vec<u8>,
    pub owner_address: ::protobuf::SingularPtrField<Address>,
    pub call_site: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ObjectReference {
    fn default() -> &'a ObjectReference {
        <ObjectReference as ::protobuf::Message>::default_instance()
    }
}

impl ObjectReference {
    pub fn new() -> ObjectReference {
        ::std::default::Default::default()
    }

    // bytes object_id = 1;


    pub fn get_object_id(&self) -> &[u8] {
        &self.object_id
    }
    pub fn clear_object_id(&mut self) {
        self.object_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_object_id(&mut self, v: ::std::vec::Vec<u8>) {
        self.object_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_object_id(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.object_id
    }

    // Take field
    pub fn take_object_id(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.object_id, ::std::vec::Vec::new())
    }

    // .ray.rpc.Address owner_address = 2;


    pub fn get_owner_address(&self) -> &Address {
        self.owner_address.as_ref().unwrap_or_else(|| <Address as ::protobuf::Message>::default_instance())
    }
    pub fn clear_owner_address(&mut self) {
        self.owner_address.clear();
    }

    pub fn has_owner_address(&self) -> bool {
        self.owner_address.is_some()
    }

    // Param is passed by value, moved
    pub fn set_owner_address(&mut self, v: Address) {
        self.owner_address = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_owner_address(&mut self) -> &mut Address {
        if self.owner_address.is_none() {
            self.owner_address.set_default();
        }
        self.owner_address.as_mut().unwrap()
    }

    // Take field
    pub fn take_owner_address(&mut self) -> Address {
        self.owner_address.take().unwrap_or_else(|| Address::new())
    }

    // string call_site = 3;


    pub fn get_call_site(&self) -> &str {
        &self.call_site
    }
    pub fn clear_call_site(&mut self) {
        self.call_site.clear();
    }

    // Param is passed by value, moved
    pub fn set_call_site(&mut self, v: ::std::string::String) {
        self.call_site = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_call_site(&mut self) -> &mut ::std::string::String {
        &mut self.call_site
    }

    // Take field
    pub fn take_call_site(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.call_site, ::std::string::String::new())
    }
}

impl ::protobuf::Message for ObjectReference {
    fn is_initialized(&self) -> bool {
        for v in &self.owner_address {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.object_id)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.owner_address)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.call_site)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.object_id.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.object_id);
        }
        if let Some(ref v) = self.owner_address.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.call_site.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.call_site);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.object_id.is_empty() {
            os.write_bytes(1, &self.object_id)?;
        }
        if let Some(ref v) = self.owner_address.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.call_site.is_empty() {
            os.write_string(3, &self.call_site)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ObjectReference {
        ObjectReference::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "object_id",
                |m: &ObjectReference| { &m.object_id },
                |m: &mut ObjectReference| { &mut m.object_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Address>>(
                "owner_address",
                |m: &ObjectReference| { &m.owner_address },
                |m: &mut ObjectReference| { &mut m.owner_address },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "call_site",
                |m: &ObjectReference| { &m.call_site },
                |m: &mut ObjectReference| { &mut m.call_site },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ObjectReference>(
                "ObjectReference",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ObjectReference {
        static instance: ::protobuf::rt::LazyV2<ObjectReference> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ObjectReference::new)
    }
}

impl ::protobuf::Clear for ObjectReference {
    fn clear(&mut self) {
        self.object_id.clear();
        self.owner_address.clear();
        self.call_site.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ObjectReference {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ObjectReference {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ObjectReferenceCount {
    // message fields
    pub reference: ::protobuf::SingularPtrField<ObjectReference>,
    pub has_local_ref: bool,
    pub borrowers: ::protobuf::RepeatedField<Address>,
    pub stored_in_objects: ::protobuf::RepeatedField<ObjectReference>,
    pub contained_in_borrowed_ids: ::protobuf::RepeatedField<::std::vec::Vec<u8>>,
    pub contains: ::protobuf::RepeatedField<::std::vec::Vec<u8>>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ObjectReferenceCount {
    fn default() -> &'a ObjectReferenceCount {
        <ObjectReferenceCount as ::protobuf::Message>::default_instance()
    }
}

impl ObjectReferenceCount {
    pub fn new() -> ObjectReferenceCount {
        ::std::default::Default::default()
    }

    // .ray.rpc.ObjectReference reference = 1;


    pub fn get_reference(&self) -> &ObjectReference {
        self.reference.as_ref().unwrap_or_else(|| <ObjectReference as ::protobuf::Message>::default_instance())
    }
    pub fn clear_reference(&mut self) {
        self.reference.clear();
    }

    pub fn has_reference(&self) -> bool {
        self.reference.is_some()
    }

    // Param is passed by value, moved
    pub fn set_reference(&mut self, v: ObjectReference) {
        self.reference = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_reference(&mut self) -> &mut ObjectReference {
        if self.reference.is_none() {
            self.reference.set_default();
        }
        self.reference.as_mut().unwrap()
    }

    // Take field
    pub fn take_reference(&mut self) -> ObjectReference {
        self.reference.take().unwrap_or_else(|| ObjectReference::new())
    }

    // bool has_local_ref = 2;


    pub fn get_has_local_ref(&self) -> bool {
        self.has_local_ref
    }
    pub fn clear_has_local_ref(&mut self) {
        self.has_local_ref = false;
    }

    // Param is passed by value, moved
    pub fn set_has_local_ref(&mut self, v: bool) {
        self.has_local_ref = v;
    }

    // repeated .ray.rpc.Address borrowers = 3;


    pub fn get_borrowers(&self) -> &[Address] {
        &self.borrowers
    }
    pub fn clear_borrowers(&mut self) {
        self.borrowers.clear();
    }

    // Param is passed by value, moved
    pub fn set_borrowers(&mut self, v: ::protobuf::RepeatedField<Address>) {
        self.borrowers = v;
    }

    // Mutable pointer to the field.
    pub fn mut_borrowers(&mut self) -> &mut ::protobuf::RepeatedField<Address> {
        &mut self.borrowers
    }

    // Take field
    pub fn take_borrowers(&mut self) -> ::protobuf::RepeatedField<Address> {
        ::std::mem::replace(&mut self.borrowers, ::protobuf::RepeatedField::new())
    }

    // repeated .ray.rpc.ObjectReference stored_in_objects = 4;


    pub fn get_stored_in_objects(&self) -> &[ObjectReference] {
        &self.stored_in_objects
    }
    pub fn clear_stored_in_objects(&mut self) {
        self.stored_in_objects.clear();
    }

    // Param is passed by value, moved
    pub fn set_stored_in_objects(&mut self, v: ::protobuf::RepeatedField<ObjectReference>) {
        self.stored_in_objects = v;
    }

    // Mutable pointer to the field.
    pub fn mut_stored_in_objects(&mut self) -> &mut ::protobuf::RepeatedField<ObjectReference> {
        &mut self.stored_in_objects
    }

    // Take field
    pub fn take_stored_in_objects(&mut self) -> ::protobuf::RepeatedField<ObjectReference> {
        ::std::mem::replace(&mut self.stored_in_objects, ::protobuf::RepeatedField::new())
    }

    // repeated bytes contained_in_borrowed_ids = 5;


    pub fn get_contained_in_borrowed_ids(&self) -> &[::std::vec::Vec<u8>] {
        &self.contained_in_borrowed_ids
    }
    pub fn clear_contained_in_borrowed_ids(&mut self) {
        self.contained_in_borrowed_ids.clear();
    }

    // Param is passed by value, moved
    pub fn set_contained_in_borrowed_ids(&mut self, v: ::protobuf::RepeatedField<::std::vec::Vec<u8>>) {
        self.contained_in_borrowed_ids = v;
    }

    // Mutable pointer to the field.
    pub fn mut_contained_in_borrowed_ids(&mut self) -> &mut ::protobuf::RepeatedField<::std::vec::Vec<u8>> {
        &mut self.contained_in_borrowed_ids
    }

    // Take field
    pub fn take_contained_in_borrowed_ids(&mut self) -> ::protobuf::RepeatedField<::std::vec::Vec<u8>> {
        ::std::mem::replace(&mut self.contained_in_borrowed_ids, ::protobuf::RepeatedField::new())
    }

    // repeated bytes contains = 6;


    pub fn get_contains(&self) -> &[::std::vec::Vec<u8>] {
        &self.contains
    }
    pub fn clear_contains(&mut self) {
        self.contains.clear();
    }

    // Param is passed by value, moved
    pub fn set_contains(&mut self, v: ::protobuf::RepeatedField<::std::vec::Vec<u8>>) {
        self.contains = v;
    }

    // Mutable pointer to the field.
    pub fn mut_contains(&mut self) -> &mut ::protobuf::RepeatedField<::std::vec::Vec<u8>> {
        &mut self.contains
    }

    // Take field
    pub fn take_contains(&mut self) -> ::protobuf::RepeatedField<::std::vec::Vec<u8>> {
        ::std::mem::replace(&mut self.contains, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for ObjectReferenceCount {
    fn is_initialized(&self) -> bool {
        for v in &self.reference {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.borrowers {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.stored_in_objects {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.reference)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.has_local_ref = tmp;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.borrowers)?;
                },
                4 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.stored_in_objects)?;
                },
                5 => {
                    ::protobuf::rt::read_repeated_bytes_into(wire_type, is, &mut self.contained_in_borrowed_ids)?;
                },
                6 => {
                    ::protobuf::rt::read_repeated_bytes_into(wire_type, is, &mut self.contains)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.reference.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.has_local_ref != false {
            my_size += 2;
        }
        for value in &self.borrowers {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.stored_in_objects {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.contained_in_borrowed_ids {
            my_size += ::protobuf::rt::bytes_size(5, &value);
        };
        for value in &self.contains {
            my_size += ::protobuf::rt::bytes_size(6, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.reference.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.has_local_ref != false {
            os.write_bool(2, self.has_local_ref)?;
        }
        for v in &self.borrowers {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.stored_in_objects {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.contained_in_borrowed_ids {
            os.write_bytes(5, &v)?;
        };
        for v in &self.contains {
            os.write_bytes(6, &v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ObjectReferenceCount {
        ObjectReferenceCount::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ObjectReference>>(
                "reference",
                |m: &ObjectReferenceCount| { &m.reference },
                |m: &mut ObjectReferenceCount| { &mut m.reference },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "has_local_ref",
                |m: &ObjectReferenceCount| { &m.has_local_ref },
                |m: &mut ObjectReferenceCount| { &mut m.has_local_ref },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Address>>(
                "borrowers",
                |m: &ObjectReferenceCount| { &m.borrowers },
                |m: &mut ObjectReferenceCount| { &mut m.borrowers },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ObjectReference>>(
                "stored_in_objects",
                |m: &ObjectReferenceCount| { &m.stored_in_objects },
                |m: &mut ObjectReferenceCount| { &mut m.stored_in_objects },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "contained_in_borrowed_ids",
                |m: &ObjectReferenceCount| { &m.contained_in_borrowed_ids },
                |m: &mut ObjectReferenceCount| { &mut m.contained_in_borrowed_ids },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "contains",
                |m: &ObjectReferenceCount| { &m.contains },
                |m: &mut ObjectReferenceCount| { &mut m.contains },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ObjectReferenceCount>(
                "ObjectReferenceCount",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ObjectReferenceCount {
        static instance: ::protobuf::rt::LazyV2<ObjectReferenceCount> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ObjectReferenceCount::new)
    }
}

impl ::protobuf::Clear for ObjectReferenceCount {
    fn clear(&mut self) {
        self.reference.clear();
        self.has_local_ref = false;
        self.borrowers.clear();
        self.stored_in_objects.clear();
        self.contained_in_borrowed_ids.clear();
        self.contains.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ObjectReferenceCount {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ObjectReferenceCount {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct TaskArg {
    // message fields
    pub object_ref: ::protobuf::SingularPtrField<ObjectReference>,
    pub data: ::std::vec::Vec<u8>,
    pub metadata: ::std::vec::Vec<u8>,
    pub nested_inlined_refs: ::protobuf::RepeatedField<ObjectReference>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a TaskArg {
    fn default() -> &'a TaskArg {
        <TaskArg as ::protobuf::Message>::default_instance()
    }
}

impl TaskArg {
    pub fn new() -> TaskArg {
        ::std::default::Default::default()
    }

    // .ray.rpc.ObjectReference object_ref = 1;


    pub fn get_object_ref(&self) -> &ObjectReference {
        self.object_ref.as_ref().unwrap_or_else(|| <ObjectReference as ::protobuf::Message>::default_instance())
    }
    pub fn clear_object_ref(&mut self) {
        self.object_ref.clear();
    }

    pub fn has_object_ref(&self) -> bool {
        self.object_ref.is_some()
    }

    // Param is passed by value, moved
    pub fn set_object_ref(&mut self, v: ObjectReference) {
        self.object_ref = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_object_ref(&mut self) -> &mut ObjectReference {
        if self.object_ref.is_none() {
            self.object_ref.set_default();
        }
        self.object_ref.as_mut().unwrap()
    }

    // Take field
    pub fn take_object_ref(&mut self) -> ObjectReference {
        self.object_ref.take().unwrap_or_else(|| ObjectReference::new())
    }

    // bytes data = 2;


    pub fn get_data(&self) -> &[u8] {
        &self.data
    }
    pub fn clear_data(&mut self) {
        self.data.clear();
    }

    // Param is passed by value, moved
    pub fn set_data(&mut self, v: ::std::vec::Vec<u8>) {
        self.data = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_data(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.data
    }

    // Take field
    pub fn take_data(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.data, ::std::vec::Vec::new())
    }

    // bytes metadata = 3;


    pub fn get_metadata(&self) -> &[u8] {
        &self.metadata
    }
    pub fn clear_metadata(&mut self) {
        self.metadata.clear();
    }

    // Param is passed by value, moved
    pub fn set_metadata(&mut self, v: ::std::vec::Vec<u8>) {
        self.metadata = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_metadata(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.metadata
    }

    // Take field
    pub fn take_metadata(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.metadata, ::std::vec::Vec::new())
    }

    // repeated .ray.rpc.ObjectReference nested_inlined_refs = 4;


    pub fn get_nested_inlined_refs(&self) -> &[ObjectReference] {
        &self.nested_inlined_refs
    }
    pub fn clear_nested_inlined_refs(&mut self) {
        self.nested_inlined_refs.clear();
    }

    // Param is passed by value, moved
    pub fn set_nested_inlined_refs(&mut self, v: ::protobuf::RepeatedField<ObjectReference>) {
        self.nested_inlined_refs = v;
    }

    // Mutable pointer to the field.
    pub fn mut_nested_inlined_refs(&mut self) -> &mut ::protobuf::RepeatedField<ObjectReference> {
        &mut self.nested_inlined_refs
    }

    // Take field
    pub fn take_nested_inlined_refs(&mut self) -> ::protobuf::RepeatedField<ObjectReference> {
        ::std::mem::replace(&mut self.nested_inlined_refs, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for TaskArg {
    fn is_initialized(&self) -> bool {
        for v in &self.object_ref {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.nested_inlined_refs {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.object_ref)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.data)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.metadata)?;
                },
                4 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.nested_inlined_refs)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.object_ref.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.data.is_empty() {
            my_size += ::protobuf::rt::bytes_size(2, &self.data);
        }
        if !self.metadata.is_empty() {
            my_size += ::protobuf::rt::bytes_size(3, &self.metadata);
        }
        for value in &self.nested_inlined_refs {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.object_ref.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.data.is_empty() {
            os.write_bytes(2, &self.data)?;
        }
        if !self.metadata.is_empty() {
            os.write_bytes(3, &self.metadata)?;
        }
        for v in &self.nested_inlined_refs {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> TaskArg {
        TaskArg::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ObjectReference>>(
                "object_ref",
                |m: &TaskArg| { &m.object_ref },
                |m: &mut TaskArg| { &mut m.object_ref },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "data",
                |m: &TaskArg| { &m.data },
                |m: &mut TaskArg| { &mut m.data },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "metadata",
                |m: &TaskArg| { &m.metadata },
                |m: &mut TaskArg| { &mut m.metadata },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ObjectReference>>(
                "nested_inlined_refs",
                |m: &TaskArg| { &m.nested_inlined_refs },
                |m: &mut TaskArg| { &mut m.nested_inlined_refs },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<TaskArg>(
                "TaskArg",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static TaskArg {
        static instance: ::protobuf::rt::LazyV2<TaskArg> = ::protobuf::rt::LazyV2::INIT;
        instance.get(TaskArg::new)
    }
}

impl ::protobuf::Clear for TaskArg {
    fn clear(&mut self) {
        self.object_ref.clear();
        self.data.clear();
        self.metadata.clear();
        self.nested_inlined_refs.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for TaskArg {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TaskArg {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ActorCreationTaskSpec {
    // message fields
    pub actor_id: ::std::vec::Vec<u8>,
    pub max_actor_restarts: i64,
    pub max_task_retries: i64,
    pub dynamic_worker_options: ::protobuf::RepeatedField<::std::string::String>,
    pub max_concurrency: i32,
    pub is_detached: bool,
    pub name: ::std::string::String,
    pub ray_namespace: ::std::string::String,
    pub is_asyncio: bool,
    pub extension_data: ::std::string::String,
    pub serialized_actor_handle: ::std::vec::Vec<u8>,
    pub concurrency_groups: ::protobuf::RepeatedField<ConcurrencyGroup>,
    pub execute_out_of_order: bool,
    pub max_pending_calls: i32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ActorCreationTaskSpec {
    fn default() -> &'a ActorCreationTaskSpec {
        <ActorCreationTaskSpec as ::protobuf::Message>::default_instance()
    }
}

impl ActorCreationTaskSpec {
    pub fn new() -> ActorCreationTaskSpec {
        ::std::default::Default::default()
    }

    // bytes actor_id = 2;


    pub fn get_actor_id(&self) -> &[u8] {
        &self.actor_id
    }
    pub fn clear_actor_id(&mut self) {
        self.actor_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_actor_id(&mut self, v: ::std::vec::Vec<u8>) {
        self.actor_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_actor_id(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.actor_id
    }

    // Take field
    pub fn take_actor_id(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.actor_id, ::std::vec::Vec::new())
    }

    // int64 max_actor_restarts = 3;


    pub fn get_max_actor_restarts(&self) -> i64 {
        self.max_actor_restarts
    }
    pub fn clear_max_actor_restarts(&mut self) {
        self.max_actor_restarts = 0;
    }

    // Param is passed by value, moved
    pub fn set_max_actor_restarts(&mut self, v: i64) {
        self.max_actor_restarts = v;
    }

    // int64 max_task_retries = 4;


    pub fn get_max_task_retries(&self) -> i64 {
        self.max_task_retries
    }
    pub fn clear_max_task_retries(&mut self) {
        self.max_task_retries = 0;
    }

    // Param is passed by value, moved
    pub fn set_max_task_retries(&mut self, v: i64) {
        self.max_task_retries = v;
    }

    // repeated string dynamic_worker_options = 5;


    pub fn get_dynamic_worker_options(&self) -> &[::std::string::String] {
        &self.dynamic_worker_options
    }
    pub fn clear_dynamic_worker_options(&mut self) {
        self.dynamic_worker_options.clear();
    }

    // Param is passed by value, moved
    pub fn set_dynamic_worker_options(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.dynamic_worker_options = v;
    }

    // Mutable pointer to the field.
    pub fn mut_dynamic_worker_options(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.dynamic_worker_options
    }

    // Take field
    pub fn take_dynamic_worker_options(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.dynamic_worker_options, ::protobuf::RepeatedField::new())
    }

    // int32 max_concurrency = 6;


    pub fn get_max_concurrency(&self) -> i32 {
        self.max_concurrency
    }
    pub fn clear_max_concurrency(&mut self) {
        self.max_concurrency = 0;
    }

    // Param is passed by value, moved
    pub fn set_max_concurrency(&mut self, v: i32) {
        self.max_concurrency = v;
    }

    // bool is_detached = 7;


    pub fn get_is_detached(&self) -> bool {
        self.is_detached
    }
    pub fn clear_is_detached(&mut self) {
        self.is_detached = false;
    }

    // Param is passed by value, moved
    pub fn set_is_detached(&mut self, v: bool) {
        self.is_detached = v;
    }

    // string name = 8;


    pub fn get_name(&self) -> &str {
        &self.name
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        &mut self.name
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.name, ::std::string::String::new())
    }

    // string ray_namespace = 9;


    pub fn get_ray_namespace(&self) -> &str {
        &self.ray_namespace
    }
    pub fn clear_ray_namespace(&mut self) {
        self.ray_namespace.clear();
    }

    // Param is passed by value, moved
    pub fn set_ray_namespace(&mut self, v: ::std::string::String) {
        self.ray_namespace = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_ray_namespace(&mut self) -> &mut ::std::string::String {
        &mut self.ray_namespace
    }

    // Take field
    pub fn take_ray_namespace(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.ray_namespace, ::std::string::String::new())
    }

    // bool is_asyncio = 10;


    pub fn get_is_asyncio(&self) -> bool {
        self.is_asyncio
    }
    pub fn clear_is_asyncio(&mut self) {
        self.is_asyncio = false;
    }

    // Param is passed by value, moved
    pub fn set_is_asyncio(&mut self, v: bool) {
        self.is_asyncio = v;
    }

    // string extension_data = 11;


    pub fn get_extension_data(&self) -> &str {
        &self.extension_data
    }
    pub fn clear_extension_data(&mut self) {
        self.extension_data.clear();
    }

    // Param is passed by value, moved
    pub fn set_extension_data(&mut self, v: ::std::string::String) {
        self.extension_data = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_extension_data(&mut self) -> &mut ::std::string::String {
        &mut self.extension_data
    }

    // Take field
    pub fn take_extension_data(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.extension_data, ::std::string::String::new())
    }

    // bytes serialized_actor_handle = 12;


    pub fn get_serialized_actor_handle(&self) -> &[u8] {
        &self.serialized_actor_handle
    }
    pub fn clear_serialized_actor_handle(&mut self) {
        self.serialized_actor_handle.clear();
    }

    // Param is passed by value, moved
    pub fn set_serialized_actor_handle(&mut self, v: ::std::vec::Vec<u8>) {
        self.serialized_actor_handle = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_serialized_actor_handle(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.serialized_actor_handle
    }

    // Take field
    pub fn take_serialized_actor_handle(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.serialized_actor_handle, ::std::vec::Vec::new())
    }

    // repeated .ray.rpc.ConcurrencyGroup concurrency_groups = 13;


    pub fn get_concurrency_groups(&self) -> &[ConcurrencyGroup] {
        &self.concurrency_groups
    }
    pub fn clear_concurrency_groups(&mut self) {
        self.concurrency_groups.clear();
    }

    // Param is passed by value, moved
    pub fn set_concurrency_groups(&mut self, v: ::protobuf::RepeatedField<ConcurrencyGroup>) {
        self.concurrency_groups = v;
    }

    // Mutable pointer to the field.
    pub fn mut_concurrency_groups(&mut self) -> &mut ::protobuf::RepeatedField<ConcurrencyGroup> {
        &mut self.concurrency_groups
    }

    // Take field
    pub fn take_concurrency_groups(&mut self) -> ::protobuf::RepeatedField<ConcurrencyGroup> {
        ::std::mem::replace(&mut self.concurrency_groups, ::protobuf::RepeatedField::new())
    }

    // bool execute_out_of_order = 14;


    pub fn get_execute_out_of_order(&self) -> bool {
        self.execute_out_of_order
    }
    pub fn clear_execute_out_of_order(&mut self) {
        self.execute_out_of_order = false;
    }

    // Param is passed by value, moved
    pub fn set_execute_out_of_order(&mut self, v: bool) {
        self.execute_out_of_order = v;
    }

    // int32 max_pending_calls = 15;


    pub fn get_max_pending_calls(&self) -> i32 {
        self.max_pending_calls
    }
    pub fn clear_max_pending_calls(&mut self) {
        self.max_pending_calls = 0;
    }

    // Param is passed by value, moved
    pub fn set_max_pending_calls(&mut self, v: i32) {
        self.max_pending_calls = v;
    }
}

impl ::protobuf::Message for ActorCreationTaskSpec {
    fn is_initialized(&self) -> bool {
        for v in &self.concurrency_groups {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                2 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.actor_id)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.max_actor_restarts = tmp;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.max_task_retries = tmp;
                },
                5 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.dynamic_worker_options)?;
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.max_concurrency = tmp;
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.is_detached = tmp;
                },
                8 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.name)?;
                },
                9 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.ray_namespace)?;
                },
                10 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.is_asyncio = tmp;
                },
                11 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.extension_data)?;
                },
                12 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.serialized_actor_handle)?;
                },
                13 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.concurrency_groups)?;
                },
                14 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.execute_out_of_order = tmp;
                },
                15 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.max_pending_calls = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.actor_id.is_empty() {
            my_size += ::protobuf::rt::bytes_size(2, &self.actor_id);
        }
        if self.max_actor_restarts != 0 {
            my_size += ::protobuf::rt::value_size(3, self.max_actor_restarts, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.max_task_retries != 0 {
            my_size += ::protobuf::rt::value_size(4, self.max_task_retries, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.dynamic_worker_options {
            my_size += ::protobuf::rt::string_size(5, &value);
        };
        if self.max_concurrency != 0 {
            my_size += ::protobuf::rt::value_size(6, self.max_concurrency, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.is_detached != false {
            my_size += 2;
        }
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(8, &self.name);
        }
        if !self.ray_namespace.is_empty() {
            my_size += ::protobuf::rt::string_size(9, &self.ray_namespace);
        }
        if self.is_asyncio != false {
            my_size += 2;
        }
        if !self.extension_data.is_empty() {
            my_size += ::protobuf::rt::string_size(11, &self.extension_data);
        }
        if !self.serialized_actor_handle.is_empty() {
            my_size += ::protobuf::rt::bytes_size(12, &self.serialized_actor_handle);
        }
        for value in &self.concurrency_groups {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if self.execute_out_of_order != false {
            my_size += 2;
        }
        if self.max_pending_calls != 0 {
            my_size += ::protobuf::rt::value_size(15, self.max_pending_calls, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.actor_id.is_empty() {
            os.write_bytes(2, &self.actor_id)?;
        }
        if self.max_actor_restarts != 0 {
            os.write_int64(3, self.max_actor_restarts)?;
        }
        if self.max_task_retries != 0 {
            os.write_int64(4, self.max_task_retries)?;
        }
        for v in &self.dynamic_worker_options {
            os.write_string(5, &v)?;
        };
        if self.max_concurrency != 0 {
            os.write_int32(6, self.max_concurrency)?;
        }
        if self.is_detached != false {
            os.write_bool(7, self.is_detached)?;
        }
        if !self.name.is_empty() {
            os.write_string(8, &self.name)?;
        }
        if !self.ray_namespace.is_empty() {
            os.write_string(9, &self.ray_namespace)?;
        }
        if self.is_asyncio != false {
            os.write_bool(10, self.is_asyncio)?;
        }
        if !self.extension_data.is_empty() {
            os.write_string(11, &self.extension_data)?;
        }
        if !self.serialized_actor_handle.is_empty() {
            os.write_bytes(12, &self.serialized_actor_handle)?;
        }
        for v in &self.concurrency_groups {
            os.write_tag(13, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if self.execute_out_of_order != false {
            os.write_bool(14, self.execute_out_of_order)?;
        }
        if self.max_pending_calls != 0 {
            os.write_int32(15, self.max_pending_calls)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ActorCreationTaskSpec {
        ActorCreationTaskSpec::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "actor_id",
                |m: &ActorCreationTaskSpec| { &m.actor_id },
                |m: &mut ActorCreationTaskSpec| { &mut m.actor_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "max_actor_restarts",
                |m: &ActorCreationTaskSpec| { &m.max_actor_restarts },
                |m: &mut ActorCreationTaskSpec| { &mut m.max_actor_restarts },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "max_task_retries",
                |m: &ActorCreationTaskSpec| { &m.max_task_retries },
                |m: &mut ActorCreationTaskSpec| { &mut m.max_task_retries },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "dynamic_worker_options",
                |m: &ActorCreationTaskSpec| { &m.dynamic_worker_options },
                |m: &mut ActorCreationTaskSpec| { &mut m.dynamic_worker_options },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "max_concurrency",
                |m: &ActorCreationTaskSpec| { &m.max_concurrency },
                |m: &mut ActorCreationTaskSpec| { &mut m.max_concurrency },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "is_detached",
                |m: &ActorCreationTaskSpec| { &m.is_detached },
                |m: &mut ActorCreationTaskSpec| { &mut m.is_detached },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "name",
                |m: &ActorCreationTaskSpec| { &m.name },
                |m: &mut ActorCreationTaskSpec| { &mut m.name },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "ray_namespace",
                |m: &ActorCreationTaskSpec| { &m.ray_namespace },
                |m: &mut ActorCreationTaskSpec| { &mut m.ray_namespace },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "is_asyncio",
                |m: &ActorCreationTaskSpec| { &m.is_asyncio },
                |m: &mut ActorCreationTaskSpec| { &mut m.is_asyncio },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "extension_data",
                |m: &ActorCreationTaskSpec| { &m.extension_data },
                |m: &mut ActorCreationTaskSpec| { &mut m.extension_data },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "serialized_actor_handle",
                |m: &ActorCreationTaskSpec| { &m.serialized_actor_handle },
                |m: &mut ActorCreationTaskSpec| { &mut m.serialized_actor_handle },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ConcurrencyGroup>>(
                "concurrency_groups",
                |m: &ActorCreationTaskSpec| { &m.concurrency_groups },
                |m: &mut ActorCreationTaskSpec| { &mut m.concurrency_groups },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "execute_out_of_order",
                |m: &ActorCreationTaskSpec| { &m.execute_out_of_order },
                |m: &mut ActorCreationTaskSpec| { &mut m.execute_out_of_order },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "max_pending_calls",
                |m: &ActorCreationTaskSpec| { &m.max_pending_calls },
                |m: &mut ActorCreationTaskSpec| { &mut m.max_pending_calls },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ActorCreationTaskSpec>(
                "ActorCreationTaskSpec",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ActorCreationTaskSpec {
        static instance: ::protobuf::rt::LazyV2<ActorCreationTaskSpec> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ActorCreationTaskSpec::new)
    }
}

impl ::protobuf::Clear for ActorCreationTaskSpec {
    fn clear(&mut self) {
        self.actor_id.clear();
        self.max_actor_restarts = 0;
        self.max_task_retries = 0;
        self.dynamic_worker_options.clear();
        self.max_concurrency = 0;
        self.is_detached = false;
        self.name.clear();
        self.ray_namespace.clear();
        self.is_asyncio = false;
        self.extension_data.clear();
        self.serialized_actor_handle.clear();
        self.concurrency_groups.clear();
        self.execute_out_of_order = false;
        self.max_pending_calls = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ActorCreationTaskSpec {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ActorCreationTaskSpec {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ActorTaskSpec {
    // message fields
    pub actor_id: ::std::vec::Vec<u8>,
    pub actor_creation_dummy_object_id: ::std::vec::Vec<u8>,
    pub actor_counter: u64,
    pub previous_actor_task_dummy_object_id: ::std::vec::Vec<u8>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ActorTaskSpec {
    fn default() -> &'a ActorTaskSpec {
        <ActorTaskSpec as ::protobuf::Message>::default_instance()
    }
}

impl ActorTaskSpec {
    pub fn new() -> ActorTaskSpec {
        ::std::default::Default::default()
    }

    // bytes actor_id = 2;


    pub fn get_actor_id(&self) -> &[u8] {
        &self.actor_id
    }
    pub fn clear_actor_id(&mut self) {
        self.actor_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_actor_id(&mut self, v: ::std::vec::Vec<u8>) {
        self.actor_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_actor_id(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.actor_id
    }

    // Take field
    pub fn take_actor_id(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.actor_id, ::std::vec::Vec::new())
    }

    // bytes actor_creation_dummy_object_id = 4;


    pub fn get_actor_creation_dummy_object_id(&self) -> &[u8] {
        &self.actor_creation_dummy_object_id
    }
    pub fn clear_actor_creation_dummy_object_id(&mut self) {
        self.actor_creation_dummy_object_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_actor_creation_dummy_object_id(&mut self, v: ::std::vec::Vec<u8>) {
        self.actor_creation_dummy_object_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_actor_creation_dummy_object_id(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.actor_creation_dummy_object_id
    }

    // Take field
    pub fn take_actor_creation_dummy_object_id(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.actor_creation_dummy_object_id, ::std::vec::Vec::new())
    }

    // uint64 actor_counter = 5;


    pub fn get_actor_counter(&self) -> u64 {
        self.actor_counter
    }
    pub fn clear_actor_counter(&mut self) {
        self.actor_counter = 0;
    }

    // Param is passed by value, moved
    pub fn set_actor_counter(&mut self, v: u64) {
        self.actor_counter = v;
    }

    // bytes previous_actor_task_dummy_object_id = 7;


    pub fn get_previous_actor_task_dummy_object_id(&self) -> &[u8] {
        &self.previous_actor_task_dummy_object_id
    }
    pub fn clear_previous_actor_task_dummy_object_id(&mut self) {
        self.previous_actor_task_dummy_object_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_previous_actor_task_dummy_object_id(&mut self, v: ::std::vec::Vec<u8>) {
        self.previous_actor_task_dummy_object_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_previous_actor_task_dummy_object_id(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.previous_actor_task_dummy_object_id
    }

    // Take field
    pub fn take_previous_actor_task_dummy_object_id(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.previous_actor_task_dummy_object_id, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for ActorTaskSpec {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                2 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.actor_id)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.actor_creation_dummy_object_id)?;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.actor_counter = tmp;
                },
                7 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.previous_actor_task_dummy_object_id)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.actor_id.is_empty() {
            my_size += ::protobuf::rt::bytes_size(2, &self.actor_id);
        }
        if !self.actor_creation_dummy_object_id.is_empty() {
            my_size += ::protobuf::rt::bytes_size(4, &self.actor_creation_dummy_object_id);
        }
        if self.actor_counter != 0 {
            my_size += ::protobuf::rt::value_size(5, self.actor_counter, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.previous_actor_task_dummy_object_id.is_empty() {
            my_size += ::protobuf::rt::bytes_size(7, &self.previous_actor_task_dummy_object_id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.actor_id.is_empty() {
            os.write_bytes(2, &self.actor_id)?;
        }
        if !self.actor_creation_dummy_object_id.is_empty() {
            os.write_bytes(4, &self.actor_creation_dummy_object_id)?;
        }
        if self.actor_counter != 0 {
            os.write_uint64(5, self.actor_counter)?;
        }
        if !self.previous_actor_task_dummy_object_id.is_empty() {
            os.write_bytes(7, &self.previous_actor_task_dummy_object_id)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ActorTaskSpec {
        ActorTaskSpec::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "actor_id",
                |m: &ActorTaskSpec| { &m.actor_id },
                |m: &mut ActorTaskSpec| { &mut m.actor_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "actor_creation_dummy_object_id",
                |m: &ActorTaskSpec| { &m.actor_creation_dummy_object_id },
                |m: &mut ActorTaskSpec| { &mut m.actor_creation_dummy_object_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "actor_counter",
                |m: &ActorTaskSpec| { &m.actor_counter },
                |m: &mut ActorTaskSpec| { &mut m.actor_counter },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "previous_actor_task_dummy_object_id",
                |m: &ActorTaskSpec| { &m.previous_actor_task_dummy_object_id },
                |m: &mut ActorTaskSpec| { &mut m.previous_actor_task_dummy_object_id },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ActorTaskSpec>(
                "ActorTaskSpec",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ActorTaskSpec {
        static instance: ::protobuf::rt::LazyV2<ActorTaskSpec> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ActorTaskSpec::new)
    }
}

impl ::protobuf::Clear for ActorTaskSpec {
    fn clear(&mut self) {
        self.actor_id.clear();
        self.actor_creation_dummy_object_id.clear();
        self.actor_counter = 0;
        self.previous_actor_task_dummy_object_id.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ActorTaskSpec {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ActorTaskSpec {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Task {
    // message fields
    pub task_spec: ::protobuf::SingularPtrField<TaskSpec>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Task {
    fn default() -> &'a Task {
        <Task as ::protobuf::Message>::default_instance()
    }
}

impl Task {
    pub fn new() -> Task {
        ::std::default::Default::default()
    }

    // .ray.rpc.TaskSpec task_spec = 1;


    pub fn get_task_spec(&self) -> &TaskSpec {
        self.task_spec.as_ref().unwrap_or_else(|| <TaskSpec as ::protobuf::Message>::default_instance())
    }
    pub fn clear_task_spec(&mut self) {
        self.task_spec.clear();
    }

    pub fn has_task_spec(&self) -> bool {
        self.task_spec.is_some()
    }

    // Param is passed by value, moved
    pub fn set_task_spec(&mut self, v: TaskSpec) {
        self.task_spec = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_task_spec(&mut self) -> &mut TaskSpec {
        if self.task_spec.is_none() {
            self.task_spec.set_default();
        }
        self.task_spec.as_mut().unwrap()
    }

    // Take field
    pub fn take_task_spec(&mut self) -> TaskSpec {
        self.task_spec.take().unwrap_or_else(|| TaskSpec::new())
    }
}

impl ::protobuf::Message for Task {
    fn is_initialized(&self) -> bool {
        for v in &self.task_spec {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.task_spec)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.task_spec.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.task_spec.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Task {
        Task::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<TaskSpec>>(
                "task_spec",
                |m: &Task| { &m.task_spec },
                |m: &mut Task| { &mut m.task_spec },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Task>(
                "Task",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Task {
        static instance: ::protobuf::rt::LazyV2<Task> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Task::new)
    }
}

impl ::protobuf::Clear for Task {
    fn clear(&mut self) {
        self.task_spec.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Task {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Task {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ResourceId {
    // message fields
    pub index: i64,
    pub quantity: f64,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ResourceId {
    fn default() -> &'a ResourceId {
        <ResourceId as ::protobuf::Message>::default_instance()
    }
}

impl ResourceId {
    pub fn new() -> ResourceId {
        ::std::default::Default::default()
    }

    // int64 index = 1;


    pub fn get_index(&self) -> i64 {
        self.index
    }
    pub fn clear_index(&mut self) {
        self.index = 0;
    }

    // Param is passed by value, moved
    pub fn set_index(&mut self, v: i64) {
        self.index = v;
    }

    // double quantity = 2;


    pub fn get_quantity(&self) -> f64 {
        self.quantity
    }
    pub fn clear_quantity(&mut self) {
        self.quantity = 0.;
    }

    // Param is passed by value, moved
    pub fn set_quantity(&mut self, v: f64) {
        self.quantity = v;
    }
}

impl ::protobuf::Message for ResourceId {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.index = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_double()?;
                    self.quantity = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.index != 0 {
            my_size += ::protobuf::rt::value_size(1, self.index, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.quantity != 0. {
            my_size += 9;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.index != 0 {
            os.write_int64(1, self.index)?;
        }
        if self.quantity != 0. {
            os.write_double(2, self.quantity)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ResourceId {
        ResourceId::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "index",
                |m: &ResourceId| { &m.index },
                |m: &mut ResourceId| { &mut m.index },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeDouble>(
                "quantity",
                |m: &ResourceId| { &m.quantity },
                |m: &mut ResourceId| { &mut m.quantity },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ResourceId>(
                "ResourceId",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ResourceId {
        static instance: ::protobuf::rt::LazyV2<ResourceId> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ResourceId::new)
    }
}

impl ::protobuf::Clear for ResourceId {
    fn clear(&mut self) {
        self.index = 0;
        self.quantity = 0.;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ResourceId {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ResourceId {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ResourceMapEntry {
    // message fields
    pub name: ::std::string::String,
    pub resource_ids: ::protobuf::RepeatedField<ResourceId>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ResourceMapEntry {
    fn default() -> &'a ResourceMapEntry {
        <ResourceMapEntry as ::protobuf::Message>::default_instance()
    }
}

impl ResourceMapEntry {
    pub fn new() -> ResourceMapEntry {
        ::std::default::Default::default()
    }

    // string name = 1;


    pub fn get_name(&self) -> &str {
        &self.name
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        &mut self.name
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.name, ::std::string::String::new())
    }

    // repeated .ray.rpc.ResourceId resource_ids = 2;


    pub fn get_resource_ids(&self) -> &[ResourceId] {
        &self.resource_ids
    }
    pub fn clear_resource_ids(&mut self) {
        self.resource_ids.clear();
    }

    // Param is passed by value, moved
    pub fn set_resource_ids(&mut self, v: ::protobuf::RepeatedField<ResourceId>) {
        self.resource_ids = v;
    }

    // Mutable pointer to the field.
    pub fn mut_resource_ids(&mut self) -> &mut ::protobuf::RepeatedField<ResourceId> {
        &mut self.resource_ids
    }

    // Take field
    pub fn take_resource_ids(&mut self) -> ::protobuf::RepeatedField<ResourceId> {
        ::std::mem::replace(&mut self.resource_ids, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for ResourceMapEntry {
    fn is_initialized(&self) -> bool {
        for v in &self.resource_ids {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.name)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.resource_ids)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.name);
        }
        for value in &self.resource_ids {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.name.is_empty() {
            os.write_string(1, &self.name)?;
        }
        for v in &self.resource_ids {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ResourceMapEntry {
        ResourceMapEntry::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "name",
                |m: &ResourceMapEntry| { &m.name },
                |m: &mut ResourceMapEntry| { &mut m.name },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ResourceId>>(
                "resource_ids",
                |m: &ResourceMapEntry| { &m.resource_ids },
                |m: &mut ResourceMapEntry| { &mut m.resource_ids },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ResourceMapEntry>(
                "ResourceMapEntry",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ResourceMapEntry {
        static instance: ::protobuf::rt::LazyV2<ResourceMapEntry> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ResourceMapEntry::new)
    }
}

impl ::protobuf::Clear for ResourceMapEntry {
    fn clear(&mut self) {
        self.name.clear();
        self.resource_ids.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ResourceMapEntry {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ResourceMapEntry {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ViewData {
    // message fields
    pub view_name: ::std::string::String,
    pub measures: ::protobuf::RepeatedField<ViewData_Measure>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ViewData {
    fn default() -> &'a ViewData {
        <ViewData as ::protobuf::Message>::default_instance()
    }
}

impl ViewData {
    pub fn new() -> ViewData {
        ::std::default::Default::default()
    }

    // string view_name = 1;


    pub fn get_view_name(&self) -> &str {
        &self.view_name
    }
    pub fn clear_view_name(&mut self) {
        self.view_name.clear();
    }

    // Param is passed by value, moved
    pub fn set_view_name(&mut self, v: ::std::string::String) {
        self.view_name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_view_name(&mut self) -> &mut ::std::string::String {
        &mut self.view_name
    }

    // Take field
    pub fn take_view_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.view_name, ::std::string::String::new())
    }

    // repeated .ray.rpc.ViewData.Measure measures = 2;


    pub fn get_measures(&self) -> &[ViewData_Measure] {
        &self.measures
    }
    pub fn clear_measures(&mut self) {
        self.measures.clear();
    }

    // Param is passed by value, moved
    pub fn set_measures(&mut self, v: ::protobuf::RepeatedField<ViewData_Measure>) {
        self.measures = v;
    }

    // Mutable pointer to the field.
    pub fn mut_measures(&mut self) -> &mut ::protobuf::RepeatedField<ViewData_Measure> {
        &mut self.measures
    }

    // Take field
    pub fn take_measures(&mut self) -> ::protobuf::RepeatedField<ViewData_Measure> {
        ::std::mem::replace(&mut self.measures, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for ViewData {
    fn is_initialized(&self) -> bool {
        for v in &self.measures {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.view_name)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.measures)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.view_name.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.view_name);
        }
        for value in &self.measures {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.view_name.is_empty() {
            os.write_string(1, &self.view_name)?;
        }
        for v in &self.measures {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ViewData {
        ViewData::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "view_name",
                |m: &ViewData| { &m.view_name },
                |m: &mut ViewData| { &mut m.view_name },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ViewData_Measure>>(
                "measures",
                |m: &ViewData| { &m.measures },
                |m: &mut ViewData| { &mut m.measures },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ViewData>(
                "ViewData",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ViewData {
        static instance: ::protobuf::rt::LazyV2<ViewData> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ViewData::new)
    }
}

impl ::protobuf::Clear for ViewData {
    fn clear(&mut self) {
        self.view_name.clear();
        self.measures.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ViewData {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ViewData {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ViewData_Measure {
    // message fields
    pub tags: ::std::string::String,
    pub int_value: i64,
    pub double_value: f64,
    pub distribution_min: f64,
    pub distribution_mean: f64,
    pub distribution_max: f64,
    pub distribution_count: f64,
    pub distribution_bucket_boundaries: ::std::vec::Vec<f64>,
    pub distribution_bucket_counts: ::std::vec::Vec<f64>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ViewData_Measure {
    fn default() -> &'a ViewData_Measure {
        <ViewData_Measure as ::protobuf::Message>::default_instance()
    }
}

impl ViewData_Measure {
    pub fn new() -> ViewData_Measure {
        ::std::default::Default::default()
    }

    // string tags = 1;


    pub fn get_tags(&self) -> &str {
        &self.tags
    }
    pub fn clear_tags(&mut self) {
        self.tags.clear();
    }

    // Param is passed by value, moved
    pub fn set_tags(&mut self, v: ::std::string::String) {
        self.tags = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_tags(&mut self) -> &mut ::std::string::String {
        &mut self.tags
    }

    // Take field
    pub fn take_tags(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.tags, ::std::string::String::new())
    }

    // int64 int_value = 2;


    pub fn get_int_value(&self) -> i64 {
        self.int_value
    }
    pub fn clear_int_value(&mut self) {
        self.int_value = 0;
    }

    // Param is passed by value, moved
    pub fn set_int_value(&mut self, v: i64) {
        self.int_value = v;
    }

    // double double_value = 3;


    pub fn get_double_value(&self) -> f64 {
        self.double_value
    }
    pub fn clear_double_value(&mut self) {
        self.double_value = 0.;
    }

    // Param is passed by value, moved
    pub fn set_double_value(&mut self, v: f64) {
        self.double_value = v;
    }

    // double distribution_min = 4;


    pub fn get_distribution_min(&self) -> f64 {
        self.distribution_min
    }
    pub fn clear_distribution_min(&mut self) {
        self.distribution_min = 0.;
    }

    // Param is passed by value, moved
    pub fn set_distribution_min(&mut self, v: f64) {
        self.distribution_min = v;
    }

    // double distribution_mean = 5;


    pub fn get_distribution_mean(&self) -> f64 {
        self.distribution_mean
    }
    pub fn clear_distribution_mean(&mut self) {
        self.distribution_mean = 0.;
    }

    // Param is passed by value, moved
    pub fn set_distribution_mean(&mut self, v: f64) {
        self.distribution_mean = v;
    }

    // double distribution_max = 6;


    pub fn get_distribution_max(&self) -> f64 {
        self.distribution_max
    }
    pub fn clear_distribution_max(&mut self) {
        self.distribution_max = 0.;
    }

    // Param is passed by value, moved
    pub fn set_distribution_max(&mut self, v: f64) {
        self.distribution_max = v;
    }

    // double distribution_count = 7;


    pub fn get_distribution_count(&self) -> f64 {
        self.distribution_count
    }
    pub fn clear_distribution_count(&mut self) {
        self.distribution_count = 0.;
    }

    // Param is passed by value, moved
    pub fn set_distribution_count(&mut self, v: f64) {
        self.distribution_count = v;
    }

    // repeated double distribution_bucket_boundaries = 8;


    pub fn get_distribution_bucket_boundaries(&self) -> &[f64] {
        &self.distribution_bucket_boundaries
    }
    pub fn clear_distribution_bucket_boundaries(&mut self) {
        self.distribution_bucket_boundaries.clear();
    }

    // Param is passed by value, moved
    pub fn set_distribution_bucket_boundaries(&mut self, v: ::std::vec::Vec<f64>) {
        self.distribution_bucket_boundaries = v;
    }

    // Mutable pointer to the field.
    pub fn mut_distribution_bucket_boundaries(&mut self) -> &mut ::std::vec::Vec<f64> {
        &mut self.distribution_bucket_boundaries
    }

    // Take field
    pub fn take_distribution_bucket_boundaries(&mut self) -> ::std::vec::Vec<f64> {
        ::std::mem::replace(&mut self.distribution_bucket_boundaries, ::std::vec::Vec::new())
    }

    // repeated double distribution_bucket_counts = 9;


    pub fn get_distribution_bucket_counts(&self) -> &[f64] {
        &self.distribution_bucket_counts
    }
    pub fn clear_distribution_bucket_counts(&mut self) {
        self.distribution_bucket_counts.clear();
    }

    // Param is passed by value, moved
    pub fn set_distribution_bucket_counts(&mut self, v: ::std::vec::Vec<f64>) {
        self.distribution_bucket_counts = v;
    }

    // Mutable pointer to the field.
    pub fn mut_distribution_bucket_counts(&mut self) -> &mut ::std::vec::Vec<f64> {
        &mut self.distribution_bucket_counts
    }

    // Take field
    pub fn take_distribution_bucket_counts(&mut self) -> ::std::vec::Vec<f64> {
        ::std::mem::replace(&mut self.distribution_bucket_counts, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for ViewData_Measure {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.tags)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.int_value = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_double()?;
                    self.double_value = tmp;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_double()?;
                    self.distribution_min = tmp;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_double()?;
                    self.distribution_mean = tmp;
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_double()?;
                    self.distribution_max = tmp;
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_double()?;
                    self.distribution_count = tmp;
                },
                8 => {
                    ::protobuf::rt::read_repeated_double_into(wire_type, is, &mut self.distribution_bucket_boundaries)?;
                },
                9 => {
                    ::protobuf::rt::read_repeated_double_into(wire_type, is, &mut self.distribution_bucket_counts)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.tags.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.tags);
        }
        if self.int_value != 0 {
            my_size += ::protobuf::rt::value_size(2, self.int_value, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.double_value != 0. {
            my_size += 9;
        }
        if self.distribution_min != 0. {
            my_size += 9;
        }
        if self.distribution_mean != 0. {
            my_size += 9;
        }
        if self.distribution_max != 0. {
            my_size += 9;
        }
        if self.distribution_count != 0. {
            my_size += 9;
        }
        my_size += 9 * self.distribution_bucket_boundaries.len() as u32;
        my_size += 9 * self.distribution_bucket_counts.len() as u32;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.tags.is_empty() {
            os.write_string(1, &self.tags)?;
        }
        if self.int_value != 0 {
            os.write_int64(2, self.int_value)?;
        }
        if self.double_value != 0. {
            os.write_double(3, self.double_value)?;
        }
        if self.distribution_min != 0. {
            os.write_double(4, self.distribution_min)?;
        }
        if self.distribution_mean != 0. {
            os.write_double(5, self.distribution_mean)?;
        }
        if self.distribution_max != 0. {
            os.write_double(6, self.distribution_max)?;
        }
        if self.distribution_count != 0. {
            os.write_double(7, self.distribution_count)?;
        }
        for v in &self.distribution_bucket_boundaries {
            os.write_double(8, *v)?;
        };
        for v in &self.distribution_bucket_counts {
            os.write_double(9, *v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ViewData_Measure {
        ViewData_Measure::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "tags",
                |m: &ViewData_Measure| { &m.tags },
                |m: &mut ViewData_Measure| { &mut m.tags },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "int_value",
                |m: &ViewData_Measure| { &m.int_value },
                |m: &mut ViewData_Measure| { &mut m.int_value },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeDouble>(
                "double_value",
                |m: &ViewData_Measure| { &m.double_value },
                |m: &mut ViewData_Measure| { &mut m.double_value },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeDouble>(
                "distribution_min",
                |m: &ViewData_Measure| { &m.distribution_min },
                |m: &mut ViewData_Measure| { &mut m.distribution_min },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeDouble>(
                "distribution_mean",
                |m: &ViewData_Measure| { &m.distribution_mean },
                |m: &mut ViewData_Measure| { &mut m.distribution_mean },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeDouble>(
                "distribution_max",
                |m: &ViewData_Measure| { &m.distribution_max },
                |m: &mut ViewData_Measure| { &mut m.distribution_max },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeDouble>(
                "distribution_count",
                |m: &ViewData_Measure| { &m.distribution_count },
                |m: &mut ViewData_Measure| { &mut m.distribution_count },
            ));
            fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeDouble>(
                "distribution_bucket_boundaries",
                |m: &ViewData_Measure| { &m.distribution_bucket_boundaries },
                |m: &mut ViewData_Measure| { &mut m.distribution_bucket_boundaries },
            ));
            fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeDouble>(
                "distribution_bucket_counts",
                |m: &ViewData_Measure| { &m.distribution_bucket_counts },
                |m: &mut ViewData_Measure| { &mut m.distribution_bucket_counts },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ViewData_Measure>(
                "ViewData.Measure",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ViewData_Measure {
        static instance: ::protobuf::rt::LazyV2<ViewData_Measure> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ViewData_Measure::new)
    }
}

impl ::protobuf::Clear for ViewData_Measure {
    fn clear(&mut self) {
        self.tags.clear();
        self.int_value = 0;
        self.double_value = 0.;
        self.distribution_min = 0.;
        self.distribution_mean = 0.;
        self.distribution_max = 0.;
        self.distribution_count = 0.;
        self.distribution_bucket_boundaries.clear();
        self.distribution_bucket_counts.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ViewData_Measure {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ViewData_Measure {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ObjectRefInfo {
    // message fields
    pub object_id: ::std::vec::Vec<u8>,
    pub call_site: ::std::string::String,
    pub object_size: i64,
    pub local_ref_count: i64,
    pub submitted_task_ref_count: i64,
    pub contained_in_owned: ::protobuf::RepeatedField<::std::vec::Vec<u8>>,
    pub pinned_in_memory: bool,
    pub task_status: TaskStatus,
    pub attempt_number: u64,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ObjectRefInfo {
    fn default() -> &'a ObjectRefInfo {
        <ObjectRefInfo as ::protobuf::Message>::default_instance()
    }
}

impl ObjectRefInfo {
    pub fn new() -> ObjectRefInfo {
        ::std::default::Default::default()
    }

    // bytes object_id = 1;


    pub fn get_object_id(&self) -> &[u8] {
        &self.object_id
    }
    pub fn clear_object_id(&mut self) {
        self.object_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_object_id(&mut self, v: ::std::vec::Vec<u8>) {
        self.object_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_object_id(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.object_id
    }

    // Take field
    pub fn take_object_id(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.object_id, ::std::vec::Vec::new())
    }

    // string call_site = 2;


    pub fn get_call_site(&self) -> &str {
        &self.call_site
    }
    pub fn clear_call_site(&mut self) {
        self.call_site.clear();
    }

    // Param is passed by value, moved
    pub fn set_call_site(&mut self, v: ::std::string::String) {
        self.call_site = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_call_site(&mut self) -> &mut ::std::string::String {
        &mut self.call_site
    }

    // Take field
    pub fn take_call_site(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.call_site, ::std::string::String::new())
    }

    // int64 object_size = 3;


    pub fn get_object_size(&self) -> i64 {
        self.object_size
    }
    pub fn clear_object_size(&mut self) {
        self.object_size = 0;
    }

    // Param is passed by value, moved
    pub fn set_object_size(&mut self, v: i64) {
        self.object_size = v;
    }

    // int64 local_ref_count = 4;


    pub fn get_local_ref_count(&self) -> i64 {
        self.local_ref_count
    }
    pub fn clear_local_ref_count(&mut self) {
        self.local_ref_count = 0;
    }

    // Param is passed by value, moved
    pub fn set_local_ref_count(&mut self, v: i64) {
        self.local_ref_count = v;
    }

    // int64 submitted_task_ref_count = 5;


    pub fn get_submitted_task_ref_count(&self) -> i64 {
        self.submitted_task_ref_count
    }
    pub fn clear_submitted_task_ref_count(&mut self) {
        self.submitted_task_ref_count = 0;
    }

    // Param is passed by value, moved
    pub fn set_submitted_task_ref_count(&mut self, v: i64) {
        self.submitted_task_ref_count = v;
    }

    // repeated bytes contained_in_owned = 6;


    pub fn get_contained_in_owned(&self) -> &[::std::vec::Vec<u8>] {
        &self.contained_in_owned
    }
    pub fn clear_contained_in_owned(&mut self) {
        self.contained_in_owned.clear();
    }

    // Param is passed by value, moved
    pub fn set_contained_in_owned(&mut self, v: ::protobuf::RepeatedField<::std::vec::Vec<u8>>) {
        self.contained_in_owned = v;
    }

    // Mutable pointer to the field.
    pub fn mut_contained_in_owned(&mut self) -> &mut ::protobuf::RepeatedField<::std::vec::Vec<u8>> {
        &mut self.contained_in_owned
    }

    // Take field
    pub fn take_contained_in_owned(&mut self) -> ::protobuf::RepeatedField<::std::vec::Vec<u8>> {
        ::std::mem::replace(&mut self.contained_in_owned, ::protobuf::RepeatedField::new())
    }

    // bool pinned_in_memory = 7;


    pub fn get_pinned_in_memory(&self) -> bool {
        self.pinned_in_memory
    }
    pub fn clear_pinned_in_memory(&mut self) {
        self.pinned_in_memory = false;
    }

    // Param is passed by value, moved
    pub fn set_pinned_in_memory(&mut self, v: bool) {
        self.pinned_in_memory = v;
    }

    // .ray.rpc.TaskStatus task_status = 8;


    pub fn get_task_status(&self) -> TaskStatus {
        self.task_status
    }
    pub fn clear_task_status(&mut self) {
        self.task_status = TaskStatus::NIL;
    }

    // Param is passed by value, moved
    pub fn set_task_status(&mut self, v: TaskStatus) {
        self.task_status = v;
    }

    // uint64 attempt_number = 9;


    pub fn get_attempt_number(&self) -> u64 {
        self.attempt_number
    }
    pub fn clear_attempt_number(&mut self) {
        self.attempt_number = 0;
    }

    // Param is passed by value, moved
    pub fn set_attempt_number(&mut self, v: u64) {
        self.attempt_number = v;
    }
}

impl ::protobuf::Message for ObjectRefInfo {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.object_id)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.call_site)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.object_size = tmp;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.local_ref_count = tmp;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.submitted_task_ref_count = tmp;
                },
                6 => {
                    ::protobuf::rt::read_repeated_bytes_into(wire_type, is, &mut self.contained_in_owned)?;
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.pinned_in_memory = tmp;
                },
                8 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.task_status, 8, &mut self.unknown_fields)?
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.attempt_number = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.object_id.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.object_id);
        }
        if !self.call_site.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.call_site);
        }
        if self.object_size != 0 {
            my_size += ::protobuf::rt::value_size(3, self.object_size, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.local_ref_count != 0 {
            my_size += ::protobuf::rt::value_size(4, self.local_ref_count, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.submitted_task_ref_count != 0 {
            my_size += ::protobuf::rt::value_size(5, self.submitted_task_ref_count, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.contained_in_owned {
            my_size += ::protobuf::rt::bytes_size(6, &value);
        };
        if self.pinned_in_memory != false {
            my_size += 2;
        }
        if self.task_status != TaskStatus::NIL {
            my_size += ::protobuf::rt::enum_size(8, self.task_status);
        }
        if self.attempt_number != 0 {
            my_size += ::protobuf::rt::value_size(9, self.attempt_number, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.object_id.is_empty() {
            os.write_bytes(1, &self.object_id)?;
        }
        if !self.call_site.is_empty() {
            os.write_string(2, &self.call_site)?;
        }
        if self.object_size != 0 {
            os.write_int64(3, self.object_size)?;
        }
        if self.local_ref_count != 0 {
            os.write_int64(4, self.local_ref_count)?;
        }
        if self.submitted_task_ref_count != 0 {
            os.write_int64(5, self.submitted_task_ref_count)?;
        }
        for v in &self.contained_in_owned {
            os.write_bytes(6, &v)?;
        };
        if self.pinned_in_memory != false {
            os.write_bool(7, self.pinned_in_memory)?;
        }
        if self.task_status != TaskStatus::NIL {
            os.write_enum(8, ::protobuf::ProtobufEnum::value(&self.task_status))?;
        }
        if self.attempt_number != 0 {
            os.write_uint64(9, self.attempt_number)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ObjectRefInfo {
        ObjectRefInfo::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "object_id",
                |m: &ObjectRefInfo| { &m.object_id },
                |m: &mut ObjectRefInfo| { &mut m.object_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "call_site",
                |m: &ObjectRefInfo| { &m.call_site },
                |m: &mut ObjectRefInfo| { &mut m.call_site },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "object_size",
                |m: &ObjectRefInfo| { &m.object_size },
                |m: &mut ObjectRefInfo| { &mut m.object_size },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "local_ref_count",
                |m: &ObjectRefInfo| { &m.local_ref_count },
                |m: &mut ObjectRefInfo| { &mut m.local_ref_count },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "submitted_task_ref_count",
                |m: &ObjectRefInfo| { &m.submitted_task_ref_count },
                |m: &mut ObjectRefInfo| { &mut m.submitted_task_ref_count },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "contained_in_owned",
                |m: &ObjectRefInfo| { &m.contained_in_owned },
                |m: &mut ObjectRefInfo| { &mut m.contained_in_owned },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "pinned_in_memory",
                |m: &ObjectRefInfo| { &m.pinned_in_memory },
                |m: &mut ObjectRefInfo| { &mut m.pinned_in_memory },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<TaskStatus>>(
                "task_status",
                |m: &ObjectRefInfo| { &m.task_status },
                |m: &mut ObjectRefInfo| { &mut m.task_status },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "attempt_number",
                |m: &ObjectRefInfo| { &m.attempt_number },
                |m: &mut ObjectRefInfo| { &mut m.attempt_number },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ObjectRefInfo>(
                "ObjectRefInfo",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ObjectRefInfo {
        static instance: ::protobuf::rt::LazyV2<ObjectRefInfo> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ObjectRefInfo::new)
    }
}

impl ::protobuf::Clear for ObjectRefInfo {
    fn clear(&mut self) {
        self.object_id.clear();
        self.call_site.clear();
        self.object_size = 0;
        self.local_ref_count = 0;
        self.submitted_task_ref_count = 0;
        self.contained_in_owned.clear();
        self.pinned_in_memory = false;
        self.task_status = TaskStatus::NIL;
        self.attempt_number = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ObjectRefInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ObjectRefInfo {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ResourceAllocations {
    // message fields
    pub resource_slots: ::protobuf::RepeatedField<ResourceAllocations_ResourceSlot>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ResourceAllocations {
    fn default() -> &'a ResourceAllocations {
        <ResourceAllocations as ::protobuf::Message>::default_instance()
    }
}

impl ResourceAllocations {
    pub fn new() -> ResourceAllocations {
        ::std::default::Default::default()
    }

    // repeated .ray.rpc.ResourceAllocations.ResourceSlot resource_slots = 1;


    pub fn get_resource_slots(&self) -> &[ResourceAllocations_ResourceSlot] {
        &self.resource_slots
    }
    pub fn clear_resource_slots(&mut self) {
        self.resource_slots.clear();
    }

    // Param is passed by value, moved
    pub fn set_resource_slots(&mut self, v: ::protobuf::RepeatedField<ResourceAllocations_ResourceSlot>) {
        self.resource_slots = v;
    }

    // Mutable pointer to the field.
    pub fn mut_resource_slots(&mut self) -> &mut ::protobuf::RepeatedField<ResourceAllocations_ResourceSlot> {
        &mut self.resource_slots
    }

    // Take field
    pub fn take_resource_slots(&mut self) -> ::protobuf::RepeatedField<ResourceAllocations_ResourceSlot> {
        ::std::mem::replace(&mut self.resource_slots, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for ResourceAllocations {
    fn is_initialized(&self) -> bool {
        for v in &self.resource_slots {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.resource_slots)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.resource_slots {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.resource_slots {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ResourceAllocations {
        ResourceAllocations::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ResourceAllocations_ResourceSlot>>(
                "resource_slots",
                |m: &ResourceAllocations| { &m.resource_slots },
                |m: &mut ResourceAllocations| { &mut m.resource_slots },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ResourceAllocations>(
                "ResourceAllocations",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ResourceAllocations {
        static instance: ::protobuf::rt::LazyV2<ResourceAllocations> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ResourceAllocations::new)
    }
}

impl ::protobuf::Clear for ResourceAllocations {
    fn clear(&mut self) {
        self.resource_slots.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ResourceAllocations {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ResourceAllocations {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ResourceAllocations_ResourceSlot {
    // message fields
    pub slot: i64,
    pub allocation: f64,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ResourceAllocations_ResourceSlot {
    fn default() -> &'a ResourceAllocations_ResourceSlot {
        <ResourceAllocations_ResourceSlot as ::protobuf::Message>::default_instance()
    }
}

impl ResourceAllocations_ResourceSlot {
    pub fn new() -> ResourceAllocations_ResourceSlot {
        ::std::default::Default::default()
    }

    // int64 slot = 1;


    pub fn get_slot(&self) -> i64 {
        self.slot
    }
    pub fn clear_slot(&mut self) {
        self.slot = 0;
    }

    // Param is passed by value, moved
    pub fn set_slot(&mut self, v: i64) {
        self.slot = v;
    }

    // double allocation = 2;


    pub fn get_allocation(&self) -> f64 {
        self.allocation
    }
    pub fn clear_allocation(&mut self) {
        self.allocation = 0.;
    }

    // Param is passed by value, moved
    pub fn set_allocation(&mut self, v: f64) {
        self.allocation = v;
    }
}

impl ::protobuf::Message for ResourceAllocations_ResourceSlot {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.slot = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_double()?;
                    self.allocation = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.slot != 0 {
            my_size += ::protobuf::rt::value_size(1, self.slot, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.allocation != 0. {
            my_size += 9;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.slot != 0 {
            os.write_int64(1, self.slot)?;
        }
        if self.allocation != 0. {
            os.write_double(2, self.allocation)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ResourceAllocations_ResourceSlot {
        ResourceAllocations_ResourceSlot::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "slot",
                |m: &ResourceAllocations_ResourceSlot| { &m.slot },
                |m: &mut ResourceAllocations_ResourceSlot| { &mut m.slot },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeDouble>(
                "allocation",
                |m: &ResourceAllocations_ResourceSlot| { &m.allocation },
                |m: &mut ResourceAllocations_ResourceSlot| { &mut m.allocation },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ResourceAllocations_ResourceSlot>(
                "ResourceAllocations.ResourceSlot",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ResourceAllocations_ResourceSlot {
        static instance: ::protobuf::rt::LazyV2<ResourceAllocations_ResourceSlot> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ResourceAllocations_ResourceSlot::new)
    }
}

impl ::protobuf::Clear for ResourceAllocations_ResourceSlot {
    fn clear(&mut self) {
        self.slot = 0;
        self.allocation = 0.;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ResourceAllocations_ResourceSlot {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ResourceAllocations_ResourceSlot {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CoreWorkerStats {
    // message fields
    pub current_task_desc: ::std::string::String,
    pub num_pending_tasks: i32,
    pub num_object_refs_in_scope: i32,
    pub current_task_name: ::std::string::String,
    pub current_task_func_desc: ::std::string::String,
    pub ip_address: ::std::string::String,
    pub port: i64,
    pub actor_id: ::std::vec::Vec<u8>,
    pub used_resources: ::std::collections::HashMap<::std::string::String, ResourceAllocations>,
    pub webui_display: ::std::collections::HashMap<::std::string::String, ::std::string::String>,
    pub num_in_plasma: i32,
    pub num_local_objects: i32,
    pub used_object_store_memory: i64,
    pub task_queue_length: i32,
    pub num_executed_tasks: i32,
    pub actor_title: ::std::string::String,
    pub object_refs: ::protobuf::RepeatedField<ObjectRefInfo>,
    pub job_id: ::std::vec::Vec<u8>,
    pub worker_id: ::std::vec::Vec<u8>,
    pub language: Language,
    pub pid: u32,
    pub worker_type: WorkerType,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CoreWorkerStats {
    fn default() -> &'a CoreWorkerStats {
        <CoreWorkerStats as ::protobuf::Message>::default_instance()
    }
}

impl CoreWorkerStats {
    pub fn new() -> CoreWorkerStats {
        ::std::default::Default::default()
    }

    // string current_task_desc = 1;


    pub fn get_current_task_desc(&self) -> &str {
        &self.current_task_desc
    }
    pub fn clear_current_task_desc(&mut self) {
        self.current_task_desc.clear();
    }

    // Param is passed by value, moved
    pub fn set_current_task_desc(&mut self, v: ::std::string::String) {
        self.current_task_desc = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_current_task_desc(&mut self) -> &mut ::std::string::String {
        &mut self.current_task_desc
    }

    // Take field
    pub fn take_current_task_desc(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.current_task_desc, ::std::string::String::new())
    }

    // int32 num_pending_tasks = 2;


    pub fn get_num_pending_tasks(&self) -> i32 {
        self.num_pending_tasks
    }
    pub fn clear_num_pending_tasks(&mut self) {
        self.num_pending_tasks = 0;
    }

    // Param is passed by value, moved
    pub fn set_num_pending_tasks(&mut self, v: i32) {
        self.num_pending_tasks = v;
    }

    // int32 num_object_refs_in_scope = 3;


    pub fn get_num_object_refs_in_scope(&self) -> i32 {
        self.num_object_refs_in_scope
    }
    pub fn clear_num_object_refs_in_scope(&mut self) {
        self.num_object_refs_in_scope = 0;
    }

    // Param is passed by value, moved
    pub fn set_num_object_refs_in_scope(&mut self, v: i32) {
        self.num_object_refs_in_scope = v;
    }

    // string current_task_name = 4;


    pub fn get_current_task_name(&self) -> &str {
        &self.current_task_name
    }
    pub fn clear_current_task_name(&mut self) {
        self.current_task_name.clear();
    }

    // Param is passed by value, moved
    pub fn set_current_task_name(&mut self, v: ::std::string::String) {
        self.current_task_name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_current_task_name(&mut self) -> &mut ::std::string::String {
        &mut self.current_task_name
    }

    // Take field
    pub fn take_current_task_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.current_task_name, ::std::string::String::new())
    }

    // string current_task_func_desc = 5;


    pub fn get_current_task_func_desc(&self) -> &str {
        &self.current_task_func_desc
    }
    pub fn clear_current_task_func_desc(&mut self) {
        self.current_task_func_desc.clear();
    }

    // Param is passed by value, moved
    pub fn set_current_task_func_desc(&mut self, v: ::std::string::String) {
        self.current_task_func_desc = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_current_task_func_desc(&mut self) -> &mut ::std::string::String {
        &mut self.current_task_func_desc
    }

    // Take field
    pub fn take_current_task_func_desc(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.current_task_func_desc, ::std::string::String::new())
    }

    // string ip_address = 7;


    pub fn get_ip_address(&self) -> &str {
        &self.ip_address
    }
    pub fn clear_ip_address(&mut self) {
        self.ip_address.clear();
    }

    // Param is passed by value, moved
    pub fn set_ip_address(&mut self, v: ::std::string::String) {
        self.ip_address = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_ip_address(&mut self) -> &mut ::std::string::String {
        &mut self.ip_address
    }

    // Take field
    pub fn take_ip_address(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.ip_address, ::std::string::String::new())
    }

    // int64 port = 8;


    pub fn get_port(&self) -> i64 {
        self.port
    }
    pub fn clear_port(&mut self) {
        self.port = 0;
    }

    // Param is passed by value, moved
    pub fn set_port(&mut self, v: i64) {
        self.port = v;
    }

    // bytes actor_id = 9;


    pub fn get_actor_id(&self) -> &[u8] {
        &self.actor_id
    }
    pub fn clear_actor_id(&mut self) {
        self.actor_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_actor_id(&mut self, v: ::std::vec::Vec<u8>) {
        self.actor_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_actor_id(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.actor_id
    }

    // Take field
    pub fn take_actor_id(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.actor_id, ::std::vec::Vec::new())
    }

    // repeated .ray.rpc.CoreWorkerStats.UsedResourcesEntry used_resources = 10;


    pub fn get_used_resources(&self) -> &::std::collections::HashMap<::std::string::String, ResourceAllocations> {
        &self.used_resources
    }
    pub fn clear_used_resources(&mut self) {
        self.used_resources.clear();
    }

    // Param is passed by value, moved
    pub fn set_used_resources(&mut self, v: ::std::collections::HashMap<::std::string::String, ResourceAllocations>) {
        self.used_resources = v;
    }

    // Mutable pointer to the field.
    pub fn mut_used_resources(&mut self) -> &mut ::std::collections::HashMap<::std::string::String, ResourceAllocations> {
        &mut self.used_resources
    }

    // Take field
    pub fn take_used_resources(&mut self) -> ::std::collections::HashMap<::std::string::String, ResourceAllocations> {
        ::std::mem::replace(&mut self.used_resources, ::std::collections::HashMap::new())
    }

    // repeated .ray.rpc.CoreWorkerStats.WebuiDisplayEntry webui_display = 11;


    pub fn get_webui_display(&self) -> &::std::collections::HashMap<::std::string::String, ::std::string::String> {
        &self.webui_display
    }
    pub fn clear_webui_display(&mut self) {
        self.webui_display.clear();
    }

    // Param is passed by value, moved
    pub fn set_webui_display(&mut self, v: ::std::collections::HashMap<::std::string::String, ::std::string::String>) {
        self.webui_display = v;
    }

    // Mutable pointer to the field.
    pub fn mut_webui_display(&mut self) -> &mut ::std::collections::HashMap<::std::string::String, ::std::string::String> {
        &mut self.webui_display
    }

    // Take field
    pub fn take_webui_display(&mut self) -> ::std::collections::HashMap<::std::string::String, ::std::string::String> {
        ::std::mem::replace(&mut self.webui_display, ::std::collections::HashMap::new())
    }

    // int32 num_in_plasma = 12;


    pub fn get_num_in_plasma(&self) -> i32 {
        self.num_in_plasma
    }
    pub fn clear_num_in_plasma(&mut self) {
        self.num_in_plasma = 0;
    }

    // Param is passed by value, moved
    pub fn set_num_in_plasma(&mut self, v: i32) {
        self.num_in_plasma = v;
    }

    // int32 num_local_objects = 13;


    pub fn get_num_local_objects(&self) -> i32 {
        self.num_local_objects
    }
    pub fn clear_num_local_objects(&mut self) {
        self.num_local_objects = 0;
    }

    // Param is passed by value, moved
    pub fn set_num_local_objects(&mut self, v: i32) {
        self.num_local_objects = v;
    }

    // int64 used_object_store_memory = 14;


    pub fn get_used_object_store_memory(&self) -> i64 {
        self.used_object_store_memory
    }
    pub fn clear_used_object_store_memory(&mut self) {
        self.used_object_store_memory = 0;
    }

    // Param is passed by value, moved
    pub fn set_used_object_store_memory(&mut self, v: i64) {
        self.used_object_store_memory = v;
    }

    // int32 task_queue_length = 15;


    pub fn get_task_queue_length(&self) -> i32 {
        self.task_queue_length
    }
    pub fn clear_task_queue_length(&mut self) {
        self.task_queue_length = 0;
    }

    // Param is passed by value, moved
    pub fn set_task_queue_length(&mut self, v: i32) {
        self.task_queue_length = v;
    }

    // int32 num_executed_tasks = 16;


    pub fn get_num_executed_tasks(&self) -> i32 {
        self.num_executed_tasks
    }
    pub fn clear_num_executed_tasks(&mut self) {
        self.num_executed_tasks = 0;
    }

    // Param is passed by value, moved
    pub fn set_num_executed_tasks(&mut self, v: i32) {
        self.num_executed_tasks = v;
    }

    // string actor_title = 17;


    pub fn get_actor_title(&self) -> &str {
        &self.actor_title
    }
    pub fn clear_actor_title(&mut self) {
        self.actor_title.clear();
    }

    // Param is passed by value, moved
    pub fn set_actor_title(&mut self, v: ::std::string::String) {
        self.actor_title = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_actor_title(&mut self) -> &mut ::std::string::String {
        &mut self.actor_title
    }

    // Take field
    pub fn take_actor_title(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.actor_title, ::std::string::String::new())
    }

    // repeated .ray.rpc.ObjectRefInfo object_refs = 18;


    pub fn get_object_refs(&self) -> &[ObjectRefInfo] {
        &self.object_refs
    }
    pub fn clear_object_refs(&mut self) {
        self.object_refs.clear();
    }

    // Param is passed by value, moved
    pub fn set_object_refs(&mut self, v: ::protobuf::RepeatedField<ObjectRefInfo>) {
        self.object_refs = v;
    }

    // Mutable pointer to the field.
    pub fn mut_object_refs(&mut self) -> &mut ::protobuf::RepeatedField<ObjectRefInfo> {
        &mut self.object_refs
    }

    // Take field
    pub fn take_object_refs(&mut self) -> ::protobuf::RepeatedField<ObjectRefInfo> {
        ::std::mem::replace(&mut self.object_refs, ::protobuf::RepeatedField::new())
    }

    // bytes job_id = 19;


    pub fn get_job_id(&self) -> &[u8] {
        &self.job_id
    }
    pub fn clear_job_id(&mut self) {
        self.job_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_job_id(&mut self, v: ::std::vec::Vec<u8>) {
        self.job_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_job_id(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.job_id
    }

    // Take field
    pub fn take_job_id(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.job_id, ::std::vec::Vec::new())
    }

    // bytes worker_id = 20;


    pub fn get_worker_id(&self) -> &[u8] {
        &self.worker_id
    }
    pub fn clear_worker_id(&mut self) {
        self.worker_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_worker_id(&mut self, v: ::std::vec::Vec<u8>) {
        self.worker_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_worker_id(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.worker_id
    }

    // Take field
    pub fn take_worker_id(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.worker_id, ::std::vec::Vec::new())
    }

    // .ray.rpc.Language language = 21;


    pub fn get_language(&self) -> Language {
        self.language
    }
    pub fn clear_language(&mut self) {
        self.language = Language::PYTHON;
    }

    // Param is passed by value, moved
    pub fn set_language(&mut self, v: Language) {
        self.language = v;
    }

    // uint32 pid = 22;


    pub fn get_pid(&self) -> u32 {
        self.pid
    }
    pub fn clear_pid(&mut self) {
        self.pid = 0;
    }

    // Param is passed by value, moved
    pub fn set_pid(&mut self, v: u32) {
        self.pid = v;
    }

    // .ray.rpc.WorkerType worker_type = 23;


    pub fn get_worker_type(&self) -> WorkerType {
        self.worker_type
    }
    pub fn clear_worker_type(&mut self) {
        self.worker_type = WorkerType::WORKER;
    }

    // Param is passed by value, moved
    pub fn set_worker_type(&mut self, v: WorkerType) {
        self.worker_type = v;
    }
}

impl ::protobuf::Message for CoreWorkerStats {
    fn is_initialized(&self) -> bool {
        for v in &self.object_refs {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.current_task_desc)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.num_pending_tasks = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.num_object_refs_in_scope = tmp;
                },
                4 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.current_task_name)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.current_task_func_desc)?;
                },
                7 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.ip_address)?;
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.port = tmp;
                },
                9 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.actor_id)?;
                },
                10 => {
                    ::protobuf::rt::read_map_into::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeMessage<ResourceAllocations>>(wire_type, is, &mut self.used_resources)?;
                },
                11 => {
                    ::protobuf::rt::read_map_into::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(wire_type, is, &mut self.webui_display)?;
                },
                12 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.num_in_plasma = tmp;
                },
                13 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.num_local_objects = tmp;
                },
                14 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.used_object_store_memory = tmp;
                },
                15 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.task_queue_length = tmp;
                },
                16 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.num_executed_tasks = tmp;
                },
                17 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.actor_title)?;
                },
                18 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.object_refs)?;
                },
                19 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.job_id)?;
                },
                20 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.worker_id)?;
                },
                21 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.language, 21, &mut self.unknown_fields)?
                },
                22 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.pid = tmp;
                },
                23 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.worker_type, 23, &mut self.unknown_fields)?
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.current_task_desc.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.current_task_desc);
        }
        if self.num_pending_tasks != 0 {
            my_size += ::protobuf::rt::value_size(2, self.num_pending_tasks, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.num_object_refs_in_scope != 0 {
            my_size += ::protobuf::rt::value_size(3, self.num_object_refs_in_scope, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.current_task_name.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.current_task_name);
        }
        if !self.current_task_func_desc.is_empty() {
            my_size += ::protobuf::rt::string_size(5, &self.current_task_func_desc);
        }
        if !self.ip_address.is_empty() {
            my_size += ::protobuf::rt::string_size(7, &self.ip_address);
        }
        if self.port != 0 {
            my_size += ::protobuf::rt::value_size(8, self.port, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.actor_id.is_empty() {
            my_size += ::protobuf::rt::bytes_size(9, &self.actor_id);
        }
        my_size += ::protobuf::rt::compute_map_size::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeMessage<ResourceAllocations>>(10, &self.used_resources);
        my_size += ::protobuf::rt::compute_map_size::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(11, &self.webui_display);
        if self.num_in_plasma != 0 {
            my_size += ::protobuf::rt::value_size(12, self.num_in_plasma, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.num_local_objects != 0 {
            my_size += ::protobuf::rt::value_size(13, self.num_local_objects, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.used_object_store_memory != 0 {
            my_size += ::protobuf::rt::value_size(14, self.used_object_store_memory, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.task_queue_length != 0 {
            my_size += ::protobuf::rt::value_size(15, self.task_queue_length, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.num_executed_tasks != 0 {
            my_size += ::protobuf::rt::value_size(16, self.num_executed_tasks, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.actor_title.is_empty() {
            my_size += ::protobuf::rt::string_size(17, &self.actor_title);
        }
        for value in &self.object_refs {
            let len = value.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if !self.job_id.is_empty() {
            my_size += ::protobuf::rt::bytes_size(19, &self.job_id);
        }
        if !self.worker_id.is_empty() {
            my_size += ::protobuf::rt::bytes_size(20, &self.worker_id);
        }
        if self.language != Language::PYTHON {
            my_size += ::protobuf::rt::enum_size(21, self.language);
        }
        if self.pid != 0 {
            my_size += ::protobuf::rt::value_size(22, self.pid, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.worker_type != WorkerType::WORKER {
            my_size += ::protobuf::rt::enum_size(23, self.worker_type);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.current_task_desc.is_empty() {
            os.write_string(1, &self.current_task_desc)?;
        }
        if self.num_pending_tasks != 0 {
            os.write_int32(2, self.num_pending_tasks)?;
        }
        if self.num_object_refs_in_scope != 0 {
            os.write_int32(3, self.num_object_refs_in_scope)?;
        }
        if !self.current_task_name.is_empty() {
            os.write_string(4, &self.current_task_name)?;
        }
        if !self.current_task_func_desc.is_empty() {
            os.write_string(5, &self.current_task_func_desc)?;
        }
        if !self.ip_address.is_empty() {
            os.write_string(7, &self.ip_address)?;
        }
        if self.port != 0 {
            os.write_int64(8, self.port)?;
        }
        if !self.actor_id.is_empty() {
            os.write_bytes(9, &self.actor_id)?;
        }
        ::protobuf::rt::write_map_with_cached_sizes::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeMessage<ResourceAllocations>>(10, &self.used_resources, os)?;
        ::protobuf::rt::write_map_with_cached_sizes::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(11, &self.webui_display, os)?;
        if self.num_in_plasma != 0 {
            os.write_int32(12, self.num_in_plasma)?;
        }
        if self.num_local_objects != 0 {
            os.write_int32(13, self.num_local_objects)?;
        }
        if self.used_object_store_memory != 0 {
            os.write_int64(14, self.used_object_store_memory)?;
        }
        if self.task_queue_length != 0 {
            os.write_int32(15, self.task_queue_length)?;
        }
        if self.num_executed_tasks != 0 {
            os.write_int32(16, self.num_executed_tasks)?;
        }
        if !self.actor_title.is_empty() {
            os.write_string(17, &self.actor_title)?;
        }
        for v in &self.object_refs {
            os.write_tag(18, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if !self.job_id.is_empty() {
            os.write_bytes(19, &self.job_id)?;
        }
        if !self.worker_id.is_empty() {
            os.write_bytes(20, &self.worker_id)?;
        }
        if self.language != Language::PYTHON {
            os.write_enum(21, ::protobuf::ProtobufEnum::value(&self.language))?;
        }
        if self.pid != 0 {
            os.write_uint32(22, self.pid)?;
        }
        if self.worker_type != WorkerType::WORKER {
            os.write_enum(23, ::protobuf::ProtobufEnum::value(&self.worker_type))?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CoreWorkerStats {
        CoreWorkerStats::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "current_task_desc",
                |m: &CoreWorkerStats| { &m.current_task_desc },
                |m: &mut CoreWorkerStats| { &mut m.current_task_desc },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "num_pending_tasks",
                |m: &CoreWorkerStats| { &m.num_pending_tasks },
                |m: &mut CoreWorkerStats| { &mut m.num_pending_tasks },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "num_object_refs_in_scope",
                |m: &CoreWorkerStats| { &m.num_object_refs_in_scope },
                |m: &mut CoreWorkerStats| { &mut m.num_object_refs_in_scope },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "current_task_name",
                |m: &CoreWorkerStats| { &m.current_task_name },
                |m: &mut CoreWorkerStats| { &mut m.current_task_name },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "current_task_func_desc",
                |m: &CoreWorkerStats| { &m.current_task_func_desc },
                |m: &mut CoreWorkerStats| { &mut m.current_task_func_desc },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "ip_address",
                |m: &CoreWorkerStats| { &m.ip_address },
                |m: &mut CoreWorkerStats| { &mut m.ip_address },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "port",
                |m: &CoreWorkerStats| { &m.port },
                |m: &mut CoreWorkerStats| { &mut m.port },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "actor_id",
                |m: &CoreWorkerStats| { &m.actor_id },
                |m: &mut CoreWorkerStats| { &mut m.actor_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_map_accessor::<_, ::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeMessage<ResourceAllocations>>(
                "used_resources",
                |m: &CoreWorkerStats| { &m.used_resources },
                |m: &mut CoreWorkerStats| { &mut m.used_resources },
            ));
            fields.push(::protobuf::reflect::accessor::make_map_accessor::<_, ::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(
                "webui_display",
                |m: &CoreWorkerStats| { &m.webui_display },
                |m: &mut CoreWorkerStats| { &mut m.webui_display },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "num_in_plasma",
                |m: &CoreWorkerStats| { &m.num_in_plasma },
                |m: &mut CoreWorkerStats| { &mut m.num_in_plasma },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "num_local_objects",
                |m: &CoreWorkerStats| { &m.num_local_objects },
                |m: &mut CoreWorkerStats| { &mut m.num_local_objects },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "used_object_store_memory",
                |m: &CoreWorkerStats| { &m.used_object_store_memory },
                |m: &mut CoreWorkerStats| { &mut m.used_object_store_memory },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "task_queue_length",
                |m: &CoreWorkerStats| { &m.task_queue_length },
                |m: &mut CoreWorkerStats| { &mut m.task_queue_length },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "num_executed_tasks",
                |m: &CoreWorkerStats| { &m.num_executed_tasks },
                |m: &mut CoreWorkerStats| { &mut m.num_executed_tasks },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "actor_title",
                |m: &CoreWorkerStats| { &m.actor_title },
                |m: &mut CoreWorkerStats| { &mut m.actor_title },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ObjectRefInfo>>(
                "object_refs",
                |m: &CoreWorkerStats| { &m.object_refs },
                |m: &mut CoreWorkerStats| { &mut m.object_refs },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "job_id",
                |m: &CoreWorkerStats| { &m.job_id },
                |m: &mut CoreWorkerStats| { &mut m.job_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "worker_id",
                |m: &CoreWorkerStats| { &m.worker_id },
                |m: &mut CoreWorkerStats| { &mut m.worker_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<Language>>(
                "language",
                |m: &CoreWorkerStats| { &m.language },
                |m: &mut CoreWorkerStats| { &mut m.language },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "pid",
                |m: &CoreWorkerStats| { &m.pid },
                |m: &mut CoreWorkerStats| { &mut m.pid },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<WorkerType>>(
                "worker_type",
                |m: &CoreWorkerStats| { &m.worker_type },
                |m: &mut CoreWorkerStats| { &mut m.worker_type },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CoreWorkerStats>(
                "CoreWorkerStats",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CoreWorkerStats {
        static instance: ::protobuf::rt::LazyV2<CoreWorkerStats> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CoreWorkerStats::new)
    }
}

impl ::protobuf::Clear for CoreWorkerStats {
    fn clear(&mut self) {
        self.current_task_desc.clear();
        self.num_pending_tasks = 0;
        self.num_object_refs_in_scope = 0;
        self.current_task_name.clear();
        self.current_task_func_desc.clear();
        self.ip_address.clear();
        self.port = 0;
        self.actor_id.clear();
        self.used_resources.clear();
        self.webui_display.clear();
        self.num_in_plasma = 0;
        self.num_local_objects = 0;
        self.used_object_store_memory = 0;
        self.task_queue_length = 0;
        self.num_executed_tasks = 0;
        self.actor_title.clear();
        self.object_refs.clear();
        self.job_id.clear();
        self.worker_id.clear();
        self.language = Language::PYTHON;
        self.pid = 0;
        self.worker_type = WorkerType::WORKER;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CoreWorkerStats {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CoreWorkerStats {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct MetricPoint {
    // message fields
    pub metric_name: ::std::string::String,
    pub timestamp: i64,
    pub value: f64,
    pub tags: ::std::collections::HashMap<::std::string::String, ::std::string::String>,
    pub description: ::std::string::String,
    pub units: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a MetricPoint {
    fn default() -> &'a MetricPoint {
        <MetricPoint as ::protobuf::Message>::default_instance()
    }
}

impl MetricPoint {
    pub fn new() -> MetricPoint {
        ::std::default::Default::default()
    }

    // string metric_name = 1;


    pub fn get_metric_name(&self) -> &str {
        &self.metric_name
    }
    pub fn clear_metric_name(&mut self) {
        self.metric_name.clear();
    }

    // Param is passed by value, moved
    pub fn set_metric_name(&mut self, v: ::std::string::String) {
        self.metric_name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_metric_name(&mut self) -> &mut ::std::string::String {
        &mut self.metric_name
    }

    // Take field
    pub fn take_metric_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.metric_name, ::std::string::String::new())
    }

    // int64 timestamp = 2;


    pub fn get_timestamp(&self) -> i64 {
        self.timestamp
    }
    pub fn clear_timestamp(&mut self) {
        self.timestamp = 0;
    }

    // Param is passed by value, moved
    pub fn set_timestamp(&mut self, v: i64) {
        self.timestamp = v;
    }

    // double value = 3;


    pub fn get_value(&self) -> f64 {
        self.value
    }
    pub fn clear_value(&mut self) {
        self.value = 0.;
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: f64) {
        self.value = v;
    }

    // repeated .ray.rpc.MetricPoint.TagsEntry tags = 4;


    pub fn get_tags(&self) -> &::std::collections::HashMap<::std::string::String, ::std::string::String> {
        &self.tags
    }
    pub fn clear_tags(&mut self) {
        self.tags.clear();
    }

    // Param is passed by value, moved
    pub fn set_tags(&mut self, v: ::std::collections::HashMap<::std::string::String, ::std::string::String>) {
        self.tags = v;
    }

    // Mutable pointer to the field.
    pub fn mut_tags(&mut self) -> &mut ::std::collections::HashMap<::std::string::String, ::std::string::String> {
        &mut self.tags
    }

    // Take field
    pub fn take_tags(&mut self) -> ::std::collections::HashMap<::std::string::String, ::std::string::String> {
        ::std::mem::replace(&mut self.tags, ::std::collections::HashMap::new())
    }

    // string description = 5;


    pub fn get_description(&self) -> &str {
        &self.description
    }
    pub fn clear_description(&mut self) {
        self.description.clear();
    }

    // Param is passed by value, moved
    pub fn set_description(&mut self, v: ::std::string::String) {
        self.description = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_description(&mut self) -> &mut ::std::string::String {
        &mut self.description
    }

    // Take field
    pub fn take_description(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.description, ::std::string::String::new())
    }

    // string units = 6;


    pub fn get_units(&self) -> &str {
        &self.units
    }
    pub fn clear_units(&mut self) {
        self.units.clear();
    }

    // Param is passed by value, moved
    pub fn set_units(&mut self, v: ::std::string::String) {
        self.units = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_units(&mut self) -> &mut ::std::string::String {
        &mut self.units
    }

    // Take field
    pub fn take_units(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.units, ::std::string::String::new())
    }
}

impl ::protobuf::Message for MetricPoint {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.metric_name)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.timestamp = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_double()?;
                    self.value = tmp;
                },
                4 => {
                    ::protobuf::rt::read_map_into::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(wire_type, is, &mut self.tags)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.description)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.units)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.metric_name.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.metric_name);
        }
        if self.timestamp != 0 {
            my_size += ::protobuf::rt::value_size(2, self.timestamp, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.value != 0. {
            my_size += 9;
        }
        my_size += ::protobuf::rt::compute_map_size::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(4, &self.tags);
        if !self.description.is_empty() {
            my_size += ::protobuf::rt::string_size(5, &self.description);
        }
        if !self.units.is_empty() {
            my_size += ::protobuf::rt::string_size(6, &self.units);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.metric_name.is_empty() {
            os.write_string(1, &self.metric_name)?;
        }
        if self.timestamp != 0 {
            os.write_int64(2, self.timestamp)?;
        }
        if self.value != 0. {
            os.write_double(3, self.value)?;
        }
        ::protobuf::rt::write_map_with_cached_sizes::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(4, &self.tags, os)?;
        if !self.description.is_empty() {
            os.write_string(5, &self.description)?;
        }
        if !self.units.is_empty() {
            os.write_string(6, &self.units)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> MetricPoint {
        MetricPoint::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "metric_name",
                |m: &MetricPoint| { &m.metric_name },
                |m: &mut MetricPoint| { &mut m.metric_name },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "timestamp",
                |m: &MetricPoint| { &m.timestamp },
                |m: &mut MetricPoint| { &mut m.timestamp },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeDouble>(
                "value",
                |m: &MetricPoint| { &m.value },
                |m: &mut MetricPoint| { &mut m.value },
            ));
            fields.push(::protobuf::reflect::accessor::make_map_accessor::<_, ::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(
                "tags",
                |m: &MetricPoint| { &m.tags },
                |m: &mut MetricPoint| { &mut m.tags },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "description",
                |m: &MetricPoint| { &m.description },
                |m: &mut MetricPoint| { &mut m.description },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "units",
                |m: &MetricPoint| { &m.units },
                |m: &mut MetricPoint| { &mut m.units },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<MetricPoint>(
                "MetricPoint",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static MetricPoint {
        static instance: ::protobuf::rt::LazyV2<MetricPoint> = ::protobuf::rt::LazyV2::INIT;
        instance.get(MetricPoint::new)
    }
}

impl ::protobuf::Clear for MetricPoint {
    fn clear(&mut self) {
        self.metric_name.clear();
        self.timestamp = 0;
        self.value = 0.;
        self.tags.clear();
        self.description.clear();
        self.units.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for MetricPoint {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MetricPoint {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct NamedActorInfo {
    // message fields
    pub ray_namespace: ::std::string::String,
    pub name: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a NamedActorInfo {
    fn default() -> &'a NamedActorInfo {
        <NamedActorInfo as ::protobuf::Message>::default_instance()
    }
}

impl NamedActorInfo {
    pub fn new() -> NamedActorInfo {
        ::std::default::Default::default()
    }

    // string ray_namespace = 1;


    pub fn get_ray_namespace(&self) -> &str {
        &self.ray_namespace
    }
    pub fn clear_ray_namespace(&mut self) {
        self.ray_namespace.clear();
    }

    // Param is passed by value, moved
    pub fn set_ray_namespace(&mut self, v: ::std::string::String) {
        self.ray_namespace = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_ray_namespace(&mut self) -> &mut ::std::string::String {
        &mut self.ray_namespace
    }

    // Take field
    pub fn take_ray_namespace(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.ray_namespace, ::std::string::String::new())
    }

    // string name = 2;


    pub fn get_name(&self) -> &str {
        &self.name
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        &mut self.name
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.name, ::std::string::String::new())
    }
}

impl ::protobuf::Message for NamedActorInfo {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.ray_namespace)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.name)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.ray_namespace.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.ray_namespace);
        }
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.name);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.ray_namespace.is_empty() {
            os.write_string(1, &self.ray_namespace)?;
        }
        if !self.name.is_empty() {
            os.write_string(2, &self.name)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> NamedActorInfo {
        NamedActorInfo::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "ray_namespace",
                |m: &NamedActorInfo| { &m.ray_namespace },
                |m: &mut NamedActorInfo| { &mut m.ray_namespace },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "name",
                |m: &NamedActorInfo| { &m.name },
                |m: &mut NamedActorInfo| { &mut m.name },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<NamedActorInfo>(
                "NamedActorInfo",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static NamedActorInfo {
        static instance: ::protobuf::rt::LazyV2<NamedActorInfo> = ::protobuf::rt::LazyV2::INIT;
        instance.get(NamedActorInfo::new)
    }
}

impl ::protobuf::Clear for NamedActorInfo {
    fn clear(&mut self) {
        self.ray_namespace.clear();
        self.name.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for NamedActorInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for NamedActorInfo {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum Language {
    PYTHON = 0,
    JAVA = 1,
    CPP = 2,
    RUST = 3,
}

impl ::protobuf::ProtobufEnum for Language {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<Language> {
        match value {
            0 => ::std::option::Option::Some(Language::PYTHON),
            1 => ::std::option::Option::Some(Language::JAVA),
            2 => ::std::option::Option::Some(Language::CPP),
            3 => ::std::option::Option::Some(Language::RUST),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [Language] = &[
            Language::PYTHON,
            Language::JAVA,
            Language::CPP,
            Language::RUST,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<Language>("Language", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for Language {
}

impl ::std::default::Default for Language {
    fn default() -> Self {
        Language::PYTHON
    }
}

impl ::protobuf::reflect::ProtobufValue for Language {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum WorkerType {
    WORKER = 0,
    DRIVER = 1,
    SPILL_WORKER = 2,
    RESTORE_WORKER = 3,
}

impl ::protobuf::ProtobufEnum for WorkerType {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<WorkerType> {
        match value {
            0 => ::std::option::Option::Some(WorkerType::WORKER),
            1 => ::std::option::Option::Some(WorkerType::DRIVER),
            2 => ::std::option::Option::Some(WorkerType::SPILL_WORKER),
            3 => ::std::option::Option::Some(WorkerType::RESTORE_WORKER),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [WorkerType] = &[
            WorkerType::WORKER,
            WorkerType::DRIVER,
            WorkerType::SPILL_WORKER,
            WorkerType::RESTORE_WORKER,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<WorkerType>("WorkerType", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for WorkerType {
}

impl ::std::default::Default for WorkerType {
    fn default() -> Self {
        WorkerType::WORKER
    }
}

impl ::protobuf::reflect::ProtobufValue for WorkerType {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum TaskType {
    NORMAL_TASK = 0,
    ACTOR_CREATION_TASK = 1,
    ACTOR_TASK = 2,
    DRIVER_TASK = 3,
}

impl ::protobuf::ProtobufEnum for TaskType {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<TaskType> {
        match value {
            0 => ::std::option::Option::Some(TaskType::NORMAL_TASK),
            1 => ::std::option::Option::Some(TaskType::ACTOR_CREATION_TASK),
            2 => ::std::option::Option::Some(TaskType::ACTOR_TASK),
            3 => ::std::option::Option::Some(TaskType::DRIVER_TASK),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [TaskType] = &[
            TaskType::NORMAL_TASK,
            TaskType::ACTOR_CREATION_TASK,
            TaskType::ACTOR_TASK,
            TaskType::DRIVER_TASK,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<TaskType>("TaskType", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for TaskType {
}

impl ::std::default::Default for TaskType {
    fn default() -> Self {
        TaskType::NORMAL_TASK
    }
}

impl ::protobuf::reflect::ProtobufValue for TaskType {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum ErrorType {
    WORKER_DIED = 0,
    ACTOR_DIED = 1,
    OBJECT_UNRECONSTRUCTABLE = 2,
    TASK_EXECUTION_EXCEPTION = 3,
    OBJECT_IN_PLASMA = 4,
    TASK_CANCELLED = 5,
    ACTOR_CREATION_FAILED = 6,
    RUNTIME_ENV_SETUP_FAILED = 7,
    OBJECT_LOST = 8,
    OWNER_DIED = 9,
    OBJECT_DELETED = 10,
    DEPENDENCY_RESOLUTION_FAILED = 11,
    OBJECT_UNRECONSTRUCTABLE_MAX_ATTEMPTS_EXCEEDED = 12,
    OBJECT_UNRECONSTRUCTABLE_LINEAGE_EVICTED = 13,
    OBJECT_FETCH_TIMED_OUT = 14,
    LOCAL_RAYLET_DIED = 15,
    TASK_PLACEMENT_GROUP_REMOVED = 16,
    ACTOR_PLACEMENT_GROUP_REMOVED = 17,
}

impl ::protobuf::ProtobufEnum for ErrorType {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<ErrorType> {
        match value {
            0 => ::std::option::Option::Some(ErrorType::WORKER_DIED),
            1 => ::std::option::Option::Some(ErrorType::ACTOR_DIED),
            2 => ::std::option::Option::Some(ErrorType::OBJECT_UNRECONSTRUCTABLE),
            3 => ::std::option::Option::Some(ErrorType::TASK_EXECUTION_EXCEPTION),
            4 => ::std::option::Option::Some(ErrorType::OBJECT_IN_PLASMA),
            5 => ::std::option::Option::Some(ErrorType::TASK_CANCELLED),
            6 => ::std::option::Option::Some(ErrorType::ACTOR_CREATION_FAILED),
            7 => ::std::option::Option::Some(ErrorType::RUNTIME_ENV_SETUP_FAILED),
            8 => ::std::option::Option::Some(ErrorType::OBJECT_LOST),
            9 => ::std::option::Option::Some(ErrorType::OWNER_DIED),
            10 => ::std::option::Option::Some(ErrorType::OBJECT_DELETED),
            11 => ::std::option::Option::Some(ErrorType::DEPENDENCY_RESOLUTION_FAILED),
            12 => ::std::option::Option::Some(ErrorType::OBJECT_UNRECONSTRUCTABLE_MAX_ATTEMPTS_EXCEEDED),
            13 => ::std::option::Option::Some(ErrorType::OBJECT_UNRECONSTRUCTABLE_LINEAGE_EVICTED),
            14 => ::std::option::Option::Some(ErrorType::OBJECT_FETCH_TIMED_OUT),
            15 => ::std::option::Option::Some(ErrorType::LOCAL_RAYLET_DIED),
            16 => ::std::option::Option::Some(ErrorType::TASK_PLACEMENT_GROUP_REMOVED),
            17 => ::std::option::Option::Some(ErrorType::ACTOR_PLACEMENT_GROUP_REMOVED),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [ErrorType] = &[
            ErrorType::WORKER_DIED,
            ErrorType::ACTOR_DIED,
            ErrorType::OBJECT_UNRECONSTRUCTABLE,
            ErrorType::TASK_EXECUTION_EXCEPTION,
            ErrorType::OBJECT_IN_PLASMA,
            ErrorType::TASK_CANCELLED,
            ErrorType::ACTOR_CREATION_FAILED,
            ErrorType::RUNTIME_ENV_SETUP_FAILED,
            ErrorType::OBJECT_LOST,
            ErrorType::OWNER_DIED,
            ErrorType::OBJECT_DELETED,
            ErrorType::DEPENDENCY_RESOLUTION_FAILED,
            ErrorType::OBJECT_UNRECONSTRUCTABLE_MAX_ATTEMPTS_EXCEEDED,
            ErrorType::OBJECT_UNRECONSTRUCTABLE_LINEAGE_EVICTED,
            ErrorType::OBJECT_FETCH_TIMED_OUT,
            ErrorType::LOCAL_RAYLET_DIED,
            ErrorType::TASK_PLACEMENT_GROUP_REMOVED,
            ErrorType::ACTOR_PLACEMENT_GROUP_REMOVED,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<ErrorType>("ErrorType", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for ErrorType {
}

impl ::std::default::Default for ErrorType {
    fn default() -> Self {
        ErrorType::WORKER_DIED
    }
}

impl ::protobuf::reflect::ProtobufValue for ErrorType {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum TaskStatus {
    NIL = 0,
    WAITING_FOR_DEPENDENCIES = 1,
    SCHEDULED = 2,
    FINISHED = 3,
}

impl ::protobuf::ProtobufEnum for TaskStatus {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<TaskStatus> {
        match value {
            0 => ::std::option::Option::Some(TaskStatus::NIL),
            1 => ::std::option::Option::Some(TaskStatus::WAITING_FOR_DEPENDENCIES),
            2 => ::std::option::Option::Some(TaskStatus::SCHEDULED),
            3 => ::std::option::Option::Some(TaskStatus::FINISHED),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [TaskStatus] = &[
            TaskStatus::NIL,
            TaskStatus::WAITING_FOR_DEPENDENCIES,
            TaskStatus::SCHEDULED,
            TaskStatus::FINISHED,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<TaskStatus>("TaskStatus", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for TaskStatus {
}

impl ::std::default::Default for TaskStatus {
    fn default() -> Self {
        TaskStatus::NIL
    }
}

impl ::protobuf::reflect::ProtobufValue for TaskStatus {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum WorkerExitType {
    SYSTEM_ERROR_EXIT = 0,
    INTENDED_EXIT = 1,
    UNUSED_RESOURCE_RELEASED = 2,
    PLACEMENT_GROUP_REMOVED = 3,
    CREATION_TASK_ERROR = 4,
    IDLE_EXIT = 5,
    NODE_DIED = 6,
}

impl ::protobuf::ProtobufEnum for WorkerExitType {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<WorkerExitType> {
        match value {
            0 => ::std::option::Option::Some(WorkerExitType::SYSTEM_ERROR_EXIT),
            1 => ::std::option::Option::Some(WorkerExitType::INTENDED_EXIT),
            2 => ::std::option::Option::Some(WorkerExitType::UNUSED_RESOURCE_RELEASED),
            3 => ::std::option::Option::Some(WorkerExitType::PLACEMENT_GROUP_REMOVED),
            4 => ::std::option::Option::Some(WorkerExitType::CREATION_TASK_ERROR),
            5 => ::std::option::Option::Some(WorkerExitType::IDLE_EXIT),
            6 => ::std::option::Option::Some(WorkerExitType::NODE_DIED),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [WorkerExitType] = &[
            WorkerExitType::SYSTEM_ERROR_EXIT,
            WorkerExitType::INTENDED_EXIT,
            WorkerExitType::UNUSED_RESOURCE_RELEASED,
            WorkerExitType::PLACEMENT_GROUP_REMOVED,
            WorkerExitType::CREATION_TASK_ERROR,
            WorkerExitType::IDLE_EXIT,
            WorkerExitType::NODE_DIED,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<WorkerExitType>("WorkerExitType", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for WorkerExitType {
}

impl ::std::default::Default for WorkerExitType {
    fn default() -> Self {
        WorkerExitType::SYSTEM_ERROR_EXIT
    }
}

impl ::protobuf::reflect::ProtobufValue for WorkerExitType {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum PlacementStrategy {
    PACK = 0,
    SPREAD = 1,
    STRICT_PACK = 2,
    STRICT_SPREAD = 3,
}

impl ::protobuf::ProtobufEnum for PlacementStrategy {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<PlacementStrategy> {
        match value {
            0 => ::std::option::Option::Some(PlacementStrategy::PACK),
            1 => ::std::option::Option::Some(PlacementStrategy::SPREAD),
            2 => ::std::option::Option::Some(PlacementStrategy::STRICT_PACK),
            3 => ::std::option::Option::Some(PlacementStrategy::STRICT_SPREAD),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [PlacementStrategy] = &[
            PlacementStrategy::PACK,
            PlacementStrategy::SPREAD,
            PlacementStrategy::STRICT_PACK,
            PlacementStrategy::STRICT_SPREAD,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<PlacementStrategy>("PlacementStrategy", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for PlacementStrategy {
}

impl ::std::default::Default for PlacementStrategy {
    fn default() -> Self {
        PlacementStrategy::PACK
    }
}

impl ::protobuf::reflect::ProtobufValue for PlacementStrategy {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n\x1dsrc/ray/protobuf/common.proto\x12\x07ray.rpc\x1a)src/ray/protobuf/\
    runtime_env_common.proto\"\xdf\x01\n\x20PlacementGroupSchedulingStrategy\
    \x12,\n\x12placement_group_id\x18\x01\x20\x01(\x0cR\x10placementGroupId\
    \x12?\n\x1cplacement_group_bundle_index\x18\x02\x20\x01(\x03R\x19placeme\
    ntGroupBundleIndex\x12L\n#placement_group_capture_child_tasks\x18\x03\
    \x20\x01(\x08R\x1fplacementGroupCaptureChildTasks\"\x1b\n\x19DefaultSche\
    dulingStrategy\"\x1a\n\x18SpreadSchedulingStrategy\"\xf0\x02\n\x12Schedu\
    lingStrategy\x12d\n\x1bdefault_scheduling_strategy\x18\x01\x20\x01(\x0b2\
    \".ray.rpc.DefaultSchedulingStrategyH\0R\x19defaultSchedulingStrategy\
    \x12z\n#placement_group_scheduling_strategy\x18\x02\x20\x01(\x0b2).ray.r\
    pc.PlacementGroupSchedulingStrategyH\0R\x20placementGroupSchedulingStrat\
    egy\x12a\n\x1aspread_scheduling_strategy\x18\x03\x20\x01(\x0b2!.ray.rpc.\
    SpreadSchedulingStrategyH\0R\x18spreadSchedulingStrategyB\x15\n\x13sched\
    uling_strategy\"v\n\x07Address\x12\x1b\n\traylet_id\x18\x01\x20\x01(\x0c\
    R\x08rayletId\x12\x1d\n\nip_address\x18\x02\x20\x01(\tR\tipAddress\x12\
    \x12\n\x04port\x18\x03\x20\x01(\x05R\x04port\x12\x1b\n\tworker_id\x18\
    \x04\x20\x01(\x0cR\x08workerId\"z\n\x16JavaFunctionDescriptor\x12\x1d\n\
    \nclass_name\x18\x01\x20\x01(\tR\tclassName\x12#\n\rfunction_name\x18\
    \x02\x20\x01(\tR\x0cfunctionName\x12\x1c\n\tsignature\x18\x03\x20\x01(\t\
    R\tsignature\"\xa4\x01\n\x18PythonFunctionDescriptor\x12\x1f\n\x0bmodule\
    _name\x18\x01\x20\x01(\tR\nmoduleName\x12\x1d\n\nclass_name\x18\x02\x20\
    \x01(\tR\tclassName\x12#\n\rfunction_name\x18\x03\x20\x01(\tR\x0cfunctio\
    nName\x12#\n\rfunction_hash\x18\x04\x20\x01(\tR\x0cfunctionHash\"<\n\x15\
    CppFunctionDescriptor\x12#\n\rfunction_name\x18\x01\x20\x01(\tR\x0cfunct\
    ionName\"=\n\x16RustFunctionDescriptor\x12#\n\rfunction_name\x18\x01\x20\
    \x01(\tR\x0cfunctionName\"\xa2\x03\n\x12FunctionDescriptor\x12[\n\x18jav\
    a_function_descriptor\x18\x01\x20\x01(\x0b2\x1f.ray.rpc.JavaFunctionDesc\
    riptorH\0R\x16javaFunctionDescriptor\x12a\n\x1apython_function_descripto\
    r\x18\x02\x20\x01(\x0b2!.ray.rpc.PythonFunctionDescriptorH\0R\x18pythonF\
    unctionDescriptor\x12X\n\x17cpp_function_descriptor\x18\x03\x20\x01(\x0b\
    2\x1e.ray.rpc.CppFunctionDescriptorH\0R\x15cppFunctionDescriptor\x12[\n\
    \x18rust_function_descriptor\x18\x04\x20\x01(\x0b2\x1f.ray.rpc.RustFunct\
    ionDescriptorH\0R\x16rustFunctionDescriptorB\x15\n\x13function_descripto\
    r\"\x9f\x01\n\x10ConcurrencyGroup\x12\x12\n\x04name\x18\x01\x20\x01(\tR\
    \x04name\x12'\n\x0fmax_concurrency\x18\x02\x20\x01(\x05R\x0emaxConcurren\
    cy\x12N\n\x14function_descriptors\x18\x03\x20\x03(\x0b2\x1b.ray.rpc.Func\
    tionDescriptorR\x13functionDescriptors\"\xc5\x01\n\x0cRayErrorInfo\x12D\
    \n\x10actor_died_error\x18\x02\x20\x01(\x0b2\x18.ray.rpc.ActorDeathCause\
    H\0R\x0eactorDiedError\x12f\n\x1eruntime_env_setup_failed_error\x18\x03\
    \x20\x01(\x0b2\x20.ray.rpc.RuntimeEnvFailedContextH\0R\x1aruntimeEnvSetu\
    pFailedErrorB\x07\n\x05error\"\xae\x01\n\x0cRayException\x12-\n\x08langu\
    age\x18\x01\x20\x01(\x0e2\x11.ray.rpc.LanguageR\x08language\x121\n\x14se\
    rialized_exception\x18\x02\x20\x01(\x0cR\x13serializedException\x12<\n\
    \x1aformatted_exception_string\x18\x03\x20\x01(\tR\x18formattedException\
    String\"\xb4\x02\n\x0fActorDeathCause\x12Z\n\x1dcreation_task_failure_co\
    ntext\x18\x01\x20\x01(\x0b2\x15.ray.rpc.RayExceptionH\0R\x1acreationTask\
    FailureContext\x12_\n\x1aruntime_env_failed_context\x18\x02\x20\x01(\x0b\
    2\x20.ray.rpc.RuntimeEnvFailedContextH\0R\x17runtimeEnvFailedContext\x12\
    Y\n\x18actor_died_error_context\x18\x03\x20\x01(\x0b2\x1e.ray.rpc.ActorD\
    iedErrorContextH\0R\x15actorDiedErrorContextB\t\n\x07context\">\n\x17Run\
    timeEnvFailedContext\x12#\n\rerror_message\x18\x01\x20\x01(\tR\x0cerrorM\
    essage\"\xae\x02\n\x15ActorDiedErrorContext\x12#\n\rerror_message\x18\
    \x01\x20\x01(\tR\x0cerrorMessage\x12\x19\n\x08owner_id\x18\x02\x20\x01(\
    \x0cR\x07ownerId\x12(\n\x10owner_ip_address\x18\x03\x20\x01(\tR\x0eowner\
    IpAddress\x12&\n\x0fnode_ip_address\x18\x04\x20\x01(\tR\rnodeIpAddress\
    \x12\x10\n\x03pid\x18\x05\x20\x01(\rR\x03pid\x12\x12\n\x04name\x18\x06\
    \x20\x01(\tR\x04name\x12#\n\rray_namespace\x18\x07\x20\x01(\tR\x0crayNam\
    espace\x12\x1d\n\nclass_name\x18\x08\x20\x01(\tR\tclassName\x12\x19\n\
    \x08actor_id\x18\t\x20\x01(\x0cR\x07actorId\"\x80\x0b\n\x08TaskSpec\x12%\
    \n\x04type\x18\x01\x20\x01(\x0e2\x11.ray.rpc.TaskTypeR\x04type\x12\x12\n\
    \x04name\x18\x02\x20\x01(\tR\x04name\x12-\n\x08language\x18\x03\x20\x01(\
    \x0e2\x11.ray.rpc.LanguageR\x08language\x12L\n\x13function_descriptor\
    \x18\x04\x20\x01(\x0b2\x1b.ray.rpc.FunctionDescriptorR\x12functionDescri\
    ptor\x12\x15\n\x06job_id\x18\x05\x20\x01(\x0cR\x05jobId\x12\x17\n\x07tas\
    k_id\x18\x06\x20\x01(\x0cR\x06taskId\x12$\n\x0eparent_task_id\x18\x07\
    \x20\x01(\x0cR\x0cparentTaskId\x12%\n\x0eparent_counter\x18\x08\x20\x01(\
    \x04R\rparentCounter\x12\x1b\n\tcaller_id\x18\t\x20\x01(\x0cR\x08callerI\
    d\x127\n\x0ecaller_address\x18\n\x20\x01(\x0b2\x10.ray.rpc.AddressR\rcal\
    lerAddress\x12$\n\x04args\x18\x0b\x20\x03(\x0b2\x10.ray.rpc.TaskArgR\x04\
    args\x12\x1f\n\x0bnum_returns\x18\x0c\x20\x01(\x04R\nnumReturns\x12W\n\
    \x12required_resources\x18\r\x20\x03(\x0b2(.ray.rpc.TaskSpec.RequiredRes\
    ourcesEntryR\x11requiredResources\x12s\n\x1crequired_placement_resources\
    \x18\x0e\x20\x03(\x0b21.ray.rpc.TaskSpec.RequiredPlacementResourcesEntry\
    R\x1arequiredPlacementResources\x12W\n\x18actor_creation_task_spec\x18\
    \x0f\x20\x01(\x0b2\x1e.ray.rpc.ActorCreationTaskSpecR\x15actorCreationTa\
    skSpec\x12>\n\x0factor_task_spec\x18\x10\x20\x01(\x0b2\x16.ray.rpc.Actor\
    TaskSpecR\ractorTaskSpec\x12\x1f\n\x0bmax_retries\x18\x11\x20\x01(\x05R\
    \nmaxRetries\x12%\n\x0eskip_execution\x18\x15\x20\x01(\x08R\rskipExecuti\
    on\x12/\n\x13debugger_breakpoint\x18\x16\x20\x01(\x0cR\x12debuggerBreakp\
    oint\x12A\n\x10runtime_env_info\x18\x17\x20\x01(\x0b2\x17.ray.rpc.Runtim\
    eEnvInfoR\x0eruntimeEnvInfo\x124\n\x16concurrency_group_name\x18\x18\x20\
    \x01(\tR\x14concurrencyGroupName\x12)\n\x10retry_exceptions\x18\x19\x20\
    \x01(\x08R\x0fretryExceptions\x12\x14\n\x05depth\x18\x1a\x20\x01(\x03R\
    \x05depth\x12L\n\x13scheduling_strategy\x18\x1b\x20\x01(\x0b2\x1b.ray.rp\
    c.SchedulingStrategyR\x12schedulingStrategy\x12%\n\x0eattempt_number\x18\
    \x1c\x20\x01(\x04R\rattemptNumber\x1aD\n\x16RequiredResourcesEntry\x12\
    \x10\n\x03key\x18\x01\x20\x01(\tR\x03key\x12\x14\n\x05value\x18\x02\x20\
    \x01(\x01R\x05value:\x028\x01\x1aM\n\x1fRequiredPlacementResourcesEntry\
    \x12\x10\n\x03key\x18\x01\x20\x01(\tR\x03key\x12\x14\n\x05value\x18\x02\
    \x20\x01(\x01R\x05value:\x028\x01\"\xd2\x02\n\x06Bundle\x12=\n\tbundle_i\
    d\x18\x01\x20\x01(\x0b2\x20.ray.rpc.Bundle.BundleIdentifierR\x08bundleId\
    \x12I\n\x0eunit_resources\x18\x02\x20\x03(\x0b2\".ray.rpc.Bundle.UnitRes\
    ourcesEntryR\runitResources\x12\x17\n\x07node_id\x18\x03\x20\x01(\x0cR\
    \x06nodeId\x1ac\n\x10BundleIdentifier\x12,\n\x12placement_group_id\x18\
    \x01\x20\x01(\x0cR\x10placementGroupId\x12!\n\x0cbundle_index\x18\x02\
    \x20\x01(\x05R\x0bbundleIndex\x1a@\n\x12UnitResourcesEntry\x12\x10\n\x03\
    key\x18\x01\x20\x01(\tR\x03key\x12\x14\n\x05value\x18\x02\x20\x01(\x01R\
    \x05value:\x028\x01\"\x82\x03\n\x12PlacementGroupSpec\x12,\n\x12placemen\
    t_group_id\x18\x01\x20\x01(\x0cR\x10placementGroupId\x12\x12\n\x04name\
    \x18\x02\x20\x01(\tR\x04name\x12)\n\x07bundles\x18\x03\x20\x03(\x0b2\x0f\
    .ray.rpc.BundleR\x07bundles\x126\n\x08strategy\x18\x04\x20\x01(\x0e2\x1a\
    .ray.rpc.PlacementStrategyR\x08strategy\x12$\n\x0ecreator_job_id\x18\x05\
    \x20\x01(\x0cR\x0ccreatorJobId\x12(\n\x10creator_actor_id\x18\x06\x20\
    \x01(\x0cR\x0ecreatorActorId\x12(\n\x10creator_job_dead\x18\x07\x20\x01(\
    \x08R\x0ecreatorJobDead\x12,\n\x12creator_actor_dead\x18\x08\x20\x01(\
    \x08R\x10creatorActorDead\x12\x1f\n\x0bis_detached\x18\t\x20\x01(\x08R\n\
    isDetached\"\x82\x01\n\x0fObjectReference\x12\x1b\n\tobject_id\x18\x01\
    \x20\x01(\x0cR\x08objectId\x125\n\rowner_address\x18\x02\x20\x01(\x0b2\
    \x10.ray.rpc.AddressR\x0cownerAddress\x12\x1b\n\tcall_site\x18\x03\x20\
    \x01(\tR\x08callSite\"\xbf\x02\n\x14ObjectReferenceCount\x126\n\treferen\
    ce\x18\x01\x20\x01(\x0b2\x18.ray.rpc.ObjectReferenceR\treference\x12\"\n\
    \rhas_local_ref\x18\x02\x20\x01(\x08R\x0bhasLocalRef\x12.\n\tborrowers\
    \x18\x03\x20\x03(\x0b2\x10.ray.rpc.AddressR\tborrowers\x12D\n\x11stored_\
    in_objects\x18\x04\x20\x03(\x0b2\x18.ray.rpc.ObjectReferenceR\x0fstoredI\
    nObjects\x129\n\x19contained_in_borrowed_ids\x18\x05\x20\x03(\x0cR\x16co\
    ntainedInBorrowedIds\x12\x1a\n\x08contains\x18\x06\x20\x03(\x0cR\x08cont\
    ains\"\xbc\x01\n\x07TaskArg\x127\n\nobject_ref\x18\x01\x20\x01(\x0b2\x18\
    .ray.rpc.ObjectReferenceR\tobjectRef\x12\x12\n\x04data\x18\x02\x20\x01(\
    \x0cR\x04data\x12\x1a\n\x08metadata\x18\x03\x20\x01(\x0cR\x08metadata\
    \x12H\n\x13nested_inlined_refs\x18\x04\x20\x03(\x0b2\x18.ray.rpc.ObjectR\
    eferenceR\x11nestedInlinedRefs\"\xe8\x04\n\x15ActorCreationTaskSpec\x12\
    \x19\n\x08actor_id\x18\x02\x20\x01(\x0cR\x07actorId\x12,\n\x12max_actor_\
    restarts\x18\x03\x20\x01(\x03R\x10maxActorRestarts\x12(\n\x10max_task_re\
    tries\x18\x04\x20\x01(\x03R\x0emaxTaskRetries\x124\n\x16dynamic_worker_o\
    ptions\x18\x05\x20\x03(\tR\x14dynamicWorkerOptions\x12'\n\x0fmax_concurr\
    ency\x18\x06\x20\x01(\x05R\x0emaxConcurrency\x12\x1f\n\x0bis_detached\
    \x18\x07\x20\x01(\x08R\nisDetached\x12\x12\n\x04name\x18\x08\x20\x01(\tR\
    \x04name\x12#\n\rray_namespace\x18\t\x20\x01(\tR\x0crayNamespace\x12\x1d\
    \n\nis_asyncio\x18\n\x20\x01(\x08R\tisAsyncio\x12%\n\x0eextension_data\
    \x18\x0b\x20\x01(\tR\rextensionData\x126\n\x17serialized_actor_handle\
    \x18\x0c\x20\x01(\x0cR\x15serializedActorHandle\x12H\n\x12concurrency_gr\
    oups\x18\r\x20\x03(\x0b2\x19.ray.rpc.ConcurrencyGroupR\x11concurrencyGro\
    ups\x12/\n\x14execute_out_of_order\x18\x0e\x20\x01(\x08R\x11executeOutOf\
    Order\x12*\n\x11max_pending_calls\x18\x0f\x20\x01(\x05R\x0fmaxPendingCal\
    ls\"\xe0\x01\n\rActorTaskSpec\x12\x19\n\x08actor_id\x18\x02\x20\x01(\x0c\
    R\x07actorId\x12B\n\x1eactor_creation_dummy_object_id\x18\x04\x20\x01(\
    \x0cR\x1aactorCreationDummyObjectId\x12#\n\ractor_counter\x18\x05\x20\
    \x01(\x04R\x0cactorCounter\x12K\n#previous_actor_task_dummy_object_id\
    \x18\x07\x20\x01(\x0cR\x1epreviousActorTaskDummyObjectId\"6\n\x04Task\
    \x12.\n\ttask_spec\x18\x01\x20\x01(\x0b2\x11.ray.rpc.TaskSpecR\x08taskSp\
    ec\">\n\nResourceId\x12\x14\n\x05index\x18\x01\x20\x01(\x03R\x05index\
    \x12\x1a\n\x08quantity\x18\x02\x20\x01(\x01R\x08quantity\"^\n\x10Resourc\
    eMapEntry\x12\x12\n\x04name\x18\x01\x20\x01(\tR\x04name\x126\n\x0cresour\
    ce_ids\x18\x02\x20\x03(\x0b2\x13.ray.rpc.ResourceIdR\x0bresourceIds\"\
    \xf4\x03\n\x08ViewData\x12\x1b\n\tview_name\x18\x01\x20\x01(\tR\x08viewN\
    ame\x125\n\x08measures\x18\x02\x20\x03(\x0b2\x19.ray.rpc.ViewData.Measur\
    eR\x08measures\x1a\x93\x03\n\x07Measure\x12\x12\n\x04tags\x18\x01\x20\
    \x01(\tR\x04tags\x12\x1b\n\tint_value\x18\x02\x20\x01(\x03R\x08intValue\
    \x12!\n\x0cdouble_value\x18\x03\x20\x01(\x01R\x0bdoubleValue\x12)\n\x10d\
    istribution_min\x18\x04\x20\x01(\x01R\x0fdistributionMin\x12+\n\x11distr\
    ibution_mean\x18\x05\x20\x01(\x01R\x10distributionMean\x12)\n\x10distrib\
    ution_max\x18\x06\x20\x01(\x01R\x0fdistributionMax\x12-\n\x12distributio\
    n_count\x18\x07\x20\x01(\x01R\x11distributionCount\x12D\n\x1edistributio\
    n_bucket_boundaries\x18\x08\x20\x03(\x01R\x1cdistributionBucketBoundarie\
    s\x12<\n\x1adistribution_bucket_counts\x18\t\x20\x03(\x01R\x18distributi\
    onBucketCounts\"\x80\x03\n\rObjectRefInfo\x12\x1b\n\tobject_id\x18\x01\
    \x20\x01(\x0cR\x08objectId\x12\x1b\n\tcall_site\x18\x02\x20\x01(\tR\x08c\
    allSite\x12\x1f\n\x0bobject_size\x18\x03\x20\x01(\x03R\nobjectSize\x12&\
    \n\x0flocal_ref_count\x18\x04\x20\x01(\x03R\rlocalRefCount\x127\n\x18sub\
    mitted_task_ref_count\x18\x05\x20\x01(\x03R\x15submittedTaskRefCount\x12\
    ,\n\x12contained_in_owned\x18\x06\x20\x03(\x0cR\x10containedInOwned\x12(\
    \n\x10pinned_in_memory\x18\x07\x20\x01(\x08R\x0epinnedInMemory\x124\n\
    \x0btask_status\x18\x08\x20\x01(\x0e2\x13.ray.rpc.TaskStatusR\ntaskStatu\
    s\x12%\n\x0eattempt_number\x18\t\x20\x01(\x04R\rattemptNumber\"\xab\x01\
    \n\x13ResourceAllocations\x12P\n\x0eresource_slots\x18\x01\x20\x03(\x0b2\
    ).ray.rpc.ResourceAllocations.ResourceSlotR\rresourceSlots\x1aB\n\x0cRes\
    ourceSlot\x12\x12\n\x04slot\x18\x01\x20\x01(\x03R\x04slot\x12\x1e\n\nall\
    ocation\x18\x02\x20\x01(\x01R\nallocation\"\xfe\x08\n\x0fCoreWorkerStats\
    \x12*\n\x11current_task_desc\x18\x01\x20\x01(\tR\x0fcurrentTaskDesc\x12*\
    \n\x11num_pending_tasks\x18\x02\x20\x01(\x05R\x0fnumPendingTasks\x126\n\
    \x18num_object_refs_in_scope\x18\x03\x20\x01(\x05R\x14numObjectRefsInSco\
    pe\x12*\n\x11current_task_name\x18\x04\x20\x01(\tR\x0fcurrentTaskName\
    \x123\n\x16current_task_func_desc\x18\x05\x20\x01(\tR\x13currentTaskFunc\
    Desc\x12\x1d\n\nip_address\x18\x07\x20\x01(\tR\tipAddress\x12\x12\n\x04p\
    ort\x18\x08\x20\x01(\x03R\x04port\x12\x19\n\x08actor_id\x18\t\x20\x01(\
    \x0cR\x07actorId\x12R\n\x0eused_resources\x18\n\x20\x03(\x0b2+.ray.rpc.C\
    oreWorkerStats.UsedResourcesEntryR\rusedResources\x12O\n\rwebui_display\
    \x18\x0b\x20\x03(\x0b2*.ray.rpc.CoreWorkerStats.WebuiDisplayEntryR\x0cwe\
    buiDisplay\x12\"\n\rnum_in_plasma\x18\x0c\x20\x01(\x05R\x0bnumInPlasma\
    \x12*\n\x11num_local_objects\x18\r\x20\x01(\x05R\x0fnumLocalObjects\x127\
    \n\x18used_object_store_memory\x18\x0e\x20\x01(\x03R\x15usedObjectStoreM\
    emory\x12*\n\x11task_queue_length\x18\x0f\x20\x01(\x05R\x0ftaskQueueLeng\
    th\x12,\n\x12num_executed_tasks\x18\x10\x20\x01(\x05R\x10numExecutedTask\
    s\x12\x1f\n\x0bactor_title\x18\x11\x20\x01(\tR\nactorTitle\x127\n\x0bobj\
    ect_refs\x18\x12\x20\x03(\x0b2\x16.ray.rpc.ObjectRefInfoR\nobjectRefs\
    \x12\x15\n\x06job_id\x18\x13\x20\x01(\x0cR\x05jobId\x12\x1b\n\tworker_id\
    \x18\x14\x20\x01(\x0cR\x08workerId\x12-\n\x08language\x18\x15\x20\x01(\
    \x0e2\x11.ray.rpc.LanguageR\x08language\x12\x10\n\x03pid\x18\x16\x20\x01\
    (\rR\x03pid\x124\n\x0bworker_type\x18\x17\x20\x01(\x0e2\x13.ray.rpc.Work\
    erTypeR\nworkerType\x1a^\n\x12UsedResourcesEntry\x12\x10\n\x03key\x18\
    \x01\x20\x01(\tR\x03key\x122\n\x05value\x18\x02\x20\x01(\x0b2\x1c.ray.rp\
    c.ResourceAllocationsR\x05value:\x028\x01\x1a?\n\x11WebuiDisplayEntry\
    \x12\x10\n\x03key\x18\x01\x20\x01(\tR\x03key\x12\x14\n\x05value\x18\x02\
    \x20\x01(\tR\x05value:\x028\x01\"\x87\x02\n\x0bMetricPoint\x12\x1f\n\x0b\
    metric_name\x18\x01\x20\x01(\tR\nmetricName\x12\x1c\n\ttimestamp\x18\x02\
    \x20\x01(\x03R\ttimestamp\x12\x14\n\x05value\x18\x03\x20\x01(\x01R\x05va\
    lue\x122\n\x04tags\x18\x04\x20\x03(\x0b2\x1e.ray.rpc.MetricPoint.TagsEnt\
    ryR\x04tags\x12\x20\n\x0bdescription\x18\x05\x20\x01(\tR\x0bdescription\
    \x12\x14\n\x05units\x18\x06\x20\x01(\tR\x05units\x1a7\n\tTagsEntry\x12\
    \x10\n\x03key\x18\x01\x20\x01(\tR\x03key\x12\x14\n\x05value\x18\x02\x20\
    \x01(\tR\x05value:\x028\x01\"I\n\x0eNamedActorInfo\x12#\n\rray_namespace\
    \x18\x01\x20\x01(\tR\x0crayNamespace\x12\x12\n\x04name\x18\x02\x20\x01(\
    \tR\x04name*3\n\x08Language\x12\n\n\x06PYTHON\x10\0\x12\x08\n\x04JAVA\
    \x10\x01\x12\x07\n\x03CPP\x10\x02\x12\x08\n\x04RUST\x10\x03*J\n\nWorkerT\
    ype\x12\n\n\x06WORKER\x10\0\x12\n\n\x06DRIVER\x10\x01\x12\x10\n\x0cSPILL\
    _WORKER\x10\x02\x12\x12\n\x0eRESTORE_WORKER\x10\x03*U\n\x08TaskType\x12\
    \x0f\n\x0bNORMAL_TASK\x10\0\x12\x17\n\x13ACTOR_CREATION_TASK\x10\x01\x12\
    \x0e\n\nACTOR_TASK\x10\x02\x12\x0f\n\x0bDRIVER_TASK\x10\x03*\xfc\x03\n\t\
    ErrorType\x12\x0f\n\x0bWORKER_DIED\x10\0\x12\x0e\n\nACTOR_DIED\x10\x01\
    \x12\x1c\n\x18OBJECT_UNRECONSTRUCTABLE\x10\x02\x12\x1c\n\x18TASK_EXECUTI\
    ON_EXCEPTION\x10\x03\x12\x14\n\x10OBJECT_IN_PLASMA\x10\x04\x12\x12\n\x0e\
    TASK_CANCELLED\x10\x05\x12\x19\n\x15ACTOR_CREATION_FAILED\x10\x06\x12\
    \x1c\n\x18RUNTIME_ENV_SETUP_FAILED\x10\x07\x12\x0f\n\x0bOBJECT_LOST\x10\
    \x08\x12\x0e\n\nOWNER_DIED\x10\t\x12\x12\n\x0eOBJECT_DELETED\x10\n\x12\
    \x20\n\x1cDEPENDENCY_RESOLUTION_FAILED\x10\x0b\x122\n.OBJECT_UNRECONSTRU\
    CTABLE_MAX_ATTEMPTS_EXCEEDED\x10\x0c\x12,\n(OBJECT_UNRECONSTRUCTABLE_LIN\
    EAGE_EVICTED\x10\r\x12\x1a\n\x16OBJECT_FETCH_TIMED_OUT\x10\x0e\x12\x15\n\
    \x11LOCAL_RAYLET_DIED\x10\x0f\x12\x20\n\x1cTASK_PLACEMENT_GROUP_REMOVED\
    \x10\x10\x12!\n\x1dACTOR_PLACEMENT_GROUP_REMOVED\x10\x11*P\n\nTaskStatus\
    \x12\x07\n\x03NIL\x10\0\x12\x1c\n\x18WAITING_FOR_DEPENDENCIES\x10\x01\
    \x12\r\n\tSCHEDULED\x10\x02\x12\x0c\n\x08FINISHED\x10\x03*\xac\x01\n\x0e\
    WorkerExitType\x12\x15\n\x11SYSTEM_ERROR_EXIT\x10\0\x12\x11\n\rINTENDED_\
    EXIT\x10\x01\x12\x1c\n\x18UNUSED_RESOURCE_RELEASED\x10\x02\x12\x1b\n\x17\
    PLACEMENT_GROUP_REMOVED\x10\x03\x12\x17\n\x13CREATION_TASK_ERROR\x10\x04\
    \x12\r\n\tIDLE_EXIT\x10\x05\x12\r\n\tNODE_DIED\x10\x06*M\n\x11PlacementS\
    trategy\x12\x08\n\x04PACK\x10\0\x12\n\n\x06SPREAD\x10\x01\x12\x0f\n\x0bS\
    TRICT_PACK\x10\x02\x12\x11\n\rSTRICT_SPREAD\x10\x03B\x1d\n\x18io.ray.run\
    time.generated\xf8\x01\x01b\x06proto3\
";

static file_descriptor_proto_lazy: ::protobuf::rt::LazyV2<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::rt::LazyV2::INIT;

fn parse_descriptor_proto() -> ::protobuf::descriptor::FileDescriptorProto {
    ::protobuf::parse_from_bytes(file_descriptor_proto_data).unwrap()
}

pub fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    file_descriptor_proto_lazy.get(|| {
        parse_descriptor_proto()
    })
}
