from __future__ import absolute_import
from __future__ import division
from __future__ import print_function

from collections import defaultdict

import ray
import ray.cloudpickle as cloudpickle


class Signal(object):
    """Base class for Ray signals."""
    pass


class ErrorSignal(Signal):
    """Signal raised if an exception happens in a task or actor method."""

    def __init__(self, error):
        self.error = error

    def get_error(self):
        return self.error


def _get_task_id(source):
    """Return the task ID associated with the generic source of the signal.

    Args:
        source: source of the signal, it can be either an object ID, task ID,
            or actor handle.

    Returns:
        - If source is an object ID, return ID of task which creted object.
        - If source is an actor handle, return ID of actor's task creator.
        - If source is a task ID, return same task ID.
    """
    if type(source) is ray.actor.ActorHandle:
        return ray._raylet.compute_task_id(
            source._ray_actor_creation_dummy_object_id)
    else:
        if type(source) is ray.TaskID:
            return source
        else:
            return ray._raylet.compute_task_id(source)


def send(signal):
    """Send a signal to anyone listening for signals.

    Signals from the same sender are sent in order and they persist. The sender
    is the actor, task, or driver invoking this call. By "persist" we
    mean that all past signals can be red at a later time by another
    task, actor, or driver using receive().

    Args:
        signal: Signal to be sent.
    """
    # The signal has a unique identifier that is computed from (1) the ID
    # of the actor or task sending this signal (i.e., the actor or task calling
    # this function), and (2) an index that is incremented every time this
    # source sends a signal. This index starts from 1.
    if hasattr(ray.worker.global_worker, "actor_creation_task_id"):
        global_worker = ray.worker.global_worker
        source_key = global_worker.actor_creation_task_id.hex()
    else:
        # No actors; this function must have been called from a task
        source_key = ray.worker.global_worker.current_task_id.hex()

    encoded_signal = ray.utils.binary_to_hex(cloudpickle.dumps(signal))
    ray.worker.global_worker.redis_client.execute_command(
        "XADD " + source_key + " * signal " + encoded_signal)


def receive(sources, timeout=None):
    """Get all outstanding signals from sources.

    A source can be either (1) an object ID returned by the task (we want
    to receive signals from), or (2) an actor handle.

    When invoked by the same entity E (where E can be an actor, task or
    driver), for each source S in sources, this function returns all signals
    generated by S since the last receive() was invoked by E on S. If this is
    the first call on S, this function returns all past signals generated by S
    so far. Note that different actors, tasks or drivers that call receive()
    on the same source S will get independent copies of the signals generated
    by S.

    Args:
        sources: List of sources from which the caller waits for signals.
            A source is either an object ID returned by a task (in this case
            the object ID is used to Identify that task), or an actor handle.
            If the user passes the IDs of multiple objects returned by the
            same task, this function returns a copy of the signals generated
            by that task for each object ID.
        timeout: Maximum time (in seconds) this function waits to get a signal
            from a source in sources. If None, the timeout is infinite.

    Returns:
        A list of pairs (S, sig), where S is a source in the sources argument,
            and sig is a signal generated by S since the last time receive()
            was called on S. Thus, for each S in sources, the return list can
            contain zero or multiple entries.
    """

    # If None, initialize the timeout to a huge value (i.e., over 30,000 years
    # in this case) to "approximate" infinity.
    if timeout is None:
        timeout = 10**12

    if timeout < 0:
        raise ValueError("The 'timeout' argument cannot be less than 0.")

    if not hasattr(ray.worker.global_worker, "signal_counters"):
        ray.worker.global_worker.signal_counters = defaultdict(lambda: b"0")

    signal_counters = ray.worker.global_worker.signal_counters

    # Construct the redis query.
    query = "XREAD BLOCK "
    # Multiply by 1000x since timeout is in sec and redis expects ms.
    query += str(1000 * timeout)
    query += " STREAMS "
    query += " ".join([_get_task_id(source).hex() for source in sources])
    query += " "
    query += " ".join([
        ray.utils.decode(signal_counters[_get_task_id(source)])
        for source in sources
    ])

    answers = ray.worker.global_worker.redis_client.execute_command(query)
    if not answers:
        return []
    # There will be at most one answer per source. If there is no signal for
    # a given source, redis will provide no answer for that source.
    # Map the ID of each source s in sources to s itself.
    source_id_to_idx = {}
    for s in sources:
        source_id_to_idx[_get_task_id(s).hex()] = s

    results = []
    # Decoding is a little bit involved. Iterate through all the answers:
    for i, answer in enumerate(answers):
        # Make sure the answer corresponds to a source, s, in sources.
        assert ray.utils.decode(answer[0]) in source_id_to_idx
        s = source_id_to_idx[ray.utils.decode(answer[0])]
        # The list of results for source s is stored in answer[1]
        for r in answer[1]:
            # Now it gets tricky: r[0] is the redis internal sequence id
            signal_counters[_get_task_id(s)] = r[0]
            # r[1] contains a list with elements (key, value), in our case
            # we only have one key "signal" and the value is the signal.
            signal = cloudpickle.loads(ray.utils.hex_to_binary(r[1][1]))
            results.append((s, signal))

    return results


def reset():
    """
    Reset the worker state associated with any signals that this worker
    has received so far.

    If the worker calls receive() on a source next, it will get all the
    signals generated by that source starting with index = 1.
    """
    ray.worker.global_worker.signal_counters = defaultdict(lambda: b"0")
