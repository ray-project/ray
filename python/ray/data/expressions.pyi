"""Type stubs for ray.data.expressions module.

This file provides type hints for dynamically generated namespace methods
to enable IDE autocomplete and type checking.
"""

from __future__ import annotations

from enum import Enum
from typing import Any, Callable, Dict, List, Literal, Union

from ray.data.block import BatchColumn
from ray.data.datatype import DataType

# Re-export main classes
class Operation(Enum):
    ADD: str
    SUB: str
    MUL: str
    DIV: str
    FLOORDIV: str
    GT: str
    LT: str
    GE: str
    LE: str
    EQ: str
    NE: str
    AND: str
    OR: str
    NOT: str
    IS_NULL: str
    IS_NOT_NULL: str
    IN: str
    NOT_IN: str

class Expr:
    data_type: DataType

    @property
    def name(self) -> str | None: ...
    def structurally_equals(self, other: Any) -> bool: ...
    def to_pyarrow(self) -> Any: ...
    def __repr__(self) -> str: ...
    def _bin(self, other: Any, op: Operation) -> Expr: ...

    # Arithmetic
    def __add__(self, other: Any) -> Expr: ...
    def __radd__(self, other: Any) -> Expr: ...
    def __sub__(self, other: Any) -> Expr: ...
    def __rsub__(self, other: Any) -> Expr: ...
    def __mul__(self, other: Any) -> Expr: ...
    def __rmul__(self, other: Any) -> Expr: ...
    def __truediv__(self, other: Any) -> Expr: ...
    def __rtruediv__(self, other: Any) -> Expr: ...
    def __floordiv__(self, other: Any) -> Expr: ...
    def __rfloordiv__(self, other: Any) -> Expr: ...

    # Comparison
    def __gt__(self, other: Any) -> Expr: ...
    def __lt__(self, other: Any) -> Expr: ...
    def __ge__(self, other: Any) -> Expr: ...
    def __le__(self, other: Any) -> Expr: ...
    def __eq__(self, other: Any) -> Expr: ...
    def __ne__(self, other: Any) -> Expr: ...

    # Boolean
    def __and__(self, other: Any) -> Expr: ...
    def __or__(self, other: Any) -> Expr: ...
    def __invert__(self) -> Expr: ...

    # Predicates
    def is_null(self) -> Expr: ...
    def is_not_null(self) -> Expr: ...
    def is_in(self, values: Union[List[Any], Expr]) -> Expr: ...
    def not_in(self, values: Union[List[Any], Expr]) -> Expr: ...

    def alias(self, name: str) -> Expr: ...

    # Namespace accessors
    @property
    def list(self) -> _ListNamespace: ...
    @property
    def str(self) -> _StringNamespace: ...
    @property
    def struct(self) -> _StructNamespace: ...

    def _unalias(self) -> Expr: ...

class ColumnExpr(Expr):
    _name: str
    @property
    def name(self) -> str: ...
    def _rename(self, name: str) -> AliasExpr: ...
    def structurally_equals(self, other: Any) -> bool: ...

class LiteralExpr(Expr):
    value: Any
    def structurally_equals(self, other: Any) -> bool: ...

class BinaryExpr(Expr):
    op: Operation
    left: Expr
    right: Expr
    def structurally_equals(self, other: Any) -> bool: ...

class UnaryExpr(Expr):
    op: Operation
    operand: Expr
    def structurally_equals(self, other: Any) -> bool: ...

class UDFExpr(Expr):
    fn: Callable[..., BatchColumn]
    args: List[Expr]
    kwargs: Dict[str, Expr]
    def structurally_equals(self, other: Any) -> bool: ...

class DownloadExpr(Expr):
    uri_column_name: str
    def structurally_equals(self, other: Any) -> bool: ...

class AliasExpr(Expr):
    expr: Expr
    _name: str
    _is_rename: bool
    @property
    def name(self) -> str: ...
    def alias(self, name: str) -> Expr: ...
    def _unalias(self) -> Expr: ...
    def structurally_equals(self, other: Any) -> bool: ...

class StarExpr(Expr):
    def structurally_equals(self, other: Any) -> bool: ...

# ──────────────────────────────────────
# Namespace Classes with Full Method Signatures
# ──────────────────────────────────────

class _ListNamespace:
    """Namespace for list operations."""
    _expr: Expr

    # Indexing and slicing
    def __getitem__(self, key: Union[int, slice]) -> UDFExpr: ...
    def get(self, index: int) -> UDFExpr: ...
    def slice(self, start: int = None, stop: int = None, step: int = None) -> UDFExpr: ...

    # Auto-generated methods
    def len(self) -> UDFExpr: ...
    def flatten(self) -> UDFExpr: ...

class _StringNamespace:
    """Namespace for string operations."""
    _expr: Expr

    # Auto-generated length methods
    def len(self) -> UDFExpr: ...
    def byte_len(self) -> UDFExpr: ...

    # Auto-generated case conversion
    def upper(self) -> UDFExpr: ...
    def lower(self) -> UDFExpr: ...
    def capitalize(self) -> UDFExpr: ...
    def title(self) -> UDFExpr: ...
    def swapcase(self) -> UDFExpr: ...

    # Auto-generated predicates
    def is_alpha(self) -> UDFExpr: ...
    def is_alnum(self) -> UDFExpr: ...
    def is_digit(self) -> UDFExpr: ...
    def is_decimal(self) -> UDFExpr: ...
    def is_numeric(self) -> UDFExpr: ...
    def is_space(self) -> UDFExpr: ...
    def is_lower(self) -> UDFExpr: ...
    def is_upper(self) -> UDFExpr: ...
    def is_title(self) -> UDFExpr: ...
    def is_printable(self) -> UDFExpr: ...
    def is_ascii(self) -> UDFExpr: ...

    # Auto-generated searching (parameterized)
    def starts_with(self, pattern: str, ignore_case: bool = False) -> UDFExpr: ...
    def ends_with(self, pattern: str, ignore_case: bool = False) -> UDFExpr: ...
    def contains(self, pattern: str, ignore_case: bool = False) -> UDFExpr: ...
    def match(self, pattern: str, ignore_case: bool = False) -> UDFExpr: ...
    def find(self, pattern: str, ignore_case: bool = False) -> UDFExpr: ...
    def count(self, pattern: str, ignore_case: bool = False) -> UDFExpr: ...
    def find_regex(self, pattern: str, ignore_case: bool = False) -> UDFExpr: ...
    def count_regex(self, pattern: str, ignore_case: bool = False) -> UDFExpr: ...
    def match_regex(self, pattern: str, ignore_case: bool = False) -> UDFExpr: ...

    # Auto-generated transformations
    def reverse(self) -> UDFExpr: ...

    # Manual methods (complex logic)
    def strip(self, characters: str = None) -> UDFExpr: ...
    def lstrip(self, characters: str = None) -> UDFExpr: ...
    def rstrip(self, characters: str = None) -> UDFExpr: ...
    def pad(
        self,
        width: int,
        fillchar: str = " ",
        side: Literal["left", "right", "both"] = "right",
    ) -> UDFExpr: ...
    def center(self, width: int, fillchar: str = " ") -> UDFExpr: ...
    def slice(self, start: int, stop: int = None, step: int = 1) -> UDFExpr: ...
    def replace(
        self, pattern: str, replacement: str, max_replacements: int = None
    ) -> UDFExpr: ...
    def replace_regex(
        self, pattern: str, replacement: str, max_replacements: int = None
    ) -> UDFExpr: ...
    def replace_slice(self, start: int, stop: int, replacement: str) -> UDFExpr: ...
    def split(
        self, pattern: str, max_splits: int = None, reverse: bool = False
    ) -> UDFExpr: ...
    def split_regex(
        self, pattern: str, max_splits: int = None, reverse: bool = False
    ) -> UDFExpr: ...
    def split_whitespace(
        self, max_splits: int = None, reverse: bool = False
    ) -> UDFExpr: ...
    def extract(self, pattern: str) -> UDFExpr: ...
    def repeat(self, n: int) -> UDFExpr: ...

class _StructNamespace:
    """Namespace for struct operations."""
    _expr: Expr

    def __getitem__(self, field_name: str) -> UDFExpr: ...
    def field(self, field_name: str) -> UDFExpr: ...

# ──────────────────────────────────────
# Public API Functions
# ──────────────────────────────────────

def col(name: str) -> ColumnExpr: ...
def lit(value: Any) -> LiteralExpr: ...
def star() -> StarExpr: ...
def download(uri_column_name: str) -> DownloadExpr: ...
def udf(return_dtype: DataType) -> Callable[..., Callable[..., UDFExpr]]: ...

__all__ = [
    "Operation",
    "Expr",
    "ColumnExpr",
    "LiteralExpr",
    "BinaryExpr",
    "UnaryExpr",
    "UDFExpr",
    "DownloadExpr",
    "AliasExpr",
    "StarExpr",
    "udf",
    "col",
    "lit",
    "download",
    "star",
]
