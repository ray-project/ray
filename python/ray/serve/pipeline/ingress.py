from ray.experimental.dag import DAGNode
from ray.ml.checkpoint import Checkpoint
from ray.ml.predictor import Predictor

import ray


class PipelineIngressModel(Predictor):
    def __init__(self, dag: DAGNode):
        self.dag = dag

    @classmethod
    def from_checkpoint(cls, checkpoint: "PipelineIngressCheckpoint") -> "Predictor":
        assert isinstance(checkpoint, PipelineIngressCheckpoint)
        return cls(checkpoint.dag)

    def predict(self, data) -> ray.ObjectRef:
        return self.dag.execute(data)


class PipelineIngressCheckpoint(Checkpoint):
    def __init__(self, serve_dag_node_json):
        import json

        from ray.serve.pipeline.json_serde import dagnode_from_json

        self.dag: DAGNode = json.loads(
            serve_dag_node_json, object_hook=dagnode_from_json
        )

    @classmethod
    def from_uri(cls, serve_dag_node_json):
        return PipelineIngressCheckpoint(serve_dag_node_json)


# TODO: make ingress _a_ model wrapper
# TODO: implement a forward func for model wrapper so they can used in pipeline
# class Ingress:
#     """User facing HTTP component of a serve pipeline. Generated by default."""

#     def __init__(
#         self,
#         serve_dag_node_json: str,
#         preprocessor_import_path: str,
#     ):
#         module_name, attr_name = parse_import_path(preprocessor_import_path)
#         self.preprocessor = getattr(import_module(module_name), attr_name)

#     async def __call__(self, request: starlette.requests.Request):
#         # TODO (jiaodong, simonmo): Integrate with ModelWrapper
#         user_input_python = await self.preprocessor(request)
#         return await self.dag.execute(user_input_python)
