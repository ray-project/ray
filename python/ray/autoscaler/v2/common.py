
from dataclasses import dataclass
from typing import Dict, List, Tuple, Any, Optional
from ray.core.generated.experimental import autoscaler_pb2

from ray.autoscaler._private.util import (
    NodeIP,
    NodeType,
)

from ray.autoscaler._private.node_provider_availability_tracker import (
    NodeAvailabilitySummary,
)

@dataclass
class LaunchRequest:
    # The ray node type, e.g. worker node.
    node_type: NodeType
    # Number of nodes to launch in the request.
    count: int
    # The request created timestamp.
    created_ts: int

@dataclass
class PlacementGroupInfo:
    # Placement group ID
    pg_id: str
    # Placement group strategy, e.g. SPREAD, STRICT_SPREAD,
    strategy: str



@dataclass
class ResourceRequest:
    # Bundles 
    bundles: Dict[str, float]
    # If this is a request as part of placement groups. 
    pg_info: Optional[PlacementGroupInfo]

    #TODO(rickyx): We could include actors/tasks info in the future if this is a 
    # resource requests generated by tasks/actors. For now, if a resource request
    # doesn't have pg_info, it's a request generated by tasks/actors.


@dataclass
class ClusterStatus:
    # A list of nodes in the cluster (active, or dead), reported by GCS.
    nodes: List[autoscaler_pb2.NodeState]
    # A map of pending launch requests reported by the autoscaler/node provider.
    pending_launches: List[LaunchRequest]
    # A list of pending resource requests 
    pending_resource_requests: List[ResourceRequest]
    # Cluster resource constraint
    cluster_resource_constraint: List[ResourceRequest]
    # TODO(rickyx): I am not sure how useful this is actually. But keeping it for
    # backward compatibility as for now.
    node_availability_summary: Optional[NodeAvailabilitySummary]


    def format_str(self, verbose=False):
        # This could be what the `ray status` is getting.
        return "not implemented"





