syntax = "proto3";

message Int {
  int64 data = 1;
}

message String {
  string data = 1;
}

message Double {
  double data = 1;
}

// Empty used to represent a None object
message Empty {
}

message Bool {
  bool data = 1;
}

message PyObj {
  bytes data = 1;
}

// Union of possible object types
message Obj {
  String string_data = 1;
  Int int_data = 2;
  Double double_data = 3;
  Bool bool_data = 10;
  Tuple tuple_data = 7;
  List list_data = 4;
  Dict dict_data = 8;
  Array array_data = 5;
  Empty empty_data = 9;
  PyObj pyobj_data = 6;
}

message List {
  repeated Obj elem = 1;
}

message Tuple {
  repeated Obj elem = 1;
}

message DictEntry {
  Obj key = 1;
  Obj value = 2;
}

message Dict {
  repeated DictEntry elem = 1;
}

message Value {
  uint64 ref = 1; // For pass by reference
  Obj obj = 2; // For pass by value
}

message Task {
  string name = 1; // Name of the function call
  repeated Value arg = 2; // List of arguments, can be either object references or protobuf descriptions of object passed by value
  repeated uint64 result = 3; // Object references for result
}

message Push {
  uint64 objref = 1; // The objref for the pushed object
}

// This is used internally by the scheduler. From the scheduler's perspective,
// the submission of tasks (via SubmitTask) and the submission of pushes (via
// PushObj) look very similar, and so it is useful to be able to handle them
// together (for example in the computation graph).
message Operation {
  Task task = 1;
  Push push = 2;
  uint64 creator_operationid = 3; // The id of the task that called this task or push.
}

message Array {
  repeated uint64 shape = 1;
  sint64 dtype = 2;
  repeated double double_data = 3;
  repeated float float_data = 4;
  repeated sint64 int_data = 5;
  repeated uint64 uint_data = 6;
  repeated uint64 objref_data = 7;
}
